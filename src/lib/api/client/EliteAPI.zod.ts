/**
 * Generated by orval v7.16.0 üç∫
 * Do not edit manually.
 * Elite API
 * A backend API for https://elitebot.dev/ that provides Hypixel Skyblock data.
<br><br>
Use of this API requires following the [Elite API TOS](https://elitebot.dev/apiterms). This API is not affiliated with Hypixel or Mojang.
 * OpenAPI spec version: v1
 */
import * as zod from 'zod';

/**
 * Retrieves the Minecraft account information for a given player, along with an overview of their profiles and player data.
 * @summary Get Account
 */
export const zodGetAccountParams = zod.object({
	player: zod.string().describe('Player uuid or ign'),
});

export const zodGetAccountResponseSettingsFeaturesEmbedColorMax = 6;

export const zodGetAccountResponseSettingsFeaturesEmojiUrlMax = 256;

export const zodGetAccountResponseSettingsWeightStyleNameMax = 64;

export const zodGetAccountResponseSettingsLeaderboardStyleNameMax = 64;

export const zodGetAccountResponseSettingsNameStyleNameMax = 64;

export const zodGetAccountResponseProfilesItemMembersItemMetaPrefixMax = 16;

export const zodGetAccountResponseProfilesItemMembersItemMetaSuffixMax = 16;

export const zodGetAccountResponseBadgesItemImageTitleMax = 64;

export const zodGetAccountResponseBadgesItemImageDescriptionMax = 512;

export const zodGetAccountResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	formattedName: zod.string(),
	primaryAccount: zod.coerce.boolean<boolean>(),
	discordId: zod.string().nullish(),
	discordUsername: zod.string().nullish(),
	discordAvatar: zod.string().nullish(),
	settings: zod.object({
		prefix: zod.string().nullish().describe('Custom name prefix'),
		suffix: zod.string().nullish().describe('Custom name suffix'),
		features: zod
			.object({
				weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
				weightStyleOverride: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe("Ability to override other's weight styles."),
				embedColor: zod
					.string()
					.max(zodGetAccountResponseSettingsFeaturesEmbedColorMax)
					.nullish()
					.describe('Embed color for the bot.'),
				moreInfoDefault: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Show \"More Info\" on weight command by default.'),
				hideShopPromotions: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('If shop promotions should be hidden.'),
				emojiUrl: zod
					.string()
					.max(zodGetAccountResponseSettingsFeaturesEmojiUrlMax)
					.nullish()
					.describe('Custom name emoji URL.'),
			})
			.nullish()
			.describe('Configurated features for the user'),
		weightStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountResponseSettingsWeightStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected weight style for the user'),
		leaderboardStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountResponseSettingsLeaderboardStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected leaderboard style for the user'),
		nameStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountResponseSettingsNameStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected name style for the user'),
		fortune: zod
			.object({
				accounts: zod
					.record(
						zod.string(),
						zod.record(
							zod.string(),
							zod.object({
								strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
								communityCenter: zod.number().describe('Community center farming fortune level'),
								rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
								attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
								chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
							})
						)
					)
					.describe('Member fortune settings for each minecraft account, then each profile.'),
			})
			.nullish()
			.describe('Fortune settings for the user'),
	}),
	skin: zod.object({
		texture: zod.string().nullish().describe('Minecraft skin texture ID'),
		face: zod.string().nullish().describe('Base64 data image of the 8x8 face'),
		hat: zod.string().nullish().describe('Base64 data image of the 8x8 hat (overlay on the face)'),
	}),
	profiles: zod.array(
		zod.object({
			profileId: zod.string(),
			profileName: zod.string(),
			gameMode: zod.string(),
			selected: zod.coerce.boolean<boolean>(),
			bankBalance: zod.number(),
			deleted: zod.coerce.boolean<boolean>(),
			members: zod.array(
				zod.object({
					uuid: zod.string(),
					username: zod.string(),
					profileName: zod.string().nullish(),
					active: zod.coerce.boolean<boolean>(),
					farmingWeight: zod.number(),
					meta: zod
						.object({
							prefix: zod
								.string()
								.max(zodGetAccountResponseProfilesItemMembersItemMetaPrefixMax)
								.nullish(),
							suffix: zod
								.string()
								.max(zodGetAccountResponseProfilesItemMembersItemMetaSuffixMax)
								.nullish(),
							leaderboard: zod
								.object({
									styleId: zod.number().nullish(),
									backgroundColor: zod.string().nullish(),
									borderColor: zod.string().nullish(),
									textColor: zod.string().nullish(),
									rankColor: zod.string().nullish(),
									backgroundImage: zod.string().nullish(),
									overlayImage: zod.string().nullish(),
								})
								.nullish(),
						})
						.nullish(),
				})
			),
		})
	),
	badges: zod.array(
		zod.object({
			id: zod.number(),
			image: zod.object({
				title: zod.string().max(zodGetAccountResponseBadgesItemImageTitleMax).nullish().describe('Image title'),
				description: zod
					.string()
					.max(zodGetAccountResponseBadgesItemImageDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			}),
			name: zod.string(),
			description: zod.string(),
			requirements: zod.string(),
			timestamp: zod.string(),
			visible: zod.coerce.boolean<boolean>(),
			order: zod.number(),
		})
	),
	playerData: zod
		.object({
			uuid: zod.string(),
			displayname: zod.string().nullish(),
			firstLogin: zod.number(),
			lastLogin: zod.number(),
			lastLogout: zod.number(),
			karma: zod.number(),
			networkExp: zod.number(),
			guildMember: zod
				.object({
					guild: zod
						.object({
							id: zod.string(),
							name: zod.string(),
							createdAt: zod.number(),
							tag: zod.string().nullish(),
							tagColor: zod.string().nullish(),
							memberCount: zod.number(),
							lastUpdated: zod.number(),
							stats: zod
								.object({
									recordedAt: zod.iso.datetime({}),
									memberCount: zod.number(),
									hypixelLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skyblockExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skillLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									slayerExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									catacombsExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									farmingWeight: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									networth: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
								})
								.nullish(),
							amount: zod
								.number()
								.describe('Populated when sorting guilds by a specific collection or skill'),
						})
						.nullish(),
					rank: zod.string().nullish(),
					joinedAt: zod.number(),
					questParticipation: zod.number(),
					active: zod.coerce.boolean<boolean>(),
					expHistory: zod.record(zod.string(), zod.number()),
				})
				.nullish(),
			rewardHighScore: zod.number(),
			rewardScore: zod.number(),
			rewardStreak: zod.number(),
			totalDailyRewards: zod.number(),
			totalRewards: zod.number(),
			prefix: zod.string().nullish(),
			rank: zod.string().nullish(),
			packageRank: zod.string().nullish(),
			newPackageRank: zod.string().nullish(),
			rankPlusColor: zod.string().nullish(),
			monthlyPackageRank: zod.string().nullish(),
			mostRecentMonthlyPackageRank: zod.string().nullish(),
			monthlyRankColor: zod.string().nullish(),
			socialMedia: zod
				.object({
					discord: zod.string().nullish(),
					hypixel: zod.string().nullish(),
					youtube: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish(),
});

/**
 * @summary Link Account
 */
export const zodLinkOwnAccountParams = zod.object({
	player: zod.string(),
});

/**
 * @summary Unlink Account
 */
export const zodUnlinkOwnAccountParams = zod.object({
	player: zod.string(),
});

/**
 * Returns a 72x72 face png image of the Minecraft account associated with the provided player name or UUID. 72x72 response includes the player's "hat" overlay. If not found, returns Steve's face.
 * @summary Get Minecraft Account Face Image
 */
export const zodGetAccountFace1Params = zod.object({
	player: zod.string(),
});

/**
 * Returns a 72x72 face png image of the Minecraft account associated with the provided player name or UUID. 72x72 response includes the player's "hat" overlay. If not found, returns Steve's face.
 * @summary Get Minecraft Account Face Image
 */
export const zodGetAccountFace2Params = zod.object({
	player: zod.string(),
});

/**
 * @summary Get Minecraft Account from Discord Id
 */
export const zodGetAccountFromDiscordParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodGetAccountFromDiscordResponseSettingsFeaturesEmbedColorMax = 6;

export const zodGetAccountFromDiscordResponseSettingsFeaturesEmojiUrlMax = 256;

export const zodGetAccountFromDiscordResponseSettingsWeightStyleNameMax = 64;

export const zodGetAccountFromDiscordResponseSettingsLeaderboardStyleNameMax = 64;

export const zodGetAccountFromDiscordResponseSettingsNameStyleNameMax = 64;

export const zodGetAccountFromDiscordResponseProfilesItemMembersItemMetaPrefixMax = 16;

export const zodGetAccountFromDiscordResponseProfilesItemMembersItemMetaSuffixMax = 16;

export const zodGetAccountFromDiscordResponseBadgesItemImageTitleMax = 64;

export const zodGetAccountFromDiscordResponseBadgesItemImageDescriptionMax = 512;

export const zodGetAccountFromDiscordResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	formattedName: zod.string(),
	primaryAccount: zod.coerce.boolean<boolean>(),
	discordId: zod.string().nullish(),
	discordUsername: zod.string().nullish(),
	discordAvatar: zod.string().nullish(),
	settings: zod.object({
		prefix: zod.string().nullish().describe('Custom name prefix'),
		suffix: zod.string().nullish().describe('Custom name suffix'),
		features: zod
			.object({
				weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
				weightStyleOverride: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe("Ability to override other's weight styles."),
				embedColor: zod
					.string()
					.max(zodGetAccountFromDiscordResponseSettingsFeaturesEmbedColorMax)
					.nullish()
					.describe('Embed color for the bot.'),
				moreInfoDefault: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Show \"More Info\" on weight command by default.'),
				hideShopPromotions: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('If shop promotions should be hidden.'),
				emojiUrl: zod
					.string()
					.max(zodGetAccountFromDiscordResponseSettingsFeaturesEmojiUrlMax)
					.nullish()
					.describe('Custom name emoji URL.'),
			})
			.nullish()
			.describe('Configurated features for the user'),
		weightStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountFromDiscordResponseSettingsWeightStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected weight style for the user'),
		leaderboardStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountFromDiscordResponseSettingsLeaderboardStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected leaderboard style for the user'),
		nameStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAccountFromDiscordResponseSettingsNameStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected name style for the user'),
		fortune: zod
			.object({
				accounts: zod
					.record(
						zod.string(),
						zod.record(
							zod.string(),
							zod.object({
								strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
								communityCenter: zod.number().describe('Community center farming fortune level'),
								rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
								attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
								chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
							})
						)
					)
					.describe('Member fortune settings for each minecraft account, then each profile.'),
			})
			.nullish()
			.describe('Fortune settings for the user'),
	}),
	skin: zod.object({
		texture: zod.string().nullish().describe('Minecraft skin texture ID'),
		face: zod.string().nullish().describe('Base64 data image of the 8x8 face'),
		hat: zod.string().nullish().describe('Base64 data image of the 8x8 hat (overlay on the face)'),
	}),
	profiles: zod.array(
		zod.object({
			profileId: zod.string(),
			profileName: zod.string(),
			gameMode: zod.string(),
			selected: zod.coerce.boolean<boolean>(),
			bankBalance: zod.number(),
			deleted: zod.coerce.boolean<boolean>(),
			members: zod.array(
				zod.object({
					uuid: zod.string(),
					username: zod.string(),
					profileName: zod.string().nullish(),
					active: zod.coerce.boolean<boolean>(),
					farmingWeight: zod.number(),
					meta: zod
						.object({
							prefix: zod
								.string()
								.max(zodGetAccountFromDiscordResponseProfilesItemMembersItemMetaPrefixMax)
								.nullish(),
							suffix: zod
								.string()
								.max(zodGetAccountFromDiscordResponseProfilesItemMembersItemMetaSuffixMax)
								.nullish(),
							leaderboard: zod
								.object({
									styleId: zod.number().nullish(),
									backgroundColor: zod.string().nullish(),
									borderColor: zod.string().nullish(),
									textColor: zod.string().nullish(),
									rankColor: zod.string().nullish(),
									backgroundImage: zod.string().nullish(),
									overlayImage: zod.string().nullish(),
								})
								.nullish(),
						})
						.nullish(),
				})
			),
		})
	),
	badges: zod.array(
		zod.object({
			id: zod.number(),
			image: zod.object({
				title: zod
					.string()
					.max(zodGetAccountFromDiscordResponseBadgesItemImageTitleMax)
					.nullish()
					.describe('Image title'),
				description: zod
					.string()
					.max(zodGetAccountFromDiscordResponseBadgesItemImageDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			}),
			name: zod.string(),
			description: zod.string(),
			requirements: zod.string(),
			timestamp: zod.string(),
			visible: zod.coerce.boolean<boolean>(),
			order: zod.number(),
		})
	),
	playerData: zod
		.object({
			uuid: zod.string(),
			displayname: zod.string().nullish(),
			firstLogin: zod.number(),
			lastLogin: zod.number(),
			lastLogout: zod.number(),
			karma: zod.number(),
			networkExp: zod.number(),
			guildMember: zod
				.object({
					guild: zod
						.object({
							id: zod.string(),
							name: zod.string(),
							createdAt: zod.number(),
							tag: zod.string().nullish(),
							tagColor: zod.string().nullish(),
							memberCount: zod.number(),
							lastUpdated: zod.number(),
							stats: zod
								.object({
									recordedAt: zod.iso.datetime({}),
									memberCount: zod.number(),
									hypixelLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skyblockExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skillLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									slayerExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									catacombsExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									farmingWeight: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									networth: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
								})
								.nullish(),
							amount: zod
								.number()
								.describe('Populated when sorting guilds by a specific collection or skill'),
						})
						.nullish(),
					rank: zod.string().nullish(),
					joinedAt: zod.number(),
					questParticipation: zod.number(),
					active: zod.coerce.boolean<boolean>(),
					expHistory: zod.record(zod.string(), zod.number()),
				})
				.nullish(),
			rewardHighScore: zod.number(),
			rewardScore: zod.number(),
			rewardStreak: zod.number(),
			totalDailyRewards: zod.number(),
			totalRewards: zod.number(),
			prefix: zod.string().nullish(),
			rank: zod.string().nullish(),
			packageRank: zod.string().nullish(),
			newPackageRank: zod.string().nullish(),
			rankPlusColor: zod.string().nullish(),
			monthlyPackageRank: zod.string().nullish(),
			mostRecentMonthlyPackageRank: zod.string().nullish(),
			monthlyRankColor: zod.string().nullish(),
			socialMedia: zod
				.object({
					discord: zod.string().nullish(),
					hypixel: zod.string().nullish(),
					youtube: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish(),
});

/**
 * @summary Get Account Settings
 */
export const zodGetAccountSettingsParams = zod.object({
	discordId: zod.number(),
});

export const zodGetAccountSettingsResponseFeaturesEmbedColorMax = 6;

export const zodGetAccountSettingsResponseFeaturesEmojiUrlMax = 256;

export const zodGetAccountSettingsResponseWeightStyleNameMax = 64;

export const zodGetAccountSettingsResponseLeaderboardStyleNameMax = 64;

export const zodGetAccountSettingsResponseNameStyleNameMax = 64;

export const zodGetAccountSettingsResponse = zod.object({
	prefix: zod.string().nullish().describe('Custom name prefix'),
	suffix: zod.string().nullish().describe('Custom name suffix'),
	features: zod
		.object({
			weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColor: zod
				.string()
				.max(zodGetAccountSettingsResponseFeaturesEmbedColorMax)
				.nullish()
				.describe('Embed color for the bot.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			hideShopPromotions: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('If shop promotions should be hidden.'),
			emojiUrl: zod
				.string()
				.max(zodGetAccountSettingsResponseFeaturesEmojiUrlMax)
				.nullish()
				.describe('Custom name emoji URL.'),
		})
		.nullish()
		.describe('Configurated features for the user'),
	weightStyle: zod
		.object({
			id: zod.number(),
			name: zod.string().max(zodGetAccountSettingsResponseWeightStyleNameMax).nullish(),
		})
		.nullish()
		.describe('Selected weight style for the user'),
	leaderboardStyle: zod
		.object({
			id: zod.number(),
			name: zod.string().max(zodGetAccountSettingsResponseLeaderboardStyleNameMax).nullish(),
		})
		.nullish()
		.describe('Selected leaderboard style for the user'),
	nameStyle: zod
		.object({
			id: zod.number(),
			name: zod.string().max(zodGetAccountSettingsResponseNameStyleNameMax).nullish(),
		})
		.nullish()
		.describe('Selected name style for the user'),
	fortune: zod
		.object({
			accounts: zod
				.record(
					zod.string(),
					zod.record(
						zod.string(),
						zod.object({
							strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
							communityCenter: zod.number().describe('Community center farming fortune level'),
							rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
							attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
							chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
						})
					)
				)
				.describe('Member fortune settings for each minecraft account, then each profile.'),
		})
		.nullish()
		.describe('Fortune settings for the user'),
});

/**
 * @summary Get Logged-In Account
 */
export const zodGetAuthAccountResponseSettingsFeaturesEmbedColorMax = 6;

export const zodGetAuthAccountResponseSettingsFeaturesEmojiUrlMax = 256;

export const zodGetAuthAccountResponseSettingsWeightStyleNameMax = 64;

export const zodGetAuthAccountResponseSettingsLeaderboardStyleNameMax = 64;

export const zodGetAuthAccountResponseSettingsNameStyleNameMax = 64;

export const zodGetAuthAccountResponseEntitlementsItemProductWeightStylesItemNameMax = 64;

export const zodGetAuthAccountResponseEntitlementsItemProductThumbnailTitleMax = 64;

export const zodGetAuthAccountResponseEntitlementsItemProductThumbnailDescriptionMax = 512;

export const zodGetAuthAccountResponseEntitlementsItemProductImagesItemTitleMax = 64;

export const zodGetAuthAccountResponseEntitlementsItemProductImagesItemDescriptionMax = 512;

export const zodGetAuthAccountResponseMinecraftAccountsItemBadgesItemImageTitleMax = 64;

export const zodGetAuthAccountResponseMinecraftAccountsItemBadgesItemImageDescriptionMax = 512;

export const zodGetAuthAccountResponse = zod.object({
	id: zod.string().describe('Discord user ID'),
	displayName: zod.string().describe('Discord display name'),
	username: zod.string().describe('Discord username (unique)'),
	discriminator: zod.string().nullish(),
	locale: zod.string().nullish().describe('Discord user locale'),
	avatar: zod.string().nullish().describe('Discord avatar URL hash'),
	banner: zod.string().nullish().describe('Discord banner URL hash'),
	settings: zod.object({
		prefix: zod.string().nullish().describe('Custom name prefix'),
		suffix: zod.string().nullish().describe('Custom name suffix'),
		features: zod
			.object({
				weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
				weightStyleOverride: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe("Ability to override other's weight styles."),
				embedColor: zod
					.string()
					.max(zodGetAuthAccountResponseSettingsFeaturesEmbedColorMax)
					.nullish()
					.describe('Embed color for the bot.'),
				moreInfoDefault: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Show \"More Info\" on weight command by default.'),
				hideShopPromotions: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('If shop promotions should be hidden.'),
				emojiUrl: zod
					.string()
					.max(zodGetAuthAccountResponseSettingsFeaturesEmojiUrlMax)
					.nullish()
					.describe('Custom name emoji URL.'),
			})
			.nullish()
			.describe('Configurated features for the user'),
		weightStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAuthAccountResponseSettingsWeightStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected weight style for the user'),
		leaderboardStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAuthAccountResponseSettingsLeaderboardStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected leaderboard style for the user'),
		nameStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodGetAuthAccountResponseSettingsNameStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected name style for the user'),
		fortune: zod
			.object({
				accounts: zod
					.record(
						zod.string(),
						zod.record(
							zod.string(),
							zod.object({
								strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
								communityCenter: zod.number().describe('Community center farming fortune level'),
								rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
								attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
								chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
							})
						)
					)
					.describe('Member fortune settings for each minecraft account, then each profile.'),
			})
			.nullish()
			.describe('Fortune settings for the user'),
	}),
	entitlements: zod
		.array(
			zod.object({
				id: zod.string().describe('Entitlement ID'),
				type: zod
					.union([
						zod.literal(1),
						zod.literal(2),
						zod.literal(3),
						zod.literal(4),
						zod.literal(5),
						zod.literal(6),
						zod.literal(7),
						zod.literal(8),
					])
					.describe('Type of entitlement'),
				target: zod
					.union([zod.literal(0), zod.literal(1), zod.literal(2)])
					.describe('Target of entitlement.\n0 = None\n1 = User\n2 = Guild'),
				productId: zod.string().describe('SKU ID of the product'),
				product: zod
					.object({
						id: zod.string().describe('Product ID'),
						name: zod.string().describe('Product name'),
						slug: zod.string().describe('Slug of the product'),
						price: zod.number().describe('Product price'),
						description: zod.string().nullish().describe('Product description'),
						available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
						type: zod
							.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
							.describe('Type of product'),
						features: zod
							.object({
								badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
								weightStyles: zod
									.array(zod.string())
									.nullish()
									.describe('Name of weight style to unlock.'),
								weightStyleOverride: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe("Ability to override other's weight styles."),
								embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
								hideShopPromotions: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Ability to hide shop promotions.'),
								moreInfoDefault: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Show \"More Info\" on weight command by default.'),
								customEmoji: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Ability to have custom name emoji for the user.'),
								maxMonthlyEvents: zod
									.number()
									.nullish()
									.describe('Maximum number of events that can be created in a month. (For guilds)'),
								maxJacobLeaderboards: zod
									.number()
									.nullish()
									.describe(
										'Maximum number of jacob leaderboard that can be active at once. (For guilds)'
									),
								flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
							})
							.describe('Features of the product'),
						weightStyles: zod
							.array(
								zod.object({
									id: zod.number(),
									name: zod
										.string()
										.max(zodGetAuthAccountResponseEntitlementsItemProductWeightStylesItemNameMax)
										.nullish(),
								})
							)
							.describe('Unlocked weight styles'),
						thumbnail: zod
							.object({
								title: zod
									.string()
									.max(zodGetAuthAccountResponseEntitlementsItemProductThumbnailTitleMax)
									.nullish()
									.describe('Image title'),
								description: zod
									.string()
									.max(zodGetAuthAccountResponseEntitlementsItemProductThumbnailDescriptionMax)
									.nullish()
									.describe('Image description'),
								order: zod.number().nullish().describe('Image ordering number'),
								width: zod.number().describe('The original width of the image.'),
								height: zod.number().describe('The original height of the image.'),
								sources: zod
									.record(
										zod.string(),
										zod.object({
											url: zod
												.string()
												.describe('The fully-qualified public URL for this image variant.'),
											width: zod.number().describe('The width of this image variant in pixels.'),
										})
									)
									.describe(
										'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
									),
								url: zod.string().describe('Lowest quality image URL'),
							})
							.nullish()
							.describe('Product thumbnail'),
						images: zod
							.array(
								zod.object({
									title: zod
										.string()
										.max(zodGetAuthAccountResponseEntitlementsItemProductImagesItemTitleMax)
										.nullish()
										.describe('Image title'),
									description: zod
										.string()
										.max(zodGetAuthAccountResponseEntitlementsItemProductImagesItemDescriptionMax)
										.nullish()
										.describe('Image description'),
									order: zod.number().nullish().describe('Image ordering number'),
									width: zod.number().describe('The original width of the image.'),
									height: zod.number().describe('The original height of the image.'),
									sources: zod
										.record(
											zod.string(),
											zod.object({
												url: zod
													.string()
													.describe('The fully-qualified public URL for this image variant.'),
												width: zod
													.number()
													.describe('The width of this image variant in pixels.'),
											})
										)
										.describe(
											'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
										),
									url: zod.string().describe('Lowest quality image URL'),
								})
							)
							.describe('Product Images'),
						flags: zod.number().describe('Discord flags'),
						isSubscription: zod.coerce.boolean<boolean>(),
						isGuildSubscription: zod.coerce.boolean<boolean>(),
						isUserSubscription: zod.coerce.boolean<boolean>(),
					})
					.describe('Product details'),
				deleted: zod.coerce.boolean<boolean>(),
				consumed: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Consumed status of the entitlement if applicable'),
				startDate: zod.iso.datetime({}).nullish().describe('Start date of the entitlement'),
				endDate: zod.iso.datetime({}).nullish().describe('End date of the entitlement'),
			})
		)
		.describe('Purchased entitlements from the Discord store'),
	minecraftAccounts: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				primaryAccount: zod.coerce.boolean<boolean>(),
				badges: zod.array(
					zod.object({
						id: zod.number(),
						image: zod.object({
							title: zod
								.string()
								.max(zodGetAuthAccountResponseMinecraftAccountsItemBadgesItemImageTitleMax)
								.nullish()
								.describe('Image title'),
							description: zod
								.string()
								.max(zodGetAuthAccountResponseMinecraftAccountsItemBadgesItemImageDescriptionMax)
								.nullish()
								.describe('Image description'),
							order: zod.number().nullish().describe('Image ordering number'),
							width: zod.number().describe('The original width of the image.'),
							height: zod.number().describe('The original height of the image.'),
							sources: zod
								.record(
									zod.string(),
									zod.object({
										url: zod
											.string()
											.describe('The fully-qualified public URL for this image variant.'),
										width: zod.number().describe('The width of this image variant in pixels.'),
									})
								)
								.describe(
									'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
								),
							url: zod.string().describe('Lowest quality image URL'),
						}),
						name: zod.string(),
						description: zod.string(),
						requirements: zod.string(),
						timestamp: zod.string(),
						visible: zod.coerce.boolean<boolean>(),
						order: zod.number(),
					})
				),
				skin: zod.object({
					texture: zod.string().nullish().describe('Minecraft skin texture ID'),
					face: zod.string().nullish().describe('Base64 data image of the 8x8 face'),
					hat: zod.string().nullish().describe('Base64 data image of the 8x8 hat (overlay on the face)'),
				}),
			})
		)
		.describe('Linked Minecraft accounts'),
	dismissedAnnouncements: zod.array(zod.string()).describe('Dismissed announcements by the user'),
});

/**
 * @summary Search for Minecraft Account
 */
export const zodSearchAccountsQueryParams = zod.object({
	q: zod.string().describe('Search query string'),
	start: zod.string().nullish().describe('Start of results for pagination'),
});

export const zodSearchAccountsResponseItem = zod.string();
export const zodSearchAccountsResponse = zod.array(zodSearchAccountsResponseItem);

/**
 * Authenticated endpoint that returns a list of accounts that have a specific discord username linked.
 * @summary Search for Minecraft Account From Discord
 */
export const zodSearchAccountsWithDiscordResponseItem = zod.object({
	ign: zod.string(),
	uuid: zod.string(),
	discordId: zod.string().nullish(),
});
export const zodSearchAccountsWithDiscordResponse = zod.array(zodSearchAccountsWithDiscordResponseItem);

/**
 * @summary Set Primary Account
 */
export const zodSetPrimaryAccountParams = zod.object({
	player: zod.string(),
});

/**
 * @summary Update Account Settings
 */
export const zodUpdateBadgesParams = zod.object({
	playerUuid: zod.string(),
});

export const zodUpdateBadgesBodyItem = zod.object({
	badgeId: zod.number(),
	visible: zod.coerce.boolean<boolean>().nullish(),
	order: zod.number().nullish(),
});
export const zodUpdateBadgesBody = zod.array(zodUpdateBadgesBodyItem);

/**
 * @summary Update Fortune Settings for Account
 */
export const zodUpdateFortuneSettingsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodUpdateFortuneSettingsBody = zod.object({
	strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
	communityCenter: zod.number().describe('Community center farming fortune level'),
	rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
	attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
	chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
});

/**
 * @summary Update Account Settings
 */
export const zodUpdateAccountBodyFeaturesEmbedColorMax = 6;

export const zodUpdateAccountBodyFeaturesEmojiUrlMax = 256;

export const zodUpdateAccountBody = zod.object({
	prefix: zod.string().nullish().describe('Custom name prefix'),
	suffix: zod.string().nullish().describe('Custom name suffix'),
	features: zod
		.object({
			weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColor: zod
				.string()
				.max(zodUpdateAccountBodyFeaturesEmbedColorMax)
				.nullish()
				.describe('Embed color for the bot.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			hideShopPromotions: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('If shop promotions should be hidden.'),
			emojiUrl: zod
				.string()
				.max(zodUpdateAccountBodyFeaturesEmojiUrlMax)
				.nullish()
				.describe('Custom name emoji URL.'),
		})
		.nullish()
		.describe('Configurated features for the user'),
	weightStyleId: zod.number().nullish().describe('Selected weight style for the user'),
	leaderboardStyleId: zod.number().nullish().describe('Selected leaderboard style for the user'),
	nameStyleId: zod.number().nullish().describe('Selected name style for the user'),
});

/**
 * @summary Add a role to a user
 */
export const zodAddRoleToUserParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	role: zod.string(),
});

/**
 * @summary Remove a role from a user
 */
export const zodRemoveRoleFromUserParams = zod.object({
	discordId: zod.number(),
	role: zod.string(),
});

/**
 * @summary Get list of admins
 */
export const zodGetAdminsResponseItem = zod.object({
	id: zod.string(),
	displayName: zod.string(),
	username: zod.string(),
	roles: zod.array(zod.string()),
	discriminator: zod.string().nullish(),
	avatar: zod.string().nullish(),
});
export const zodGetAdminsResponse = zod.array(zodGetAdminsResponseItem);

/**
 * @summary Get list of roles
 */
export const zodGetRolesResponseItem = zod.string();
export const zodGetRolesResponse = zod.array(zodGetRolesResponseItem);

/**
 * This enables a player's data from Hypixel to be refreshed on the next request.
 * @summary Reset a player's cooldowns
 */
export const zodClearPlayerCooldownsParams = zod.object({
	player: zod.string(),
});

/**
 * @summary Delete Event
 */
export const zodDeleteEventApprovalParams = zod.object({
	eventId: zod.number(),
});

/**
 * @summary Get events pending approval
 */
export const zodGetPendingEventsResponseBannerTitleMax = 64;

export const zodGetPendingEventsResponseBannerDescriptionMax = 512;

export const zodGetPendingEventsResponseItem = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetPendingEventsResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPendingEventsResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});
export const zodGetPendingEventsResponse = zod.array(zodGetPendingEventsResponseItem);

/**
 * @summary Set event approval
 */
export const zodSetEventApprovalParams = zod.object({
	eventId: zod.number(),
});

export const zodSetEventApprovalQueryApproveDefault = false;

export const zodSetEventApprovalQueryParams = zod.object({
	approve: zod.coerce.boolean<boolean>().nullish(),
});

/**
 * @summary Link an Account
 */
export const zodLinkUserAccountBody = zod.object({
	discordId: zod.string(),
	player: zod.string(),
});

/**
 * This fetches the latest data from Discord for the specified guild
 * @summary Refresh a guild
 */
export const zodRefreshDiscordGuildParams = zod.object({
	guildId: zod.number(),
});

/**
 * This fetches the latest data from Hypixel for the specified guild
 * @summary Refresh a Hypixel Guild
 */
export const zodRefreshHypixelGuildParams = zod.object({
	guildId: zod.string(),
});

/**
 * @summary Unlink an Account
 */
export const zodUnlinkUserAccountBody = zod.object({
	discordId: zod.string(),
	player: zod.string(),
});

/**
 * Creates a new announcement that will be displayed to users
 * @summary Create an announcement
 */
export const zodCreateAnnouncementBody = zod.object({
	title: zod.string().describe('Announcement title'),
	content: zod.string().describe('Announcement content'),
	type: zod
		.enum(['other', 'update', 'article', 'news', 'event', 'maintenance', 'shop'])
		.describe('Type of the announcement'),
	targetLabel: zod
		.string()
		.nullish()
		.describe('Label for the target of the announcement (e.g. \"Read more\", \"View article\")'),
	targetUrl: zod.string().nullish().describe('Url to read more about the announcement'),
	targetStartsAt: zod.iso
		.datetime({})
		.nullish()
		.describe('Optional time stamp for when the topic of the announcement starts'),
	targetEndsAt: zod.iso
		.datetime({})
		.nullish()
		.describe('Optional time stamp for when the topic of the announcement ends'),
	createdAt: zod.iso.datetime({}).describe('Announcement creation date'),
	expiresAt: zod.iso.datetime({}).describe('Announcement expiration date (will no longer be shown after this date)'),
});

/**
 * Mark an announcement as dismissed for the current user
 * @summary Dismiss an announcement
 */
export const zodDismissAnnouncementParams = zod.object({
	announcementId: zod.string(),
});

/**
 * Gets all announcements that should be shown to users
 * @summary Get announcements
 */
export const zodGetAnnouncementResponseItem = zod.object({
	title: zod.string().describe('Announcement title'),
	content: zod.string().describe('Announcement content'),
	type: zod
		.enum(['other', 'update', 'article', 'news', 'event', 'maintenance', 'shop'])
		.describe('Type of the announcement'),
	targetLabel: zod
		.string()
		.nullish()
		.describe('Label for the target of the announcement (e.g. \"Read more\", \"View article\")'),
	targetUrl: zod.string().nullish().describe('Url to read more about the announcement'),
	targetStartsAt: zod.iso
		.datetime({})
		.nullish()
		.describe('Optional time stamp for when the topic of the announcement starts'),
	targetEndsAt: zod.iso
		.datetime({})
		.nullish()
		.describe('Optional time stamp for when the topic of the announcement ends'),
	createdAt: zod.iso.datetime({}).describe('Announcement creation date'),
	expiresAt: zod.iso.datetime({}).describe('Announcement expiration date (will no longer be shown after this date)'),
	id: zod.string().describe('Announcement id'),
});
export const zodGetAnnouncementResponse = zod.array(zodGetAnnouncementResponseItem);

/**
 * Returns distinct actions and target types for filter dropdowns.
 * @summary Get available audit log filters
 */
export const zodGetAuditLogFiltersResponse = zod.object({
	actions: zod.array(zod.string()),
	targetTypes: zod.array(zod.string()),
});

/**
 * Retrieve paginated and filterable audit logs for administrative actions.
 * @summary Get admin audit logs
 */
export const zodGetAuditLogsQueryParams = zod.object({
	offset: zod.number(),
	limit: zod.number(),
	action: zod.string().nullish(),
	targetType: zod.string().nullish(),
	adminUserId: zod.string().nullish(),
	fromDate: zod.iso.datetime({}).nullish(),
	toDate: zod.iso.datetime({}).nullish(),
});

export const zodGetAuditLogsResponse = zod.object({
	logs: zod.array(
		zod.object({
			id: zod.number(),
			adminUserId: zod.string(),
			adminUserName: zod.string(),
			action: zod.string(),
			targetType: zod.string(),
			targetId: zod.string().nullish(),
			details: zod.string().nullish(),
			createdAt: zod.iso.datetime({}),
			data: zod.record(zod.string(), zod.unknown()).nullish(),
		})
	),
	totalCount: zod.number(),
});

/**
 * Accepts a login confirmation that users will need to accept to proceed.
 * @summary Accept a confirmation
 */
export const zodAcceptConfirmationParams = zod.object({
	id: zod.number(),
});

export const zodAcceptConfirmationResponse = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});

/**
 * Gets a confirmation that users will need to accept.
 * @summary Get a confirmation
 */
export const zodGetConfirmationParams = zod.object({
	id: zod.number(),
});

export const zodGetConfirmationResponse = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});

/**
 * Get the account of the currently logged in user
 * @summary Get logged in account
 */
export const zodGetSessionResponse = zod.object({
	id: zod.string().describe('Discord user ID'),
	username: zod.string().describe('Discord username'),
	avatar: zod.string().describe('Discord avatar hash'),
	ign: zod.string().describe('Primary Minecraft IGN'),
	fIgn: zod.string().nullish().describe('Formatted Primary Minecraft IGN'),
	uuid: zod.string().describe('Primary Minecraft UUID'),
	roles: zod.array(zod.string()).describe('List of user roles'),
	flags: zod.array(zod.string()).describe('List of account flags'),
	pending_confirmation: zod
		.object({
			id: zod.number(),
			title: zod.string().nullish(),
			content: zod.string().nullish(),
			isActive: zod.coerce.boolean<boolean>(),
			createdAt: zod.iso.datetime({}),
		})
		.nullish()
		.describe('The pending confirmation for the user, if any'),
});

/**
 * Log in with discord credentials
 * @summary Log in
 */
export const zodLoginBody = zod.object({
	code: zod.string().describe('Discord login code from OAuth2'),
	redirect_uri: zod.string().describe('Redirect URI from OAuth2'),
});

export const zodLoginResponse = zod.object({
	access_token: zod.string().describe('Access token for the user'),
	expires_in: zod.string().nullish().describe('Expiry date of the access token in Unix timestamp seconds'),
	refresh_token: zod.string().describe('Refresh token for the user'),
	pending_confirmation: zod
		.object({
			id: zod.number(),
			title: zod.string().nullish(),
			content: zod.string().nullish(),
			isActive: zod.coerce.boolean<boolean>(),
			createdAt: zod.iso.datetime({}),
		})
		.nullish()
		.describe('The pending confirmation for the user, if any'),
	first_login: zod.coerce.boolean<boolean>().describe("If this is the user's first login"),
});

/**
 * Refresh the auth token using the refresh token
 * @summary Refresh Auth Token
 */
export const zodRefreshAuthBody = zod.object({
	user_id: zod.string().describe('User ID'),
	refresh_token: zod.string().describe('Refresh token for the user'),
});

export const zodRefreshAuthResponse = zod.object({
	access_token: zod.string().describe('Access token for the user'),
	expires_in: zod.string().nullish().describe('Expiry date of the access token in Unix timestamp seconds'),
	refresh_token: zod.string().describe('Refresh token for the user'),
	pending_confirmation: zod
		.object({
			id: zod.number(),
			title: zod.string().nullish(),
			content: zod.string().nullish(),
			isActive: zod.coerce.boolean<boolean>(),
			createdAt: zod.iso.datetime({}),
		})
		.nullish()
		.describe('The pending confirmation for the user, if any'),
	first_login: zod.coerce.boolean<boolean>().describe("If this is the user's first login"),
});

/**
 * @summary Add a badge to a user
 */
export const zodAddBadgeToUserBadgeParams = zod.object({
	player: zod.string().describe('Player uuid or ign'),
	badgeId: zod.number().describe('ID of the badge'),
});

/**
 * @summary Remove a badge from a user
 */
export const zodDeleteBadgeFromUserBadgeParams = zod.object({
	player: zod.string(),
	badgeId: zod.number(),
});

/**
 * @summary Create a badge
 */
export const zodCreateBadgeBodyNameMin = 0;
export const zodCreateBadgeBodyNameMax = 50;

export const zodCreateBadgeBodyDescriptionMin = 0;
export const zodCreateBadgeBodyDescriptionMax = 1024;

export const zodCreateBadgeBodyRequirementsMin = 0;
export const zodCreateBadgeBodyRequirementsMax = 512;

export const zodCreateBadgeBody = zod.object({
	name: zod.string().min(zodCreateBadgeBodyNameMin).max(zodCreateBadgeBodyNameMax),
	description: zod.string().min(zodCreateBadgeBodyDescriptionMin).max(zodCreateBadgeBodyDescriptionMax),
	requirements: zod.string().min(zodCreateBadgeBodyRequirementsMin).max(zodCreateBadgeBodyRequirementsMax),
	tieToAccount: zod.coerce.boolean<boolean>(),
	image: zod.instanceof(File).nullish(),
});

/**
 * @summary Get all badges
 */
export const zodGetBadgesResponseImageTitleMax = 64;

export const zodGetBadgesResponseImageDescriptionMax = 512;

export const zodGetBadgesResponseItem = zod.object({
	id: zod.number(),
	image: zod
		.object({
			title: zod.string().max(zodGetBadgesResponseImageTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetBadgesResponseImageDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	name: zod.string(),
	description: zod.string(),
	requirements: zod.string(),
});
export const zodGetBadgesResponse = zod.array(zodGetBadgesResponseItem);

/**
 * @summary Delete a badge
 */
export const zodDeleteBadgeParams = zod.object({
	badgeId: zod.number().describe('ID of the badge'),
});

/**
 * @summary Update a badge
 */
export const zodUpdateBadgeParams = zod.object({
	badgeId: zod.number().describe('ID of the badge'),
});

export const zodUpdateBadgeBodyNameMin = 0;
export const zodUpdateBadgeBodyNameMax = 50;

export const zodUpdateBadgeBodyDescriptionMin = 0;
export const zodUpdateBadgeBodyDescriptionMax = 1024;

export const zodUpdateBadgeBodyRequirementsMin = 0;
export const zodUpdateBadgeBodyRequirementsMax = 512;

export const zodUpdateBadgeBody = zod.object({
	name: zod.string().min(zodUpdateBadgeBodyNameMin).max(zodUpdateBadgeBodyNameMax).nullish(),
	description: zod.string().min(zodUpdateBadgeBodyDescriptionMin).max(zodUpdateBadgeBodyDescriptionMax).nullish(),
	requirements: zod.string().min(zodUpdateBadgeBodyRequirementsMin).max(zodUpdateBadgeBodyRequirementsMax).nullish(),
	image: zod.instanceof(File).nullish(),
});

/**
 * @summary Link Account
 */
export const zodLinkAccountBotParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	player: zod.string().describe('Player uuid or ign'),
});

/**
 * @summary Unlink Account
 */
export const zodUnlinkAccountBotParams = zod.object({
	discordId: zod.number(),
	player: zod.string(),
});

/**
 * @summary Make Primary Account
 */
export const zodMakePrimaryAccountParams = zod.object({
	discordId: zod.number(),
	player: zod.string(),
});

/**
 * @summary Refresh User Purchases
 */
export const zodRefreshUserPurchasesParams = zod.object({
	discordId: zod.number(),
});

/**
 * @summary Grant Badge
 */
export const zodGrantBadgeParams = zod.object({
	player: zod.string().describe('Player uuid or ign'),
	badgeId: zod.number(),
});

/**
 * @summary Remove Badge
 */
export const zodRemoveBadgeParams = zod.object({
	player: zod.string().describe('Player uuid or ign'),
	badgeId: zod.number(),
});

/**
 * @summary Disable contest pings for a guild
 */
export const zodDisableContestPingsPingsParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodDisableContestPingsPingsQueryParams = zod.object({
	reason: zod.string().nullish(),
});

/**
 * @summary Get list of guilds with contest pings enabled
 */
export const zodGetContestPingsResponseItem = zod.object({
	enabled: zod.coerce.boolean<boolean>(),
	guildId: zod.string().nullish(),
	channelId: zod.string().nullish(),
	alwaysPingRole: zod.string().nullish(),
	cropPingRoles: zod
		.object({
			cactus: zod.string().nullish(),
			carrot: zod.string().nullish(),
			potato: zod.string().nullish(),
			wheat: zod.string().nullish(),
			melon: zod.string().nullish(),
			pumpkin: zod.string().nullish(),
			mushroom: zod.string().nullish(),
			cocoaBeans: zod.string().nullish(),
			sugarCane: zod.string().nullish(),
			netherWart: zod.string().nullish(),
			sunflower: zod.string().nullish(),
			moonflower: zod.string().nullish(),
			wildRose: zod.string().nullish(),
		})
		.nullish(),
	delaySeconds: zod.number(),
	disabledReason: zod.string().nullish(),
});
export const zodGetContestPingsResponse = zod.array(zodGetContestPingsResponseItem);

/**
 * @summary Get guild
 */
export const zodGetBotGuildParams = zod.object({
	discordId: zod.number(),
});

export const zodGetBotGuildResponseFeaturesJacobLeaderboardLeaderboardsItemTitleMax = 64;

export const zodGetBotGuildResponseIconTitleMax = 64;

export const zodGetBotGuildResponseIconDescriptionMax = 512;

export const zodGetBotGuildResponseBannerTitleMax = 64;

export const zodGetBotGuildResponseBannerDescriptionMax = 512;

export const zodGetBotGuildResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	public: zod.coerce.boolean<boolean>(),
	features: zod.object({
		locked: zod.coerce.boolean<boolean>(),
		jacobLeaderboardEnabled: zod.coerce.boolean<boolean>(),
		jacobLeaderboard: zod
			.object({
				maxLeaderboards: zod.number(),
				blockedRoles: zod.array(
					zod.object({
						id: zod.string(),
						name: zod.string(),
						position: zod.number(),
						permissions: zod.number(),
					})
				),
				blockedUsers: zod.array(zod.number()),
				requiredRoles: zod.array(
					zod.object({
						id: zod.string(),
						name: zod.string(),
						position: zod.number(),
						permissions: zod.number(),
					})
				),
				excludedParticipations: zod.array(zod.string()),
				excludedTimespans: zod.array(
					zod.object({
						start: zod.number(),
						end: zod.number(),
						reason: zod.string().nullish(),
					})
				),
				leaderboards: zod.array(
					zod.object({
						id: zod.string(),
						channelId: zod.string().nullish(),
						startCutoff: zod.number(),
						endCutoff: zod.number(),
						title: zod
							.string()
							.max(zodGetBotGuildResponseFeaturesJacobLeaderboardLeaderboardsItemTitleMax)
							.nullish(),
						active: zod.coerce.boolean<boolean>(),
						requiredRole: zod.string().nullish(),
						blockedRole: zod.string().nullish(),
						updateChannelId: zod.string().nullish(),
						updateRoleId: zod.string().nullish(),
						pingForSmallImprovements: zod.coerce.boolean<boolean>(),
						crops: zod.object({
							cactus: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							carrot: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							potato: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							wheat: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							melon: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							pumpkin: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							mushroom: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							cocoaBeans: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							sugarCane: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							netherWart: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							sunflower: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							moonflower: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							wildRose: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
						}),
					})
				),
			})
			.nullish(),
		verifiedRoleEnabled: zod.coerce.boolean<boolean>(),
		verifiedRole: zod
			.object({
				enabled: zod.coerce.boolean<boolean>(),
				autoRoles: zod.array(
					zod.object({
						roleId: zod.string().nullish(),
						requiredWeight: zod.number(),
					})
				),
			})
			.nullish(),
		eventsEnabled: zod.coerce.boolean<boolean>(),
		eventSettings: zod
			.object({
				maxMonthlyEvents: zod.number(),
				publicEventsEnabled: zod.coerce.boolean<boolean>(),
				createdEvents: zod.array(
					zod.object({
						id: zod.string(),
						createdAt: zod.iso.datetime({}),
					})
				),
			})
			.nullish(),
		contestPingsEnabled: zod.coerce.boolean<boolean>(),
		contestPings: zod
			.object({
				enabled: zod.coerce.boolean<boolean>(),
				channelId: zod.string().nullish(),
				alwaysPingRole: zod.string().nullish(),
				cropPingRoles: zod
					.object({
						cactus: zod.string().nullish(),
						carrot: zod.string().nullish(),
						potato: zod.string().nullish(),
						wheat: zod.string().nullish(),
						melon: zod.string().nullish(),
						pumpkin: zod.string().nullish(),
						mushroom: zod.string().nullish(),
						cocoaBeans: zod.string().nullish(),
						sugarCane: zod.string().nullish(),
						netherWart: zod.string().nullish(),
						sunflower: zod.string().nullish(),
						moonflower: zod.string().nullish(),
						wildRose: zod.string().nullish(),
					})
					.nullish(),
				delaySeconds: zod.number(),
				disabledReason: zod.string().nullish(),
			})
			.nullish(),
	}),
	icon: zod
		.object({
			title: zod.string().max(zodGetBotGuildResponseIconTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetBotGuildResponseIconDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	banner: zod
		.object({
			title: zod.string().max(zodGetBotGuildResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetBotGuildResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	inviteCode: zod.string().nullish(),
	description: zod.string().nullish(),
	adminRole: zod.string().nullish(),
	botPermissions: zod.string().nullish(),
	botPermissionsNew: zod.string(),
	discordFeatures: zod.array(zod.string()),
	memberCount: zod.number(),
	channels: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			type: zod.number(),
			position: zod.number(),
		})
	),
	roles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
		})
	),
});

/**
 * @summary Get guild jacob
 */
export const zodGetJacobFeatureParams = zod.object({
	discordId: zod.number(),
});

export const zodGetJacobFeatureResponseLeaderboardsItemTitleMax = 64;

export const zodGetJacobFeatureResponse = zod.object({
	maxLeaderboards: zod.number(),
	blockedRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	blockedUsers: zod.array(zod.number()),
	requiredRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	excludedParticipations: zod.array(zod.string()),
	excludedTimespans: zod.array(
		zod.object({
			start: zod.number(),
			end: zod.number(),
			reason: zod.string().nullish(),
		})
	),
	leaderboards: zod.array(
		zod.object({
			id: zod.string(),
			channelId: zod.string().nullish(),
			startCutoff: zod.number(),
			endCutoff: zod.number(),
			title: zod.string().max(zodGetJacobFeatureResponseLeaderboardsItemTitleMax).nullish(),
			active: zod.coerce.boolean<boolean>(),
			requiredRole: zod.string().nullish(),
			blockedRole: zod.string().nullish(),
			updateChannelId: zod.string().nullish(),
			updateRoleId: zod.string().nullish(),
			pingForSmallImprovements: zod.coerce.boolean<boolean>(),
			crops: zod.object({
				cactus: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				carrot: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				potato: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wheat: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				melon: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				pumpkin: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				mushroom: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				cocoaBeans: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sugarCane: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				netherWart: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sunflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				moonflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wildRose: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
			}),
		})
	),
});

/**
 * @summary Update guild jacob feature
 */
export const zodUpdateJacobFeatureParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateJacobFeatureQueryParams = zod.object({
	reason: zod.string().nullish(),
});

export const zodUpdateJacobFeatureBodyLeaderboardsItemTitleMax = 64;

export const zodUpdateJacobFeatureBody = zod.object({
	blockedRoles: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				position: zod.number(),
				permissions: zod.number(),
			})
		)
		.describe("Blocked roles from participating in the guild's Jacob Leaderboards"),
	blockedUsers: zod
		.array(zod.number())
		.describe("Blocked users from participating in the guild's Jacob Leaderboards"),
	requiredRoles: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				position: zod.number(),
				permissions: zod.number(),
			})
		)
		.describe("Required roles to participate in the guild's Jacob Leaderboards"),
	excludedParticipations: zod
		.array(zod.string())
		.describe("Excluded participations from the guild's Jacob Leaderboards"),
	excludedTimespans: zod
		.array(
			zod.object({
				start: zod.number(),
				end: zod.number(),
				reason: zod.string().nullish(),
			})
		)
		.describe("Excluded timespans from the guild's Jacob Leaderboards"),
	leaderboards: zod
		.array(
			zod.object({
				id: zod.string(),
				channelId: zod.string().nullish(),
				startCutoff: zod.number(),
				endCutoff: zod.number(),
				title: zod.string().max(zodUpdateJacobFeatureBodyLeaderboardsItemTitleMax).nullish(),
				active: zod.coerce.boolean<boolean>(),
				requiredRole: zod.string().nullish(),
				blockedRole: zod.string().nullish(),
				updateChannelId: zod.string().nullish(),
				updateRoleId: zod.string().nullish(),
				pingForSmallImprovements: zod.coerce.boolean<boolean>(),
				crops: zod.object({
					cactus: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					carrot: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					potato: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					wheat: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					melon: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					pumpkin: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					mushroom: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					cocoaBeans: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					sugarCane: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					netherWart: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					sunflower: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					moonflower: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					wildRose: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
				}),
			})
		)
		.describe("Leaderboards for the guild's Jacob Leaderboards"),
});

export const zodUpdateJacobFeatureResponseLeaderboardsItemTitleMax = 64;

export const zodUpdateJacobFeatureResponse = zod.object({
	maxLeaderboards: zod.number(),
	blockedRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	blockedUsers: zod.array(zod.number()),
	requiredRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	excludedParticipations: zod.array(zod.string()),
	excludedTimespans: zod.array(
		zod.object({
			start: zod.number(),
			end: zod.number(),
			reason: zod.string().nullish(),
		})
	),
	leaderboards: zod.array(
		zod.object({
			id: zod.string(),
			channelId: zod.string().nullish(),
			startCutoff: zod.number(),
			endCutoff: zod.number(),
			title: zod.string().max(zodUpdateJacobFeatureResponseLeaderboardsItemTitleMax).nullish(),
			active: zod.coerce.boolean<boolean>(),
			requiredRole: zod.string().nullish(),
			blockedRole: zod.string().nullish(),
			updateChannelId: zod.string().nullish(),
			updateRoleId: zod.string().nullish(),
			pingForSmallImprovements: zod.coerce.boolean<boolean>(),
			crops: zod.object({
				cactus: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				carrot: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				potato: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wheat: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				melon: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				pumpkin: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				mushroom: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				cocoaBeans: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sugarCane: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				netherWart: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sunflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				moonflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wildRose: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
			}),
		})
	),
});

/**
 * @summary Request Guild Update
 */
export const zodRefreshGuildParams = zod.object({
	discordId: zod.number(),
});

/**
 * @summary Update Guild
 */
export const zodUpdateGuildParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateGuildBody = zod.object({
	id: zod.string().nullish(),
	name: zod.string(),
	icon: zod.string().nullish(),
	banner: zod.string().nullish(),
	permissions: zod.string().nullish(),
	botPermissions: zod.string().nullish(),
	features: zod.array(zod.string()).nullish(),
	channels: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				type: zod.number(),
				position: zod.number(),
				permissions: zod.string().nullish(),
			})
		)
		.nullish(),
	roles: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				position: zod.number(),
			})
		)
		.nullish(),
});

export const zodUpdateGuildResponse = zod.object({});

/**
 * @summary Update Guild Channel
 */
export const zodUpdateGuildChannelParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateGuildChannelBody = zod.object({
	id: zod.string(),
	name: zod.string(),
	type: zod.number(),
	position: zod.number(),
	permissions: zod.string().nullish(),
});

/**
 * @summary Update Guild Member Roles
 */
export const zodUpdateGuildMemberRolesParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	userId: zod.string(),
});

export const zodUpdateGuildMemberRolesBodyItem = zod.string();
export const zodUpdateGuildMemberRolesBody = zod.array(zodUpdateGuildMemberRolesBodyItem);

/**
 * @summary Update Guild Role
 */
export const zodUpdateGuildRoleParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateGuildRoleBody = zod.object({
	id: zod.string(),
	name: zod.string(),
	position: zod.number(),
});

/**
 * @summary Update user Discord account
 */
export const zodUpdateDiscordAccountBody = zod.object({
	id: zod.number(),
	username: zod.string(),
	displayName: zod.string().nullish(),
	discriminator: zod.string().nullish(),
	avatar: zod.string().nullish(),
	locale: zod.string().nullish(),
	banner: zod.string().nullish(),
});

export const zodUpdateDiscordAccountResponseSettingsFeaturesEmbedColorMax = 6;

export const zodUpdateDiscordAccountResponseSettingsFeaturesEmojiUrlMax = 256;

export const zodUpdateDiscordAccountResponseSettingsWeightStyleNameMax = 64;

export const zodUpdateDiscordAccountResponseSettingsLeaderboardStyleNameMax = 64;

export const zodUpdateDiscordAccountResponseSettingsNameStyleNameMax = 64;

export const zodUpdateDiscordAccountResponseEntitlementsItemProductWeightStylesItemNameMax = 64;

export const zodUpdateDiscordAccountResponseEntitlementsItemProductThumbnailTitleMax = 64;

export const zodUpdateDiscordAccountResponseEntitlementsItemProductThumbnailDescriptionMax = 512;

export const zodUpdateDiscordAccountResponseEntitlementsItemProductImagesItemTitleMax = 64;

export const zodUpdateDiscordAccountResponseEntitlementsItemProductImagesItemDescriptionMax = 512;

export const zodUpdateDiscordAccountResponseMinecraftAccountsItemBadgesItemImageTitleMax = 64;

export const zodUpdateDiscordAccountResponseMinecraftAccountsItemBadgesItemImageDescriptionMax = 512;

export const zodUpdateDiscordAccountResponse = zod.object({
	id: zod.string().describe('Discord user ID'),
	displayName: zod.string().describe('Discord display name'),
	username: zod.string().describe('Discord username (unique)'),
	discriminator: zod.string().nullish(),
	locale: zod.string().nullish().describe('Discord user locale'),
	avatar: zod.string().nullish().describe('Discord avatar URL hash'),
	banner: zod.string().nullish().describe('Discord banner URL hash'),
	settings: zod.object({
		prefix: zod.string().nullish().describe('Custom name prefix'),
		suffix: zod.string().nullish().describe('Custom name suffix'),
		features: zod
			.object({
				weightStyle: zod.number().nullish().describe('Name of weight style to use.'),
				weightStyleOverride: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe("Ability to override other's weight styles."),
				embedColor: zod
					.string()
					.max(zodUpdateDiscordAccountResponseSettingsFeaturesEmbedColorMax)
					.nullish()
					.describe('Embed color for the bot.'),
				moreInfoDefault: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Show \"More Info\" on weight command by default.'),
				hideShopPromotions: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('If shop promotions should be hidden.'),
				emojiUrl: zod
					.string()
					.max(zodUpdateDiscordAccountResponseSettingsFeaturesEmojiUrlMax)
					.nullish()
					.describe('Custom name emoji URL.'),
			})
			.nullish()
			.describe('Configurated features for the user'),
		weightStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodUpdateDiscordAccountResponseSettingsWeightStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected weight style for the user'),
		leaderboardStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodUpdateDiscordAccountResponseSettingsLeaderboardStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected leaderboard style for the user'),
		nameStyle: zod
			.object({
				id: zod.number(),
				name: zod.string().max(zodUpdateDiscordAccountResponseSettingsNameStyleNameMax).nullish(),
			})
			.nullish()
			.describe('Selected name style for the user'),
		fortune: zod
			.object({
				accounts: zod
					.record(
						zod.string(),
						zod.record(
							zod.string(),
							zod.object({
								strength: zod.number().describe('Amount of strength used for mooshroom fortune'),
								communityCenter: zod.number().describe('Community center farming fortune level'),
								rosewaterFlasks: zod.number().describe('Consumed Filled Rosewater Flasks'),
								attributes: zod.record(zod.string(), zod.number()).describe('Attribute shards'),
								chips: zod.record(zod.string(), zod.number()).describe('Garden chips'),
							})
						)
					)
					.describe('Member fortune settings for each minecraft account, then each profile.'),
			})
			.nullish()
			.describe('Fortune settings for the user'),
	}),
	entitlements: zod
		.array(
			zod.object({
				id: zod.string().describe('Entitlement ID'),
				type: zod
					.union([
						zod.literal(1),
						zod.literal(2),
						zod.literal(3),
						zod.literal(4),
						zod.literal(5),
						zod.literal(6),
						zod.literal(7),
						zod.literal(8),
					])
					.describe('Type of entitlement'),
				target: zod
					.union([zod.literal(0), zod.literal(1), zod.literal(2)])
					.describe('Target of entitlement.\n0 = None\n1 = User\n2 = Guild'),
				productId: zod.string().describe('SKU ID of the product'),
				product: zod
					.object({
						id: zod.string().describe('Product ID'),
						name: zod.string().describe('Product name'),
						slug: zod.string().describe('Slug of the product'),
						price: zod.number().describe('Product price'),
						description: zod.string().nullish().describe('Product description'),
						available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
						type: zod
							.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
							.describe('Type of product'),
						features: zod
							.object({
								badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
								weightStyles: zod
									.array(zod.string())
									.nullish()
									.describe('Name of weight style to unlock.'),
								weightStyleOverride: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe("Ability to override other's weight styles."),
								embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
								hideShopPromotions: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Ability to hide shop promotions.'),
								moreInfoDefault: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Show \"More Info\" on weight command by default.'),
								customEmoji: zod.coerce
									.boolean<boolean>()
									.nullish()
									.describe('Ability to have custom name emoji for the user.'),
								maxMonthlyEvents: zod
									.number()
									.nullish()
									.describe('Maximum number of events that can be created in a month. (For guilds)'),
								maxJacobLeaderboards: zod
									.number()
									.nullish()
									.describe(
										'Maximum number of jacob leaderboard that can be active at once. (For guilds)'
									),
								flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
							})
							.describe('Features of the product'),
						weightStyles: zod
							.array(
								zod.object({
									id: zod.number(),
									name: zod
										.string()
										.max(
											zodUpdateDiscordAccountResponseEntitlementsItemProductWeightStylesItemNameMax
										)
										.nullish(),
								})
							)
							.describe('Unlocked weight styles'),
						thumbnail: zod
							.object({
								title: zod
									.string()
									.max(zodUpdateDiscordAccountResponseEntitlementsItemProductThumbnailTitleMax)
									.nullish()
									.describe('Image title'),
								description: zod
									.string()
									.max(zodUpdateDiscordAccountResponseEntitlementsItemProductThumbnailDescriptionMax)
									.nullish()
									.describe('Image description'),
								order: zod.number().nullish().describe('Image ordering number'),
								width: zod.number().describe('The original width of the image.'),
								height: zod.number().describe('The original height of the image.'),
								sources: zod
									.record(
										zod.string(),
										zod.object({
											url: zod
												.string()
												.describe('The fully-qualified public URL for this image variant.'),
											width: zod.number().describe('The width of this image variant in pixels.'),
										})
									)
									.describe(
										'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
									),
								url: zod.string().describe('Lowest quality image URL'),
							})
							.nullish()
							.describe('Product thumbnail'),
						images: zod
							.array(
								zod.object({
									title: zod
										.string()
										.max(zodUpdateDiscordAccountResponseEntitlementsItemProductImagesItemTitleMax)
										.nullish()
										.describe('Image title'),
									description: zod
										.string()
										.max(
											zodUpdateDiscordAccountResponseEntitlementsItemProductImagesItemDescriptionMax
										)
										.nullish()
										.describe('Image description'),
									order: zod.number().nullish().describe('Image ordering number'),
									width: zod.number().describe('The original width of the image.'),
									height: zod.number().describe('The original height of the image.'),
									sources: zod
										.record(
											zod.string(),
											zod.object({
												url: zod
													.string()
													.describe('The fully-qualified public URL for this image variant.'),
												width: zod
													.number()
													.describe('The width of this image variant in pixels.'),
											})
										)
										.describe(
											'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
										),
									url: zod.string().describe('Lowest quality image URL'),
								})
							)
							.describe('Product Images'),
						flags: zod.number().describe('Discord flags'),
						isSubscription: zod.coerce.boolean<boolean>(),
						isGuildSubscription: zod.coerce.boolean<boolean>(),
						isUserSubscription: zod.coerce.boolean<boolean>(),
					})
					.describe('Product details'),
				deleted: zod.coerce.boolean<boolean>(),
				consumed: zod.coerce
					.boolean<boolean>()
					.nullish()
					.describe('Consumed status of the entitlement if applicable'),
				startDate: zod.iso.datetime({}).nullish().describe('Start date of the entitlement'),
				endDate: zod.iso.datetime({}).nullish().describe('End date of the entitlement'),
			})
		)
		.describe('Purchased entitlements from the Discord store'),
	minecraftAccounts: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				primaryAccount: zod.coerce.boolean<boolean>(),
				badges: zod.array(
					zod.object({
						id: zod.number(),
						image: zod.object({
							title: zod
								.string()
								.max(zodUpdateDiscordAccountResponseMinecraftAccountsItemBadgesItemImageTitleMax)
								.nullish()
								.describe('Image title'),
							description: zod
								.string()
								.max(zodUpdateDiscordAccountResponseMinecraftAccountsItemBadgesItemImageDescriptionMax)
								.nullish()
								.describe('Image description'),
							order: zod.number().nullish().describe('Image ordering number'),
							width: zod.number().describe('The original width of the image.'),
							height: zod.number().describe('The original height of the image.'),
							sources: zod
								.record(
									zod.string(),
									zod.object({
										url: zod
											.string()
											.describe('The fully-qualified public URL for this image variant.'),
										width: zod.number().describe('The width of this image variant in pixels.'),
									})
								)
								.describe(
									'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
								),
							url: zod.string().describe('Lowest quality image URL'),
						}),
						name: zod.string(),
						description: zod.string(),
						requirements: zod.string(),
						timestamp: zod.string(),
						visible: zod.coerce.boolean<boolean>(),
						order: zod.number(),
					})
				),
				skin: zod.object({
					texture: zod.string().nullish().describe('Minecraft skin texture ID'),
					face: zod.string().nullish().describe('Base64 data image of the 8x8 face'),
					hat: zod.string().nullish().describe('Base64 data image of the 8x8 hat (overlay on the face)'),
				}),
			})
		)
		.describe('Linked Minecraft accounts'),
	dismissedAnnouncements: zod.array(zod.string()).describe('Dismissed announcements by the user'),
});

/**
 * Creates a new confirmation that users will need to accept.
 * @summary Create a new confirmation
 */
export const zodCreateConfirmationBody = zod.object({
	title: zod.string(),
	content: zod.string(),
	isActive: zod.coerce.boolean<boolean>(),
});

export const zodCreateConfirmationResponse = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});

/**
 * Gets a confirmation that users will need to accept.
 * @summary Get a confirmation
 */
export const zodGetAllConfirmationsResponseItem = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});
export const zodGetAllConfirmationsResponse = zod.array(zodGetAllConfirmationsResponseItem);

/**
 * @summary Delete a login confirmation
 */
export const zodDeleteConfirmationParams = zod.object({
	id: zod.number(),
});

export const zodDeleteConfirmationResponse = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});

/**
 * Updates a confirmation that users will need to accept.
 * @summary Update a confirmation
 */
export const zodUpdateConfirmationParams = zod.object({
	id: zod.number(),
});

export const zodUpdateConfirmationBody = zod.object({
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
});

export const zodUpdateConfirmationResponse = zod.object({
	id: zod.number(),
	title: zod.string().nullish(),
	content: zod.string().nullish(),
	isActive: zod.coerce.boolean<boolean>(),
	createdAt: zod.iso.datetime({}),
});

/**
 * @summary Get a contest from a contest key
 */
export const zodGetContestFromKeyParams = zod.object({
	contestKey: zod.string().describe('A contest key in the format from the Hypixel API'),
});

export const zodGetContestFromKeyResponse = zod.object({
	crop: zod.string(),
	timestamp: zod.number(),
	participants: zod.number(),
	brackets: zod.object({
		bronze: zod.number(),
		silver: zod.number(),
		gold: zod.number(),
		platinum: zod.number(),
		diamond: zod.number(),
	}),
	participations: zod.array(
		zod.object({
			collected: zod.number(),
			position: zod.number(),
			medal: zod.string().nullish(),
			removed: zod.coerce.boolean<boolean>(),
			playerUuid: zod.string(),
			playerName: zod.string(),
			profileUuid: zod.string(),
		})
	),
});

/**
 * @summary Get the three contests that start at a specific timestamp
 */
export const zodGetContestsAtTimestampParams = zod.object({
	timestamp: zod.number(),
});

export const zodGetContestsAtTimestampQueryParams = zod.object({
	limit: zod.number().describe('Limit the number of participations returned in each contest.'),
});

export const zodGetContestsAtTimestampResponseItem = zod.object({
	crop: zod.string(),
	timestamp: zod.number(),
	participants: zod.number(),
	brackets: zod.object({
		bronze: zod.number(),
		silver: zod.number(),
		gold: zod.number(),
		platinum: zod.number(),
		diamond: zod.number(),
	}),
	participations: zod.array(
		zod.object({
			collected: zod.number(),
			position: zod.number(),
			medal: zod.string().nullish(),
			removed: zod.coerce.boolean<boolean>(),
			playerUuid: zod.string(),
			playerName: zod.string(),
			profileUuid: zod.string(),
		})
	),
});
export const zodGetContestsAtTimestampResponse = zod.array(zodGetContestsAtTimestampResponseItem);

/**
 * @summary Get the three contests in a specific SkyBlock day
 */
export const zodGetContestsInDayParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
	month: zod.number().describe('SkyBlock month'),
	day: zod.number().describe('SkyBlock day'),
});

export const zodGetContestsInDayResponseItem = zod.object({
	crop: zod.string(),
	timestamp: zod.number(),
	participants: zod.number(),
	brackets: zod.object({
		bronze: zod.number(),
		silver: zod.number(),
		gold: zod.number(),
		platinum: zod.number(),
		diamond: zod.number(),
	}),
	participations: zod.array(
		zod.object({
			collected: zod.number(),
			position: zod.number(),
			medal: zod.string().nullish(),
			removed: zod.coerce.boolean<boolean>(),
			playerUuid: zod.string(),
			playerName: zod.string(),
			profileUuid: zod.string(),
		})
	),
});
export const zodGetContestsInDayResponse = zod.array(zodGetContestsInDayResponseItem);

/**
 * @summary Get all contests in a SkyBlock month
 */
export const zodGetContestsInMonthParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
	month: zod.number().describe('SkyBlock month'),
});

export const zodGetContestsInMonthResponse = zod.record(
	zod.string(),
	zod.array(
		zod.object({
			crop: zod.string(),
			timestamp: zod.number(),
			participants: zod.number(),
			brackets: zod.object({
				bronze: zod.number(),
				silver: zod.number(),
				gold: zod.number(),
				platinum: zod.number(),
				diamond: zod.number(),
			}),
		})
	)
);

/**
 * @summary Get all contests in a SkyBlock year
 */
export const zodGetContestsInYearParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
});

export const zodGetContestsInYearQueryNowDefault = false;

export const zodGetContestsInYearQueryParams = zod.object({
	now: zod.coerce
		.boolean<boolean>()
		.nullish()
		.describe('If the year being requested is the current year. Not required.'),
});

export const zodGetContestsInYearResponse = zod.object({
	year: zod.number(),
	count: zod.number(),
	complete: zod.coerce.boolean<boolean>(),
	contests: zod.record(zod.string(), zod.array(zod.string())),
});

/**
 * Uses crowd-sourced data, which may not be accurate.
Data used and provided by <see href="https://github.com/hannibal002/SkyHanni/">SkyHanni</see> to display upcoming contests in-game.
 * @summary Get upcoming contests for the current SkyBlock year
 */
export const zodGetCurrentContestsResponse = zod.object({
	year: zod.number(),
	count: zod.number(),
	complete: zod.coerce.boolean<boolean>(),
	contests: zod.record(zod.string(), zod.array(zod.string())),
});

/**
 * Data used and provided by <see href="https://github.com/hannibal002/SkyHanni/">SkyHanni</see> to display upcoming contests in-game.
 * @summary Upload upcoming contests for the current SkyBlock year
 */
export const zodUploadCurrentContestsBody = zod.record(zod.string(), zod.array(zod.string()));

/**
 * @summary Get all contests for a player
 */
export const zodGetPlayerParticipationsParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetPlayerParticipationsResponseItem = zod.object({
	crop: zod.string(),
	timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
	collected: zod.number(),
	position: zod.number(),
	participants: zod.number(),
	medal: zod.string().nullish(),
});
export const zodGetPlayerParticipationsResponse = zod.array(zodGetPlayerParticipationsResponseItem);

/**
 * @summary Get all contests for a profile member
 */
export const zodGetProfileMemberParticipationsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetProfileMemberParticipationsResponseItem = zod.object({
	crop: zod.string(),
	timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
	collected: zod.number(),
	position: zod.number(),
	participants: zod.number(),
	medal: zod.string().nullish(),
});
export const zodGetProfileMemberParticipationsResponse = zod.array(zodGetProfileMemberParticipationsResponseItem);

/**
 * @summary Get contest records for a SkyBlock year
 */
export const zodGetRecordsInYearParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
});

export const zodGetRecordsInYearResponse = zod.object({
	year: zod.number(),
	crops: zod.record(
		zod.string(),
		zod.array(
			zod.object({
				playerUuid: zod.string(),
				playerName: zod.string(),
				profileUuid: zod.string(),
				removed: zod.coerce.boolean<boolean>(),
				timestamp: zod.number(),
				collected: zod.number(),
				position: zod.number(),
				participants: zod.number(),
			})
		)
	),
});

/**
 * @summary Get contests for the player's selected profile member
 */
export const zodGetSelectedMemberParticipationsParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetSelectedMemberParticipationsResponseItem = zod.object({
	crop: zod.string(),
	timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
	collected: zod.number(),
	position: zod.number(),
	participants: zod.number(),
	medal: zod.string().nullish(),
});
export const zodGetSelectedMemberParticipationsResponse = zod.array(zodGetSelectedMemberParticipationsResponseItem);

/**
 * @summary Add an Event Member to a Team
 */
export const zodAddTeamMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	teamId: zod.number(),
	player: zod.string().describe('Player uuid or ign'),
});

/**
 * @summary Kick an Event Team Member
 */
export const zodKickTeamMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	teamId: zod.number(),
	player: zod.string().describe('Player uuid or ign'),
});

/**
 * @summary Ban an Event Member
 */
export const zodBanMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	playerUuid: zod.string(),
});

export const zodBanMemberAdminBody = zod.string();

export const zodBanMemberAdminResponseMetaPrefixMax = 16;

export const zodBanMemberAdminResponseMetaSuffixMax = 16;

export const zodBanMemberAdminResponseNotesMax = 128;

export const zodBanMemberAdminResponse = zod.object({
	playerUuid: zod.string().nullish(),
	profileId: zod.string().nullish(),
	playerName: zod.string().nullish(),
	eventId: zod.string(),
	teamId: zod.string().nullish(),
	status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
	score: zod.string().nullish(),
	lastUpdated: zod.string().nullish(),
	disqualified: zod.coerce.boolean<boolean>().nullish(),
	data: zod.unknown().nullish(),
	estimatedTimeActive: zod.string().nullish(),
	meta: zod
		.object({
			prefix: zod.string().max(zodBanMemberAdminResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodBanMemberAdminResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Metadata of the entry'),
	id: zod.number(),
	accountId: zod.string().nullish(),
	notes: zod.string().max(zodBanMemberAdminResponseNotesMax).nullish(),
});

/**
 * @summary Unban an Event Member
 */
export const zodUnbanMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	playerUuid: zod.string(),
});

/**
 * @summary Create Event
 */
export const zodCreateEventAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodCreateEventAdminBodyNameMax = 64;

export const zodCreateEventAdminBodyDescriptionMax = 1024;

export const zodCreateEventAdminBodyRulesMax = 1024;

export const zodCreateEventAdminBodyPrizeInfoMax = 1024;

export const zodCreateEventAdminBodyRequiredRoleMax = 24;

export const zodCreateEventAdminBodyBlockedRoleMax = 24;

export const zodCreateEventAdminBody = zod.object({
	name: zod.string().min(1).max(zodCreateEventAdminBodyNameMax).describe('The name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.nullish()
		.describe('The type of the event'),
	guildId: zod.string().min(1).describe('The Discord server id as a string for the event'),
	description: zod
		.string()
		.max(zodCreateEventAdminBodyDescriptionMax)
		.nullish()
		.describe('An optional description for the event'),
	rules: zod
		.string()
		.max(zodCreateEventAdminBodyRulesMax)
		.nullish()
		.describe('An optional set of rules for the event'),
	prizeInfo: zod
		.string()
		.max(zodCreateEventAdminBodyPrizeInfoMax)
		.nullish()
		.describe('An optional description of prizes for the event'),
	startTime: zod.number().describe('Unix timestamp for the start time of the event in seconds'),
	endTime: zod.number().describe('Unix timestamp for the end time of the event in seconds'),
	joinTime: zod
		.number()
		.nullish()
		.describe('Unix timestamp for the latest time a new member can join the event in seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().nullish().describe('Currently unused'),
	requiredRole: zod
		.string()
		.max(zodCreateEventAdminBodyRequiredRoleMax)
		.nullish()
		.describe('A Discord role id that is required to participate in the event'),
	blockedRole: zod
		.string()
		.max(zodCreateEventAdminBodyBlockedRoleMax)
		.nullish()
		.describe('A Discord role id that is blocked from participating in the event'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
});

export const zodCreateEventAdminResponseBannerTitleMax = 64;

export const zodCreateEventAdminResponseBannerDescriptionMax = 512;

export const zodCreateEventAdminResponse = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodCreateEventAdminResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodCreateEventAdminResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});

/**
 * This generally should only be used for events with a set amount of teams (when users are not allowed to create their own teams)
 * @summary Create an Event Team
 */
export const zodCreateTeamAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodCreateTeamAdminQueryParams = zod.object({
	userId: zod.string().nullish(),
});

export const zodCreateTeamAdminBodyNameMax = 3;

export const zodCreateTeamAdminBodyColorMax = 7;

export const zodCreateTeamAdminBody = zod.object({
	name: zod
		.array(zod.string())
		.min(1)
		.max(zodCreateTeamAdminBodyNameMax)
		.nullish()
		.describe('An array of strings for the team name, example: [ \"Bountiful\", \"Farmers\" ]'),
	color: zod.string().max(zodCreateTeamAdminBodyColorMax).nullish(),
});

/**
 * Delete an event and all associated data. Only available for unapproved events.
 * @summary Delete Event
 */
export const zodDeleteEventAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

/**
 * @summary Update Event
 */
export const zodUpdateEventAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodUpdateEventAdminBody = zod.object({
	name: zod.string().nullish(),
	type: zod.string().nullish(),
	description: zod.string().nullish(),
	rules: zod.string().nullish(),
	prizeInfo: zod.string().nullish(),
	startTime: zod.number().nullish(),
	joinTime: zod.number().nullish(),
	endTime: zod.number().nullish(),
	dynamicStartTime: zod.coerce.boolean<boolean>().nullish(),
	active: zod.coerce.boolean<boolean>().nullish(),
	requiredRole: zod.string().nullish(),
	blockedRole: zod.string().nullish(),
	guildId: zod.string().nullish(),
	weightData: zod
		.object({
			cropWeights: zod.record(zod.string(), zod.number()).describe('The weights of each crop in the event'),
		})
		.nullish(),
	medalData: zod
		.object({
			medalWeights: zod.record(zod.string(), zod.number()),
		})
		.nullish(),
	pestData: zod
		.object({
			pestWeights: zod.record(zod.string(), zod.number()),
		})
		.nullish(),
	collectionData: zod
		.object({
			collectionWeights: zod.record(
				zod.string(),
				zod.object({
					name: zod.string().nullish(),
					weight: zod.number(),
				})
			),
		})
		.nullish(),
});

export const zodUpdateEventAdminResponseBannerTitleMax = 64;

export const zodUpdateEventAdminResponseBannerDescriptionMax = 512;

export const zodUpdateEventAdminResponse = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodUpdateEventAdminResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodUpdateEventAdminResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});

/**
 * @summary Delete Custom Event Banner
 */
export const zodDeleteEventBannerAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

/**
 * @summary Set Custom Event Banner
 */
export const zodSetEventBannerAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodSetEventBannerAdminBody = zod.object({
	image: zod.instanceof(File).nullish(),
});

/**
 * @summary Delete an Event Member
 */
export const zodDeleteMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	playerUuid: zod.string(),
});

export const zodDeleteMemberAdminQueryParams = zod.object({
	profileUuid: zod.string().nullish(),
	recordId: zod.number().nullish(),
});

/**
 * @summary Ban an Event Member
 */
export const zodForceAddMemberAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	playerUuid: zod.string(),
});

export const zodForceAddMemberAdminQueryParams = zod.object({
	profileUuid: zod.string(),
});

/**
 * @summary Delete an Event Team
 */
export const zodDeleteTeamAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
	teamId: zod.number(),
});

/**
 * @summary Update a team
 */
export const zodUpdateTeamAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodUpdateTeamAdminBodyNameMax = 3;

export const zodUpdateTeamAdminBodyColorMax = 7;

export const zodUpdateTeamAdminBody = zod.object({
	name: zod
		.array(zod.string())
		.min(1)
		.max(zodUpdateTeamAdminBodyNameMax)
		.nullish()
		.describe('An array of strings for the team name, example: [ \"Bountiful\", \"Farmers\" ]'),
	color: zod.string().max(zodUpdateTeamAdminBodyColorMax).nullish(),
	changeCode: zod.coerce.boolean<boolean>().nullish().describe('If join code should be changed'),
});

/**
 * @summary Get banned event members
 */
export const zodGetBannedMembersAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodGetBannedMembersAdminResponseMetaPrefixMax = 16;

export const zodGetBannedMembersAdminResponseMetaSuffixMax = 16;

export const zodGetBannedMembersAdminResponseNotesMax = 128;

export const zodGetBannedMembersAdminResponseItem = zod.object({
	playerUuid: zod.string().nullish(),
	profileId: zod.string().nullish(),
	playerName: zod.string().nullish(),
	eventId: zod.string(),
	teamId: zod.string().nullish(),
	status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
	score: zod.string().nullish(),
	lastUpdated: zod.string().nullish(),
	disqualified: zod.coerce.boolean<boolean>().nullish(),
	data: zod.unknown().nullish(),
	estimatedTimeActive: zod.string().nullish(),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetBannedMembersAdminResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetBannedMembersAdminResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Metadata of the entry'),
	id: zod.number(),
	accountId: zod.string().nullish(),
	notes: zod.string().max(zodGetBannedMembersAdminResponseNotesMax).nullish(),
});
export const zodGetBannedMembersAdminResponse = zod.array(zodGetBannedMembersAdminResponseItem);

/**
 * @summary Get event members
 */
export const zodGetGuildEventMembersAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodGetGuildEventMembersAdminResponseMetaPrefixMax = 16;

export const zodGetGuildEventMembersAdminResponseMetaSuffixMax = 16;

export const zodGetGuildEventMembersAdminResponseNotesMax = 128;

export const zodGetGuildEventMembersAdminResponseItem = zod.object({
	playerUuid: zod.string().nullish(),
	profileId: zod.string().nullish(),
	playerName: zod.string().nullish(),
	eventId: zod.string(),
	teamId: zod.string().nullish(),
	status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
	score: zod.string().nullish(),
	lastUpdated: zod.string().nullish(),
	disqualified: zod.coerce.boolean<boolean>().nullish(),
	data: zod.unknown().nullish(),
	estimatedTimeActive: zod.string().nullish(),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetGuildEventMembersAdminResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetGuildEventMembersAdminResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Metadata of the entry'),
	id: zod.number(),
	accountId: zod.string().nullish(),
	notes: zod.string().max(zodGetGuildEventMembersAdminResponseNotesMax).nullish(),
});
export const zodGetGuildEventMembersAdminResponse = zod.array(zodGetGuildEventMembersAdminResponseItem);

/**
 * @summary Get an event for a guild
 */
export const zodGetGuildEventAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodGetGuildEventAdminResponseBannerTitleMax = 64;

export const zodGetGuildEventAdminResponseBannerDescriptionMax = 512;

export const zodGetGuildEventAdminResponse = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetGuildEventAdminResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetGuildEventAdminResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});

/**
 * @summary Get all events for a guild
 */
export const zodGetGuildEventsAdminParams = zod.object({
	discordId: zod.number(),
});

export const zodGetGuildEventsAdminResponseBannerTitleMax = 64;

export const zodGetGuildEventsAdminResponseBannerDescriptionMax = 512;

export const zodGetGuildEventsAdminResponseItem = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetGuildEventsAdminResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetGuildEventsAdminResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});
export const zodGetGuildEventsAdminResponse = zod.array(zodGetGuildEventsAdminResponseItem);

/**
 * @summary Get event teams
 */
export const zodGetTeamsAdminParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	eventId: zod.number(),
});

export const zodGetTeamsAdminResponseMembersItemNotesMax = 128;

export const zodGetTeamsAdminResponseMembersItemMetaPrefixMax = 16;

export const zodGetTeamsAdminResponseMembersItemMetaSuffixMax = 16;

export const zodGetTeamsAdminResponseItem = zod.object({
	id: zod.number(),
	eventId: zod.string().nullish(),
	name: zod.string().nullish(),
	color: zod.string().nullish(),
	score: zod.string().nullish(),
	ownerId: zod.string().nullish(),
	ownerUuid: zod.string().nullish(),
	members: zod.array(
		zod.object({
			playerUuid: zod.string().nullish(),
			playerName: zod.string().nullish(),
			profileId: zod.string().nullish(),
			eventId: zod.string(),
			teamId: zod.string().nullish(),
			status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
			score: zod.string().nullish(),
			data: zod.unknown().nullish(),
			lastUpdated: zod.string().nullish(),
			disqualified: zod.coerce.boolean<boolean>(),
			notes: zod.string().max(zodGetTeamsAdminResponseMembersItemNotesMax).nullish(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetTeamsAdminResponseMembersItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetTeamsAdminResponseMembersItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Metadata of the entry'),
		})
	),
	joinCode: zod
		.string()
		.nullish()
		.describe('Join code for the team, only populated if authenticated user is the owner'),
});
export const zodGetTeamsAdminResponse = zod.array(zodGetTeamsAdminResponseItem);

/**
 * @summary Set player as team owner
 */
export const zodSetTeamOwnerAdminParams = zod.object({
	discordId: zod.number(),
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodSetTeamOwnerAdminBody = zod.object({
	player: zod.string(),
});

/**
 * @summary Get an event
 */
export const zodGetEventParams = zod.object({
	eventId: zod.number(),
});

export const zodGetEventResponseBannerTitleMax = 64;

export const zodGetEventResponseBannerDescriptionMax = 512;

export const zodGetEventResponse = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetEventResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetEventResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});

/**
 * Default constants for event settings.
 * @summary Get event default constants
 */
export const zodGetEventDefaultsResponse = zod.object({
	cropWeights: zod.record(zod.string(), zod.number()),
	medalValues: zod.record(zod.string(), zod.number()),
	pestWeights: zod.record(zod.string(), zod.number()),
});

/**
 * @summary Get an event member
 */
export const zodGetEventMemberParams = zod.object({
	eventId: zod.number(),
	playerUuid: zod.string(),
});

export const zodGetEventMemberResponseNotesMax = 128;

export const zodGetEventMemberResponseMetaPrefixMax = 16;

export const zodGetEventMemberResponseMetaSuffixMax = 16;

export const zodGetEventMemberResponse = zod.object({
	playerUuid: zod.string().nullish(),
	playerName: zod.string().nullish(),
	profileId: zod.string().nullish(),
	eventId: zod.string(),
	teamId: zod.string().nullish(),
	status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
	score: zod.string().nullish(),
	data: zod.unknown().nullish(),
	lastUpdated: zod.string().nullish(),
	disqualified: zod.coerce.boolean<boolean>(),
	notes: zod.string().max(zodGetEventMemberResponseNotesMax).nullish(),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetEventMemberResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetEventMemberResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Metadata of the entry'),
});

/**
 * @summary Get event members
 */
export const zodGetEventMembersParams = zod.object({
	eventId: zod.number(),
});

export const zodGetEventMembersResponseMetaPrefixMax = 16;

export const zodGetEventMembersResponseMetaSuffixMax = 16;

export const zodGetEventMembersResponseItem = zod.object({
	playerUuid: zod.string().nullish(),
	profileId: zod.string().nullish(),
	playerName: zod.string().nullish(),
	eventId: zod.string(),
	teamId: zod.string().nullish(),
	status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
	score: zod.string().nullish(),
	lastUpdated: zod.string().nullish(),
	disqualified: zod.coerce.boolean<boolean>().nullish(),
	data: zod.unknown().nullish(),
	estimatedTimeActive: zod.string().nullish(),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetEventMembersResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetEventMembersResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Metadata of the entry'),
});
export const zodGetEventMembersResponse = zod.array(zodGetEventMembersResponseItem);

/**
 * @summary Get an event team
 */
export const zodGetEventTeamParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodGetEventTeamResponseMembersItemNotesMax = 128;

export const zodGetEventTeamResponseMembersItemMetaPrefixMax = 16;

export const zodGetEventTeamResponseMembersItemMetaSuffixMax = 16;

export const zodGetEventTeamResponse = zod.object({
	id: zod.number(),
	eventId: zod.string().nullish(),
	name: zod.string().nullish(),
	color: zod.string().nullish(),
	score: zod.string().nullish(),
	ownerId: zod.string().nullish(),
	ownerUuid: zod.string().nullish(),
	members: zod.array(
		zod.object({
			playerUuid: zod.string().nullish(),
			playerName: zod.string().nullish(),
			profileId: zod.string().nullish(),
			eventId: zod.string(),
			teamId: zod.string().nullish(),
			status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
			score: zod.string().nullish(),
			data: zod.unknown().nullish(),
			lastUpdated: zod.string().nullish(),
			disqualified: zod.coerce.boolean<boolean>(),
			notes: zod.string().max(zodGetEventTeamResponseMembersItemNotesMax).nullish(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetEventTeamResponseMembersItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetEventTeamResponseMembersItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Metadata of the entry'),
		})
	),
	joinCode: zod
		.string()
		.nullish()
		.describe('Join code for the team, only populated if authenticated user is the owner'),
});

/**
 * @summary Delete team
 */
export const zodDeleteTeamParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

/**
 * @summary Update a team
 */
export const zodUpdateTeamParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodUpdateTeamBodyNameMax = 3;

export const zodUpdateTeamBodyColorMax = 7;

export const zodUpdateTeamBody = zod.object({
	name: zod
		.array(zod.string())
		.min(1)
		.max(zodUpdateTeamBodyNameMax)
		.nullish()
		.describe('An array of strings for the team name, example: [ \"Bountiful\", \"Farmers\" ]'),
	color: zod.string().max(zodUpdateTeamBodyColorMax).nullish(),
	changeCode: zod.coerce.boolean<boolean>().nullish().describe('If join code should be changed'),
});

/**
 * @summary Get event teams
 */
export const zodGetEventTeamsParams = zod.object({
	eventId: zod.number(),
});

export const zodGetEventTeamsResponseMembersItemNotesMax = 128;

export const zodGetEventTeamsResponseMembersItemMetaPrefixMax = 16;

export const zodGetEventTeamsResponseMembersItemMetaSuffixMax = 16;

export const zodGetEventTeamsResponseItem = zod.object({
	id: zod.number(),
	eventId: zod.string().nullish(),
	name: zod.string().nullish(),
	color: zod.string().nullish(),
	score: zod.string().nullish(),
	ownerId: zod.string().nullish(),
	ownerUuid: zod.string().nullish(),
	members: zod.array(
		zod.object({
			playerUuid: zod.string().nullish(),
			playerName: zod.string().nullish(),
			profileId: zod.string().nullish(),
			eventId: zod.string(),
			teamId: zod.string().nullish(),
			status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
			score: zod.string().nullish(),
			data: zod.unknown().nullish(),
			lastUpdated: zod.string().nullish(),
			disqualified: zod.coerce.boolean<boolean>(),
			notes: zod.string().max(zodGetEventTeamsResponseMembersItemNotesMax).nullish(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetEventTeamsResponseMembersItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetEventTeamsResponseMembersItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Metadata of the entry'),
		})
	),
	joinCode: zod
		.string()
		.nullish()
		.describe('Join code for the team, only populated if authenticated user is the owner'),
});
export const zodGetEventTeamsResponse = zod.array(zodGetEventTeamsResponseItem);

/**
 * @summary Create a team
 */
export const zodCreateTeamParams = zod.object({
	eventId: zod.number(),
});

export const zodCreateTeamBodyNameMax = 3;

export const zodCreateTeamBodyColorMax = 7;

export const zodCreateTeamBody = zod.object({
	name: zod
		.array(zod.string())
		.min(1)
		.max(zodCreateTeamBodyNameMax)
		.nullish()
		.describe('An array of strings for the team name, example: [ \"Bountiful\", \"Farmers\" ]'),
	color: zod.string().max(zodCreateTeamBodyColorMax).nullish(),
});

/**
 * Lists of whitelisted words for team name generation.
 * @summary Get event team word list constants
 */
export const zodGetTeamWordListResponse = zod.object({
	first: zod.array(zod.string()),
	second: zod.array(zod.string()),
	third: zod.array(zod.string()),
});

/**
 * @summary Get upcoming events
 */
export const zodGetUpcomingEventsQueryOffsetDefault = 0;

export const zodGetUpcomingEventsQueryParams = zod.object({
	offset: zod.number().nullish().describe('Offset by an amount of days to also include recently ended events.'),
});

export const zodGetUpcomingEventsResponseBannerTitleMax = 64;

export const zodGetUpcomingEventsResponseBannerDescriptionMax = 512;

export const zodGetUpcomingEventsResponseItem = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetUpcomingEventsResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetUpcomingEventsResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});
export const zodGetUpcomingEventsResponse = zod.array(zodGetUpcomingEventsResponseItem);

/**
 * @summary Join an event
 */
export const zodJoinEventParams = zod.object({
	eventId: zod.number(),
});

export const zodJoinEventQueryParams = zod.object({
	playerUuid: zod.string().nullish(),
	profileUuid: zod.string().nullish(),
});

/**
 * @summary Join a team
 */
export const zodJoinTeamParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodJoinTeamBody = zod.string();

/**
 * Kicked members can rejoin the team if they have the join code.
 * @summary Kick a team member
 */
export const zodKickTeamMemberParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
	player: zod.string().describe('Player uuid or ign'),
});

/**
 * @summary Join an event
 */
export const zodLeaveEventParams = zod.object({
	eventId: zod.number(),
});

/**
 * @summary Leave a team
 */
export const zodLeaveTeamParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

/**
 * @summary Set player as team owner
 */
export const zodSetTeamOwnerParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

export const zodSetTeamOwnerBody = zod.object({
	player: zod.string(),
});

/**
 * @summary Generate new team join code
 */
export const zodUpdateTeamJoinCodeParams = zod.object({
	eventId: zod.number(),
	teamId: zod.number(),
});

/**
 * Get Garden data for a specific profile by UUID
 * @summary Get Garden data for a profile
 */
export const zodGetGardenParams = zod.object({
	profileUuid: zod.string(),
});

export const zodGetGardenResponse = zod.object({
	profileId: zod.string().describe('Profile ID'),
	experience: zod.number().describe('Garden experience'),
	completedVisitors: zod.number().describe('Total completed visitors'),
	uniqueVisitors: zod.number().describe('Unique visitors unlocked'),
	crops: zod
		.object({
			cactus: zod.string().nullish(),
			carrot: zod.string().nullish(),
			potato: zod.string().nullish(),
			wheat: zod.string().nullish(),
			melon: zod.string().nullish(),
			pumpkin: zod.string().nullish(),
			mushroom: zod.string().nullish(),
			cocoaBeans: zod.string().nullish(),
			sugarCane: zod.string().nullish(),
			netherWart: zod.string().nullish(),
			sunflower: zod.string().nullish(),
			moonflower: zod.string().nullish(),
			wildRose: zod.string().nullish(),
		})
		.describe('Crops counted towards milestones'),
	cropUpgrades: zod
		.object({
			cactus: zod.number(),
			carrot: zod.number(),
			potato: zod.number(),
			wheat: zod.number(),
			melon: zod.number(),
			pumpkin: zod.number(),
			mushroom: zod.number(),
			cocoaBeans: zod.number(),
			sugarCane: zod.number(),
			netherWart: zod.number(),
			sunflower: zod.number(),
			moonflower: zod.number(),
			wildRose: zod.number(),
		})
		.describe('Crop upgrades'),
	plots: zod.array(zod.string()).describe('List of unlocked plots'),
	composter: zod
		.object({
			organic_matter: zod.number(),
			fuel_units: zod.number(),
			compost_units: zod.number(),
			compost_items: zod.number(),
			conversion_ticks: zod.number(),
			last_save: zod.number(),
			upgrades: zod.object({
				speed: zod.number(),
				multi_drop: zod.number(),
				fuel_cap: zod.number(),
				organic_matter_cap: zod.number(),
				cost_reduction: zod.number(),
			}),
			lastSave: zod.number().describe('Last save time in unix seconds'),
		})
		.describe('Composter data'),
	visitors: zod
		.record(
			zod.string(),
			zod.object({
				visits: zod.number(),
				accepted: zod.number(),
			})
		)
		.describe('Visitor data'),
	lastSave: zod.string().describe('Last save time in unix seconds'),
});

/**
 * Get selected Garden data for a specific player by UUID
 * @summary Get selected Garden data for a player
 */
export const zodGetSelectedGardenParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetSelectedGardenResponse = zod.object({
	profileId: zod.string().describe('Profile ID'),
	experience: zod.number().describe('Garden experience'),
	completedVisitors: zod.number().describe('Total completed visitors'),
	uniqueVisitors: zod.number().describe('Unique visitors unlocked'),
	crops: zod
		.object({
			cactus: zod.string().nullish(),
			carrot: zod.string().nullish(),
			potato: zod.string().nullish(),
			wheat: zod.string().nullish(),
			melon: zod.string().nullish(),
			pumpkin: zod.string().nullish(),
			mushroom: zod.string().nullish(),
			cocoaBeans: zod.string().nullish(),
			sugarCane: zod.string().nullish(),
			netherWart: zod.string().nullish(),
			sunflower: zod.string().nullish(),
			moonflower: zod.string().nullish(),
			wildRose: zod.string().nullish(),
		})
		.describe('Crops counted towards milestones'),
	cropUpgrades: zod
		.object({
			cactus: zod.number(),
			carrot: zod.number(),
			potato: zod.number(),
			wheat: zod.number(),
			melon: zod.number(),
			pumpkin: zod.number(),
			mushroom: zod.number(),
			cocoaBeans: zod.number(),
			sugarCane: zod.number(),
			netherWart: zod.number(),
			sunflower: zod.number(),
			moonflower: zod.number(),
			wildRose: zod.number(),
		})
		.describe('Crop upgrades'),
	plots: zod.array(zod.string()).describe('List of unlocked plots'),
	composter: zod
		.object({
			organic_matter: zod.number(),
			fuel_units: zod.number(),
			compost_units: zod.number(),
			compost_items: zod.number(),
			conversion_ticks: zod.number(),
			last_save: zod.number(),
			upgrades: zod.object({
				speed: zod.number(),
				multi_drop: zod.number(),
				fuel_cap: zod.number(),
				organic_matter_cap: zod.number(),
				cost_reduction: zod.number(),
			}),
			lastSave: zod.number().describe('Last save time in unix seconds'),
		})
		.describe('Composter data'),
	visitors: zod
		.record(
			zod.string(),
			zod.object({
				visits: zod.number(),
				accepted: zod.number(),
			})
		)
		.describe('Visitor data'),
	lastSave: zod.string().describe('Last save time in unix seconds'),
});

/**
 * @summary Get Admin Crop Collections
 */
export const zodGetAdminCropGraphsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetAdminCropGraphsQueryFromDefault = 0;
export const zodGetAdminCropGraphsQueryDaysDefault = 7;
export const zodGetAdminCropGraphsQueryPerDayDefault = 4;

export const zodGetAdminCropGraphsQueryParams = zod.object({
	from: zod.number().nullish().describe('Unix timestamp in seconds for the start of the data to return'),
	days: zod
		.number()
		.default(zodGetAdminCropGraphsQueryDaysDefault)
		.describe('Amount of days after the \"from\" timestamp to include'),
	perDay: zod
		.number()
		.default(zodGetAdminCropGraphsQueryPerDayDefault)
		.describe('Data points returned per 24-hour period'),
});

export const zodGetAdminCropGraphsResponseItem = zod.object({
	timestamp: zod.number(),
	cropWeight: zod.string(),
	crops: zod.record(zod.string(), zod.number()),
	pests: zod.record(zod.string(), zod.number()),
});
export const zodGetAdminCropGraphsResponse = zod.array(zodGetAdminCropGraphsResponseItem);

/**
 * @summary Get Admin Skill XP
 */
export const zodGetAdminSkillGraphsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetAdminSkillGraphsQueryFromDefault = 0;
export const zodGetAdminSkillGraphsQueryDaysDefault = 7;
export const zodGetAdminSkillGraphsQueryPerDayDefault = 4;

export const zodGetAdminSkillGraphsQueryParams = zod.object({
	from: zod.number().nullish(),
	days: zod.number().default(zodGetAdminSkillGraphsQueryDaysDefault),
	perDay: zod.number().default(zodGetAdminSkillGraphsQueryPerDayDefault),
});

export const zodGetAdminSkillGraphsResponseItem = zod.object({
	timestamp: zod.number(),
	skills: zod.record(zod.string(), zod.number()),
});
export const zodGetAdminSkillGraphsResponse = zod.array(zodGetAdminSkillGraphsResponseItem);

/**
 * @summary Get Crop Collections Over Time
 */
export const zodGetCropGraphsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetCropGraphsQueryFromDefault = 0;
export const zodGetCropGraphsQueryDaysDefault = 7;
export const zodGetCropGraphsQueryPerDayDefault = 4;

export const zodGetCropGraphsQueryParams = zod.object({
	from: zod.number().nullish(),
	days: zod.number().default(zodGetCropGraphsQueryDaysDefault),
	perDay: zod.number().default(zodGetCropGraphsQueryPerDayDefault),
});

export const zodGetCropGraphsResponseItem = zod.object({
	timestamp: zod.number(),
	cropWeight: zod.string(),
	crops: zod.record(zod.string(), zod.number()),
	pests: zod.record(zod.string(), zod.number()),
});
export const zodGetCropGraphsResponse = zod.array(zodGetCropGraphsResponseItem);

/**
 * @summary Get Skill XP Over Time
 */
export const zodGetSkillGraphsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetSkillGraphsQueryFromDefault = 0;
export const zodGetSkillGraphsQueryDaysDefault = 7;
export const zodGetSkillGraphsQueryPerDayDefault = 4;

export const zodGetSkillGraphsQueryParams = zod.object({
	from: zod.number().nullish(),
	days: zod.number().default(zodGetSkillGraphsQueryDaysDefault),
	perDay: zod.number().default(zodGetSkillGraphsQueryPerDayDefault),
});

export const zodGetSkillGraphsResponseItem = zod.object({
	timestamp: zod.number(),
	skills: zod.record(zod.string(), zod.number()),
});
export const zodGetSkillGraphsResponse = zod.array(zodGetSkillGraphsResponseItem);

/**
 * @summary Get current average medal brackets
 */
export const zodGetCurrentMedalBracketsQueryMonthsDefault = 2;

export const zodGetCurrentMedalBracketsQueryParams = zod.object({
	months: zod
		.number()
		.default(zodGetCurrentMedalBracketsQueryMonthsDefault)
		.describe('Amount of previous SkyBlock months to include in the average'),
});

export const zodGetCurrentMedalBracketsResponse = zod.object({
	start: zod.string(),
	end: zod.string(),
	brackets: zod.record(
		zod.string(),
		zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
			platinum: zod.number(),
			diamond: zod.number(),
		})
	),
});

/**
 * @summary Get average medal brackets for a specific SkyBlock month
 */
export const zodGetMedalBracketsParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
	month: zod.number().describe('SkyBlock month'),
});

export const zodGetMedalBracketsQueryMonthsDefault = 2;

export const zodGetMedalBracketsQueryParams = zod.object({
	months: zod
		.number()
		.default(zodGetMedalBracketsQueryMonthsDefault)
		.describe('Amount of previous SkyBlock months to include in the average'),
});

export const zodGetMedalBracketsResponse = zod.object({
	start: zod.string(),
	end: zod.string(),
	brackets: zod.record(
		zod.string(),
		zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
			platinum: zod.number(),
			diamond: zod.number(),
		})
	),
});

/**
 * @summary Get average medal brackets for multiple SkyBlock years
 */
export const zodGetMedalBracketsGraphParams = zod.object({
	year: zod.number().describe('SkyBlock year'),
});

export const zodGetMedalBracketsGraphQueryYearsDefault = 2;
export const zodGetMedalBracketsGraphQueryMonthsDefault = 2;

export const zodGetMedalBracketsGraphQueryParams = zod.object({
	years: zod
		.number()
		.default(zodGetMedalBracketsGraphQueryYearsDefault)
		.describe('Amount of previous SkyBlock years to include in the average'),
	months: zod
		.number()
		.default(zodGetMedalBracketsGraphQueryMonthsDefault)
		.describe('Amount of previous SkyBlock months to include in the average'),
});

export const zodGetMedalBracketsGraphResponseItem = zod.object({
	start: zod.string(),
	end: zod.string(),
	brackets: zod.record(
		zod.string(),
		zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
			platinum: zod.number(),
			diamond: zod.number(),
		})
	),
});
export const zodGetMedalBracketsGraphResponse = zod.array(zodGetMedalBracketsGraphResponseItem);

/**
 * Retrieves a list of guides waiting for approval.
 * @summary Get pending guides
 */
export const zodAdminPendingGuidesResponseItem = zod.object({
	id: zod.number(),
	slug: zod.string(),
	title: zod.string(),
	status: zod.string(),
	iconSkyblockId: zod.string().nullish(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	score: zod.number(),
	views: zod.number(),
	createdAt: zod.iso.datetime({}),
	description: zod.string(),
	tags: zod.array(zod.string()),
});
export const zodAdminPendingGuidesResponse = zod.array(zodAdminPendingGuidesResponseItem);

/**
 * Approves a pending comment, making it visible to all users.
 * @summary Approve a comment
 */
export const zodApproveCommentParams = zod.object({
	commentId: zod.number(),
});

/**
 * Approve a pending guide and publish it.
 * @summary Approve and publish a guide
 */
export const zodApproveGuideParams = zod.object({
	guideId: zod.number(),
});

/**
 * Add a guide to user's bookmarks/favorites.
 * @summary Bookmark a guide
 */
export const zodBookmarkGuideParams = zod.object({
	guideId: zod.number(),
});

/**
 * Remove a guide from user's bookmarks.
 * @summary Remove bookmark
 */
export const zodUnbookmarkGuideParams = zod.object({
	guideId: zod.number(),
});

/**
 * Create a new comment on a guide.
 * @summary Post a comment
 */
export const zodCreateCommentParams = zod.object({
	guideId: zod.number(),
});

export const zodCreateCommentBodyContentMin = 0;
export const zodCreateCommentBodyContentMax = 2048;

export const zodCreateCommentBodyLiftedElementIdMin = 0;
export const zodCreateCommentBodyLiftedElementIdMax = 128;

export const zodCreateCommentBody = zod.object({
	parentId: zod.number().nullish(),
	content: zod.string().min(zodCreateCommentBodyContentMin).max(zodCreateCommentBodyContentMax),
	liftedElementId: zod
		.string()
		.min(zodCreateCommentBodyLiftedElementIdMin)
		.max(zodCreateCommentBodyLiftedElementIdMax)
		.nullish(),
});

export const zodCreateCommentResponse = zod.object({
	id: zod.number(),
	sqid: zod.string(),
	parentId: zod.number().nullish(),
	content: zod.string(),
	draftContent: zod.string().nullish(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	createdAt: zod.iso.datetime({}),
	editedAt: zod.iso.datetime({}).nullish(),
	score: zod.number(),
	liftedElementId: zod.string().nullish(),
	userVote: zod.number().nullish(),
	isPending: zod.coerce.boolean<boolean>(),
	isDeleted: zod.coerce.boolean<boolean>(),
	isEdited: zod.coerce.boolean<boolean>(),
	isEditedByAdmin: zod.coerce.boolean<boolean>(),
	hasPendingEdit: zod.coerce.boolean<boolean>(),
});

/**
 * Initializes a new empty guide draft for the user.
 * @summary Create a new guide draft
 */
export const zodCreateGuideBody = zod.object({
	type: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
});

/**
 * Search and list published guides with optional filtering and sorting.
 * @summary List guides
 */
export const zodListGuidesQueryParams = zod.object({
	query: zod.string().nullish(),
	type: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]).nullish(),
	tags: zod.array(zod.number()).nullish(),
	sort: zod.enum(['newest', 'topRated', 'trending']),
	page: zod.number(),
	pageSize: zod.number(),
});

export const zodListGuidesResponseItem = zod.object({
	id: zod.number(),
	slug: zod.string(),
	title: zod.string(),
	status: zod.string(),
	iconSkyblockId: zod.string().nullish(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	score: zod.number(),
	views: zod.number(),
	createdAt: zod.iso.datetime({}),
	description: zod.string(),
	tags: zod.array(zod.string()),
});
export const zodListGuidesResponse = zod.array(zodListGuidesResponseItem);

/**
 * Create a new guide tag. Moderator only.
 * @summary Create a tag
 */
export const zodCreateTagBodyNameMin = 0;
export const zodCreateTagBodyNameMax = 64;

export const zodCreateTagBodyCategoryMin = 0;
export const zodCreateTagBodyCategoryMax = 32;

export const zodCreateTagBodyHexColorMin = 0;
export const zodCreateTagBodyHexColorMax = 7;

export const zodCreateTagBody = zod.object({
	name: zod.string().min(zodCreateTagBodyNameMin).max(zodCreateTagBodyNameMax),
	category: zod.string().min(zodCreateTagBodyCategoryMin).max(zodCreateTagBodyCategoryMax),
	hexColor: zod.string().min(zodCreateTagBodyHexColorMin).max(zodCreateTagBodyHexColorMax).nullish(),
});

export const zodCreateTagResponse = zod.object({
	id: zod.number(),
	name: zod.string(),
	category: zod.string(),
	hexColor: zod.string(),
});

/**
 * Deletes a comment.
 * @summary Delete a comment
 */
export const zodDeleteCommentParams = zod.object({
	commentId: zod.number(),
});

/**
 * Soft delete a guide. Only the author or an admin can delete.
 * @summary Delete a guide
 */
export const zodDeleteGuideParams = zod.object({
	id: zod.number(),
});

/**
 * Update the draft version of a guide. Only the author can update their own guide.
 * @summary Update a guide draft
 */
export const zodUpdateGuideParams = zod.object({
	id: zod.number(),
});

export const zodUpdateGuideBody = zod.object({
	title: zod.string(),
	iconSkyblockId: zod.string().nullish(),
	description: zod.string(),
	markdownContent: zod.string(),
	tags: zod.array(zod.string()).nullish(),
	richBlocks: zod
		.object({
			greenhouseLayout: zod
				.object({
					layoutId: zod.number(),
					slots: zod.array(
						zod.object({
							index: zod.number(),
							itemId: zod.string(),
							backgroundTexture: zod.string().nullish(),
						})
					),
				})
				.nullish(),
		})
		.nullish(),
});

/**
 * Delete a guide tag. Moderator only.
 * @summary Delete a tag
 */
export const zodDeleteTagParams = zod.object({
	id: zod.number(),
});

/**
 * Update an existing guide tag. Moderator only.
 * @summary Update a tag
 */
export const zodUpdateTagParams = zod.object({
	id: zod.number(),
});

export const zodUpdateTagBody = zod.object({
	name: zod.string().nullish(),
	category: zod.string().nullish(),
	hexColor: zod.string().nullish(),
});

export const zodUpdateTagResponse = zod.object({
	id: zod.number(),
	name: zod.string(),
	category: zod.string(),
	hexColor: zod.string(),
});

/**
 * Edit comment content. Authors can edit their own comments, admins can edit any.
 * @summary Edit a comment
 */
export const zodEditCommentParams = zod.object({
	commentId: zod.number(),
});

export const zodEditCommentBodyContentMin = 0;
export const zodEditCommentBodyContentMax = 2048;

export const zodEditCommentBody = zod.object({
	content: zod.string().min(zodEditCommentBodyContentMin).max(zodEditCommentBodyContentMax),
});

/**
 * Retrieve a guide by its slug. Use ?draft=true to view draft version (requires author/mod permission).
 * @summary Get a guide
 */
export const zodGetGuideParams = zod.object({
	slug: zod.string(),
});

export const zodGetGuideQueryParams = zod.object({
	draft: zod.coerce.boolean<boolean>(),
});

export const zodGetGuideResponse = zod.object({
	id: zod.number(),
	slug: zod.string(),
	title: zod.string(),
	iconSkyblockId: zod.string().nullish(),
	description: zod.string(),
	content: zod.string(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	createdAt: zod.iso.datetime({}),
	score: zod.number(),
	viewCount: zod.number(),
	tags: zod.array(zod.string()),
	isDraft: zod.coerce.boolean<boolean>(),
	status: zod.string(),
	userVote: zod.number().nullish(),
	isBookmarked: zod.coerce.boolean<boolean>().nullish(),
	rejectionReason: zod.string().nullish(),
});

/**
 * Returns all guides bookmarked by the user. Only the owner can see their bookmarks.
 * @summary Get user's bookmarked guides
 */
export const zodGetUserBookmarksParams = zod.object({
	accountId: zod.number(),
});

export const zodGetUserBookmarksResponseItem = zod.object({
	id: zod.number(),
	slug: zod.string(),
	title: zod.string(),
	description: zod.string(),
	type: zod.string(),
	status: zod.string(),
	score: zod.number(),
	viewCount: zod.number(),
	createdAt: zod.iso.datetime({}),
	updatedAt: zod.iso.datetime({}).nullish(),
});
export const zodGetUserBookmarksResponse = zod.array(zodGetUserBookmarksResponseItem);

/**
 * Returns all guides by a specific user. Shows only published guides for anonymous users. Author sees all their own guides.
 * @summary Get guides by user
 */
export const zodGetUserGuidesParams = zod.object({
	accountId: zod.number(),
});

export const zodGetUserGuidesResponseItem = zod.object({
	id: zod.number(),
	slug: zod.string(),
	title: zod.string(),
	description: zod.string(),
	type: zod.string(),
	status: zod.string(),
	score: zod.number(),
	viewCount: zod.number(),
	createdAt: zod.iso.datetime({}),
	updatedAt: zod.iso.datetime({}).nullish(),
});
export const zodGetUserGuidesResponse = zod.array(zodGetUserGuidesResponseItem);

/**
 * Returns all comments for a specific guide.
 * @summary List comments for a guide
 */
export const zodListCommentsParams = zod.object({
	slug: zod.string(),
});

export const zodListCommentsResponseItem = zod.object({
	id: zod.number(),
	sqid: zod.string(),
	parentId: zod.number().nullish(),
	content: zod.string(),
	draftContent: zod.string().nullish(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	createdAt: zod.iso.datetime({}),
	editedAt: zod.iso.datetime({}).nullish(),
	score: zod.number(),
	liftedElementId: zod.string().nullish(),
	userVote: zod.number().nullish(),
	isPending: zod.coerce.boolean<boolean>(),
	isDeleted: zod.coerce.boolean<boolean>(),
	isEdited: zod.coerce.boolean<boolean>(),
	isEditedByAdmin: zod.coerce.boolean<boolean>(),
	hasPendingEdit: zod.coerce.boolean<boolean>(),
});
export const zodListCommentsResponse = zod.array(zodListCommentsResponseItem);

/**
 * Returns a list of all comments pending approval.
 * @summary List all pending comments
 */
export const zodListPendingCommentsResponseItem = zod.object({
	id: zod.number(),
	sqid: zod.string(),
	parentId: zod.number().nullish(),
	content: zod.string(),
	draftContent: zod.string().nullish(),
	author: zod.object({
		id: zod.string(),
		name: zod.string(),
		avatar: zod.string().nullish(),
		uuid: zod.string().nullish(),
	}),
	createdAt: zod.iso.datetime({}),
	editedAt: zod.iso.datetime({}).nullish(),
	score: zod.number(),
	liftedElementId: zod.string().nullish(),
	userVote: zod.number().nullish(),
	isPending: zod.coerce.boolean<boolean>(),
	isDeleted: zod.coerce.boolean<boolean>(),
	isEdited: zod.coerce.boolean<boolean>(),
	isEditedByAdmin: zod.coerce.boolean<boolean>(),
	hasPendingEdit: zod.coerce.boolean<boolean>(),
});
export const zodListPendingCommentsResponse = zod.array(zodListPendingCommentsResponseItem);

/**
 * Returns all available guide tags.
 * @summary List all tags
 */
export const zodListTagsResponseItem = zod.object({
	id: zod.number(),
	name: zod.string(),
	category: zod.string(),
	hexColor: zod.string(),
});
export const zodListTagsResponse = zod.array(zodListTagsResponseItem);

/**
 * Reject a pending guide submission with an optional reason.
 * @summary Reject a guide
 */
export const zodRejectGuideParams = zod.object({
	guideId: zod.number(),
});

export const zodRejectGuideBody = zod.object({
	reason: zod.string().nullish().describe('Optional reason for rejection to provide feedback to the author.'),
});

/**
 * Submit a draft guide for admin review.
 * @summary Submit guide for approval
 */
export const zodSubmitGuideForApprovalParams = zod.object({
	guideId: zod.number(),
});

/**
 * Revert a published guide back to draft status. Only author or admin can unpublish.
 * @summary Unpublish a guide
 */
export const zodUnpublishGuideParams = zod.object({
	guideId: zod.number(),
});

/**
 * Cast an upvote (+1) or downvote (-1) on a comment.
 * @summary Vote on a comment
 */
export const zodVoteCommentParams = zod.object({
	commentId: zod.number(),
});

export const zodVoteCommentBody = zod.object({
	value: zod.number(),
});

/**
 * Cast an upvote (+1) or downvote (-1) on a guide.
 * @summary Vote on a guide
 */
export const zodVoteGuideParams = zod.object({
	guideId: zod.number(),
});

export const zodVoteGuideBody = zod.object({
	value: zod.number(),
});

/**
 * @summary Modify guild event permissions
 */
export const zodSetEventFeatureParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetEventFeatureQueryEnableDefault = false;
export const zodSetEventFeatureQueryMaxDefault = false;

export const zodSetEventFeatureQueryParams = zod.object({
	enable: zod.coerce.boolean<boolean>().nullish(),
	max: zod.number().nullish(),
});

/**
 * @summary Get public guild events
 */
export const zodGetPublicGuildEventsParams = zod.object({
	discordId: zod.number(),
});

export const zodGetPublicGuildEventsResponseBannerTitleMax = 64;

export const zodGetPublicGuildEventsResponseBannerDescriptionMax = 512;

export const zodGetPublicGuildEventsResponseItem = zod.object({
	id: zod.string().describe('Event id as a string'),
	name: zod.string().describe('Name of the event'),
	type: zod
		.enum(['none', 'farmingWeight', 'collection', 'experience', 'medals', 'pests'])
		.describe('Type of the event'),
	mode: zod.string().nullish().describe('Team mode of the event'),
	description: zod.string().nullish().describe('Event description'),
	rules: zod.string().nullish().describe('Event rules'),
	prizeInfo: zod.string().nullish().describe('Event prize information'),
	banner: zod
		.object({
			title: zod.string().max(zodGetPublicGuildEventsResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPublicGuildEventsResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Image URL for the event banner'),
	startTime: zod.string().nullish().describe('Start time of the event as a string in Unix seconds'),
	joinUntilTime: zod.string().nullish().describe('Join time of the event as a string in Unix seconds'),
	endTime: zod.string().nullish().describe('End time of the event as a string in Unix seconds'),
	dynamicStartTime: zod.coerce.boolean<boolean>().describe('Currently unused'),
	active: zod.coerce.boolean<boolean>().describe('Event status'),
	approved: zod.coerce.boolean<boolean>().describe('Event approval status'),
	maxTeams: zod.number().describe('Max amount of teams allowed in the event, 0 if solo event, -1 if unlimited'),
	maxTeamMembers: zod.number().describe('Max amount of members allowed in a team, 0 if solo event, -1 if unlimited'),
	requiredRole: zod.string().nullish().describe('Discord role id required to participate in the event'),
	blockedRole: zod.string().nullish().describe('Discord role id blocked from participating in the event'),
	guildId: zod.string().nullish().describe('Discord server id as a string'),
	data: zod.unknown().nullish().describe('Data specific to the event'),
});
export const zodGetPublicGuildEventsResponse = zod.array(zodGetPublicGuildEventsResponseItem);

/**
 * @summary Modify guild jacob permissions
 */
export const zodSetJacobFeatureParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetJacobFeatureQueryEnableDefault = true;
export const zodSetJacobFeatureQueryMaxDefault = false;

export const zodSetJacobFeatureQueryParams = zod.object({
	enable: zod.coerce.boolean<boolean>().default(zodSetJacobFeatureQueryEnableDefault),
	max: zod.number().nullish(),
});

/**
 * @summary Lock or unlock a guild
 */
export const zodSetGuildLockedParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetGuildLockedQueryLockedDefault = true;

export const zodSetGuildLockedQueryParams = zod.object({
	locked: zod.coerce
		.boolean<boolean>()
		.default(zodSetGuildLockedQueryLockedDefault)
		.describe("If server subscriptions shouldn't override feature values"),
});

/**
 * @summary Set a guild to public or private
 */
export const zodSetGuildPublicParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetGuildPublicQueryPublicDefault = true;

export const zodSetGuildPublicQueryParams = zod.object({
	public: zod.coerce.boolean<boolean>().default(zodSetGuildPublicQueryPublicDefault),
});

/**
 * @summary Get public guild
 */
export const zodGetPublicGuildParams = zod.object({
	discordId: zod.number(),
});

export const zodGetPublicGuildResponseIconTitleMax = 64;

export const zodGetPublicGuildResponseIconDescriptionMax = 512;

export const zodGetPublicGuildResponseBannerTitleMax = 64;

export const zodGetPublicGuildResponseBannerDescriptionMax = 512;

export const zodGetPublicGuildResponse = zod.object({
	id: zod.string(),
	name: zod.string(),
	icon: zod
		.object({
			title: zod.string().max(zodGetPublicGuildResponseIconTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPublicGuildResponseIconDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	banner: zod
		.object({
			title: zod.string().max(zodGetPublicGuildResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPublicGuildResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	inviteCode: zod.string().nullish(),
	description: zod.string().nullish(),
	memberCount: zod.number(),
	features: zod.object({
		jacobLeaderboardEnabled: zod.coerce.boolean<boolean>(),
		jacobLeaderboard: zod
			.object({
				maxLeaderboards: zod.number(),
				blockedRoles: zod.array(
					zod.object({
						id: zod.string(),
						name: zod.string(),
						position: zod.number(),
						permissions: zod.number(),
					})
				),
				requiredRoles: zod.array(
					zod.object({
						id: zod.string(),
						name: zod.string(),
						position: zod.number(),
						permissions: zod.number(),
					})
				),
				excludedTimespans: zod.array(
					zod.object({
						start: zod.number(),
						end: zod.number(),
						reason: zod.string().nullish(),
					})
				),
				leaderboards: zod.array(
					zod.object({
						id: zod.string(),
						channelId: zod.string().nullish(),
						startCutoff: zod.number(),
						endCutoff: zod.number(),
						title: zod.string().nullish(),
						active: zod.coerce.boolean<boolean>(),
						requiredRole: zod.string().nullish(),
						blockedRole: zod.string().nullish(),
						updateChannelId: zod.string().nullish(),
						updateRoleId: zod.string().nullish(),
						pingForSmallImprovements: zod.coerce.boolean<boolean>(),
						crops: zod.object({
							cactus: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							carrot: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							potato: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							wheat: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							melon: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							pumpkin: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							mushroom: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							cocoaBeans: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							sugarCane: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							netherWart: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							sunflower: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							moonflower: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
							wildRose: zod.array(
								zod.object({
									uuid: zod.string(),
									ign: zod.string(),
									discordId: zod.string(),
									record: zod.object({
										crop: zod.string(),
										timestamp: zod
											.number()
											.describe('Timestamp of the contest in seconds since unix epoch.'),
										collected: zod.number(),
										position: zod.number(),
										participants: zod.number(),
										medal: zod.string().nullish(),
									}),
								})
							),
						}),
					})
				),
			})
			.nullish(),
		eventsEnabled: zod.coerce.boolean<boolean>(),
		eventSettings: zod
			.object({
				maxMonthlyEvents: zod.number(),
				publicEventsEnabled: zod.coerce.boolean<boolean>(),
				createdEvents: zod.array(
					zod.object({
						id: zod.string(),
						createdAt: zod.iso.datetime({}),
					})
				),
			})
			.nullish(),
		contestPingsEnabled: zod.coerce.boolean<boolean>(),
		contestPings: zod
			.object({
				enabled: zod.coerce.boolean<boolean>(),
				guildId: zod.string().nullish(),
				channelId: zod.string().nullish(),
				alwaysPingRole: zod.string().nullish(),
				cropPingRoles: zod
					.object({
						cactus: zod.string().nullish(),
						carrot: zod.string().nullish(),
						potato: zod.string().nullish(),
						wheat: zod.string().nullish(),
						melon: zod.string().nullish(),
						pumpkin: zod.string().nullish(),
						mushroom: zod.string().nullish(),
						cocoaBeans: zod.string().nullish(),
						sugarCane: zod.string().nullish(),
						netherWart: zod.string().nullish(),
						sunflower: zod.string().nullish(),
						moonflower: zod.string().nullish(),
						wildRose: zod.string().nullish(),
					})
					.nullish(),
				delaySeconds: zod.number(),
				disabledReason: zod.string().nullish(),
			})
			.nullish(),
	}),
});

/**
 * @summary Get public guilds
 */
export const zodGetPublicGuildsResponseIconTitleMax = 64;

export const zodGetPublicGuildsResponseIconDescriptionMax = 512;

export const zodGetPublicGuildsResponseBannerTitleMax = 64;

export const zodGetPublicGuildsResponseBannerDescriptionMax = 512;

export const zodGetPublicGuildsResponseItem = zod.object({
	id: zod.string(),
	name: zod.string(),
	icon: zod
		.object({
			title: zod.string().max(zodGetPublicGuildsResponseIconTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPublicGuildsResponseIconDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	banner: zod
		.object({
			title: zod.string().max(zodGetPublicGuildsResponseBannerTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetPublicGuildsResponseBannerDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	inviteCode: zod.string().nullish(),
	memberCount: zod.number(),
});
export const zodGetPublicGuildsResponse = zod.array(zodGetPublicGuildsResponseItem);

/**
 * @summary Delete contest pings for a guild
 */
export const zodDeleteContestPingsParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodDeleteContestPingsQueryParams = zod.object({
	reason: zod.string().nullish(),
});

/**
 * @summary Update contest pings for a guild
 */
export const zodUpdateContestPingsParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateContestPingsBodyDisabledReasonMin = 0;
export const zodUpdateContestPingsBodyDisabledReasonMax = 128;

export const zodUpdateContestPingsBody = zod.object({
	enabled: zod.coerce
		.boolean<boolean>()
		.describe('Indicates whether the contest pings feature is enabled for the guild.'),
	channelId: zod.string().nullish().describe('Channel ID to send contest pings to.'),
	alwaysPingRole: zod.string().nullish().describe('Role ID to ping when a contest starts.'),
	cropPingRoles: zod
		.object({
			cactus: zod.string().nullish(),
			carrot: zod.string().nullish(),
			potato: zod.string().nullish(),
			wheat: zod.string().nullish(),
			melon: zod.string().nullish(),
			pumpkin: zod.string().nullish(),
			mushroom: zod.string().nullish(),
			cocoaBeans: zod.string().nullish(),
			sugarCane: zod.string().nullish(),
			netherWart: zod.string().nullish(),
			sunflower: zod.string().nullish(),
			moonflower: zod.string().nullish(),
			wildRose: zod.string().nullish(),
		})
		.nullish()
		.describe('Individual roles to ping when a contest for a specific crop starts.'),
	delaySeconds: zod.number().describe('Not in use yet. Delay in seconds before sending the ping.'),
	disabledReason: zod
		.string()
		.min(zodUpdateContestPingsBodyDisabledReasonMin)
		.max(zodUpdateContestPingsBodyDisabledReasonMax)
		.nullish()
		.describe('Reason for disabling the feature.'),
});

/**
 * @summary Get guild memberships for the current user
 */
export const zodGetUserGuildsResponseIconTitleMax = 64;

export const zodGetUserGuildsResponseIconDescriptionMax = 512;

export const zodGetUserGuildsResponseItem = zod.object({
	id: zod.string(),
	name: zod.string(),
	icon: zod
		.object({
			title: zod.string().max(zodGetUserGuildsResponseIconTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetUserGuildsResponseIconDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	hasBot: zod.coerce.boolean<boolean>(),
	permissions: zod.string(),
	roles: zod.array(zod.string()),
	admin: zod.coerce.boolean<boolean>().nullish(),
});
export const zodGetUserGuildsResponse = zod.array(zodGetUserGuildsResponseItem);

/**
 * @summary Get a guild membership for the current user
 */
export const zodGetUserGuildParams = zod.object({
	discordId: zod.number(),
});

export const zodGetUserGuildResponseGuildFeaturesJacobLeaderboardLeaderboardsItemTitleMax = 64;

export const zodGetUserGuildResponseGuildIconTitleMax = 64;

export const zodGetUserGuildResponseGuildIconDescriptionMax = 512;

export const zodGetUserGuildResponseGuildBannerTitleMax = 64;

export const zodGetUserGuildResponseGuildBannerDescriptionMax = 512;

export const zodGetUserGuildResponseMemberIconTitleMax = 64;

export const zodGetUserGuildResponseMemberIconDescriptionMax = 512;

export const zodGetUserGuildResponse = zod.object({
	id: zod.string(),
	permissions: zod.string(),
	guild: zod
		.object({
			id: zod.string(),
			name: zod.string(),
			public: zod.coerce.boolean<boolean>(),
			features: zod.object({
				locked: zod.coerce.boolean<boolean>(),
				jacobLeaderboardEnabled: zod.coerce.boolean<boolean>(),
				jacobLeaderboard: zod
					.object({
						maxLeaderboards: zod.number(),
						blockedRoles: zod.array(
							zod.object({
								id: zod.string(),
								name: zod.string(),
								position: zod.number(),
								permissions: zod.number(),
							})
						),
						blockedUsers: zod.array(zod.number()),
						requiredRoles: zod.array(
							zod.object({
								id: zod.string(),
								name: zod.string(),
								position: zod.number(),
								permissions: zod.number(),
							})
						),
						excludedParticipations: zod.array(zod.string()),
						excludedTimespans: zod.array(
							zod.object({
								start: zod.number(),
								end: zod.number(),
								reason: zod.string().nullish(),
							})
						),
						leaderboards: zod.array(
							zod.object({
								id: zod.string(),
								channelId: zod.string().nullish(),
								startCutoff: zod.number(),
								endCutoff: zod.number(),
								title: zod
									.string()
									.max(zodGetUserGuildResponseGuildFeaturesJacobLeaderboardLeaderboardsItemTitleMax)
									.nullish(),
								active: zod.coerce.boolean<boolean>(),
								requiredRole: zod.string().nullish(),
								blockedRole: zod.string().nullish(),
								updateChannelId: zod.string().nullish(),
								updateRoleId: zod.string().nullish(),
								pingForSmallImprovements: zod.coerce.boolean<boolean>(),
								crops: zod.object({
									cactus: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									carrot: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									potato: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									wheat: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									melon: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									pumpkin: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									mushroom: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									cocoaBeans: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									sugarCane: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									netherWart: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									sunflower: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									moonflower: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
									wildRose: zod.array(
										zod.object({
											uuid: zod.string(),
											ign: zod.string(),
											discordId: zod.string(),
											record: zod.object({
												crop: zod.string(),
												timestamp: zod
													.number()
													.describe('Timestamp of the contest in seconds since unix epoch.'),
												collected: zod.number(),
												position: zod.number(),
												participants: zod.number(),
												medal: zod.string().nullish(),
											}),
										})
									),
								}),
							})
						),
					})
					.nullish(),
				verifiedRoleEnabled: zod.coerce.boolean<boolean>(),
				verifiedRole: zod
					.object({
						enabled: zod.coerce.boolean<boolean>(),
						autoRoles: zod.array(
							zod.object({
								roleId: zod.string().nullish(),
								requiredWeight: zod.number(),
							})
						),
					})
					.nullish(),
				eventsEnabled: zod.coerce.boolean<boolean>(),
				eventSettings: zod
					.object({
						maxMonthlyEvents: zod.number(),
						publicEventsEnabled: zod.coerce.boolean<boolean>(),
						createdEvents: zod.array(
							zod.object({
								id: zod.string(),
								createdAt: zod.iso.datetime({}),
							})
						),
					})
					.nullish(),
				contestPingsEnabled: zod.coerce.boolean<boolean>(),
				contestPings: zod
					.object({
						enabled: zod.coerce.boolean<boolean>(),
						channelId: zod.string().nullish(),
						alwaysPingRole: zod.string().nullish(),
						cropPingRoles: zod
							.object({
								cactus: zod.string().nullish(),
								carrot: zod.string().nullish(),
								potato: zod.string().nullish(),
								wheat: zod.string().nullish(),
								melon: zod.string().nullish(),
								pumpkin: zod.string().nullish(),
								mushroom: zod.string().nullish(),
								cocoaBeans: zod.string().nullish(),
								sugarCane: zod.string().nullish(),
								netherWart: zod.string().nullish(),
								sunflower: zod.string().nullish(),
								moonflower: zod.string().nullish(),
								wildRose: zod.string().nullish(),
							})
							.nullish(),
						delaySeconds: zod.number(),
						disabledReason: zod.string().nullish(),
					})
					.nullish(),
			}),
			icon: zod
				.object({
					title: zod.string().max(zodGetUserGuildResponseGuildIconTitleMax).nullish().describe('Image title'),
					description: zod
						.string()
						.max(zodGetUserGuildResponseGuildIconDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish(),
			banner: zod
				.object({
					title: zod
						.string()
						.max(zodGetUserGuildResponseGuildBannerTitleMax)
						.nullish()
						.describe('Image title'),
					description: zod
						.string()
						.max(zodGetUserGuildResponseGuildBannerDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish(),
			inviteCode: zod.string().nullish(),
			description: zod.string().nullish(),
			adminRole: zod.string().nullish(),
			botPermissions: zod.string().nullish(),
			botPermissionsNew: zod.string(),
			discordFeatures: zod.array(zod.string()),
			memberCount: zod.number(),
			channels: zod.array(
				zod.object({
					id: zod.string(),
					name: zod.string(),
					type: zod.number(),
					position: zod.number(),
				})
			),
			roles: zod.array(
				zod.object({
					id: zod.string(),
					name: zod.string(),
					position: zod.number(),
				})
			),
		})
		.nullish(),
	member: zod
		.object({
			id: zod.string(),
			name: zod.string(),
			icon: zod
				.object({
					title: zod
						.string()
						.max(zodGetUserGuildResponseMemberIconTitleMax)
						.nullish()
						.describe('Image title'),
					description: zod
						.string()
						.max(zodGetUserGuildResponseMemberIconDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish(),
			hasBot: zod.coerce.boolean<boolean>(),
			permissions: zod.string(),
			roles: zod.array(zod.string()),
			admin: zod.coerce.boolean<boolean>().nullish(),
		})
		.nullish(),
});

/**
 * @summary Create a Jacob leaderboard
 */
export const zodCreateGuildJacobLeaderboardParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodCreateGuildJacobLeaderboardBodyTitleMin = 0;
export const zodCreateGuildJacobLeaderboardBodyTitleMax = 64;

export const zodCreateGuildJacobLeaderboardBody = zod.object({
	title: zod.string().min(zodCreateGuildJacobLeaderboardBodyTitleMin).max(zodCreateGuildJacobLeaderboardBodyTitleMax),
	channelId: zod.string().nullish(),
	startCutoff: zod.number().nullish(),
	endCutoff: zod.number().nullish(),
	active: zod.coerce.boolean<boolean>().nullish(),
	requiredRole: zod.string().nullish(),
	blockedRole: zod.string().nullish(),
	updateChannelId: zod.string().nullish(),
	updateRoleId: zod.string().nullish(),
	pingForSmallImprovements: zod.coerce.boolean<boolean>().nullish(),
});

/**
 * @summary Delete a Jacob leaderboard
 */
export const zodDeleteGuildJacobLeaderboardParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	leaderboardId: zod.string(),
});

/**
 * @summary Update a Jacob leaderboard
 */
export const zodUpdateGuildJacobLeaderboardParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	leaderboardId: zod.string(),
});

export const zodUpdateGuildJacobLeaderboardBodyTitleMax = 64;

export const zodUpdateGuildJacobLeaderboardBody = zod.object({
	title: zod.string().max(zodUpdateGuildJacobLeaderboardBodyTitleMax).nullish(),
	channelId: zod.string().nullish(),
	startCutoff: zod.number().nullish(),
	endCutoff: zod.number().nullish(),
	active: zod.coerce.boolean<boolean>().nullish(),
	requiredRole: zod.string().nullish(),
	blockedRole: zod.string().nullish(),
	updateChannelId: zod.string().nullish(),
	updateRoleId: zod.string().nullish(),
	pingForSmallImprovements: zod.coerce.boolean<boolean>().nullish(),
});

/**
 * @summary Get Jacob leaderboards for a guild
 */
export const zodGetGuildJacobParams = zod.object({
	discordId: zod.number(),
});

export const zodGetGuildJacobResponseLeaderboardsItemTitleMax = 64;

export const zodGetGuildJacobResponse = zod.object({
	maxLeaderboards: zod.number(),
	blockedRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	blockedUsers: zod.array(zod.number()),
	requiredRoles: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			position: zod.number(),
			permissions: zod.number(),
		})
	),
	excludedParticipations: zod.array(zod.string()),
	excludedTimespans: zod.array(
		zod.object({
			start: zod.number(),
			end: zod.number(),
			reason: zod.string().nullish(),
		})
	),
	leaderboards: zod.array(
		zod.object({
			id: zod.string(),
			channelId: zod.string().nullish(),
			startCutoff: zod.number(),
			endCutoff: zod.number(),
			title: zod.string().max(zodGetGuildJacobResponseLeaderboardsItemTitleMax).nullish(),
			active: zod.coerce.boolean<boolean>(),
			requiredRole: zod.string().nullish(),
			blockedRole: zod.string().nullish(),
			updateChannelId: zod.string().nullish(),
			updateRoleId: zod.string().nullish(),
			pingForSmallImprovements: zod.coerce.boolean<boolean>(),
			crops: zod.object({
				cactus: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				carrot: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				potato: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wheat: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				melon: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				pumpkin: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				mushroom: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				cocoaBeans: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sugarCane: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				netherWart: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				sunflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				moonflower: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
				wildRose: zod.array(
					zod.object({
						uuid: zod.string(),
						ign: zod.string(),
						discordId: zod.string(),
						record: zod.object({
							crop: zod.string(),
							timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
							collected: zod.number(),
							position: zod.number(),
							participants: zod.number(),
							medal: zod.string().nullish(),
						}),
					})
				),
			}),
		})
	),
});

/**
 * @summary Update Jacob leaderboards for a guild
 */
export const zodUpdateGuildJacobFeatureParams = zod.object({
	discordId: zod.number(),
});

export const zodUpdateGuildJacobFeatureQueryParams = zod.object({
	reason: zod.string().nullish(),
});

export const zodUpdateGuildJacobFeatureBodyLeaderboardsItemTitleMax = 64;

export const zodUpdateGuildJacobFeatureBody = zod.object({
	blockedRoles: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				position: zod.number(),
				permissions: zod.number(),
			})
		)
		.describe("Blocked roles from participating in the guild's Jacob Leaderboards"),
	blockedUsers: zod
		.array(zod.number())
		.describe("Blocked users from participating in the guild's Jacob Leaderboards"),
	requiredRoles: zod
		.array(
			zod.object({
				id: zod.string(),
				name: zod.string(),
				position: zod.number(),
				permissions: zod.number(),
			})
		)
		.describe("Required roles to participate in the guild's Jacob Leaderboards"),
	excludedParticipations: zod
		.array(zod.string())
		.describe("Excluded participations from the guild's Jacob Leaderboards"),
	excludedTimespans: zod
		.array(
			zod.object({
				start: zod.number(),
				end: zod.number(),
				reason: zod.string().nullish(),
			})
		)
		.describe("Excluded timespans from the guild's Jacob Leaderboards"),
	leaderboards: zod
		.array(
			zod.object({
				id: zod.string(),
				channelId: zod.string().nullish(),
				startCutoff: zod.number(),
				endCutoff: zod.number(),
				title: zod.string().max(zodUpdateGuildJacobFeatureBodyLeaderboardsItemTitleMax).nullish(),
				active: zod.coerce.boolean<boolean>(),
				requiredRole: zod.string().nullish(),
				blockedRole: zod.string().nullish(),
				updateChannelId: zod.string().nullish(),
				updateRoleId: zod.string().nullish(),
				pingForSmallImprovements: zod.coerce.boolean<boolean>(),
				crops: zod.object({
					cactus: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					carrot: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					potato: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					wheat: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					melon: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					pumpkin: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					mushroom: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					cocoaBeans: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					sugarCane: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					netherWart: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					sunflower: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					moonflower: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
					wildRose: zod.array(
						zod.object({
							uuid: zod.string(),
							ign: zod.string(),
							discordId: zod.string(),
							record: zod.object({
								crop: zod.string(),
								timestamp: zod
									.number()
									.describe('Timestamp of the contest in seconds since unix epoch.'),
								collected: zod.number(),
								position: zod.number(),
								participants: zod.number(),
								medal: zod.string().nullish(),
							}),
						})
					),
				}),
			})
		)
		.describe("Leaderboards for the guild's Jacob Leaderboards"),
});

/**
 * @summary Send a Jacob leaderboard to Discord
 */
export const zodSendGuildJacobFeatureParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	leaderboardId: zod.string(),
});

/**
 * This fetches the latest data from Discord for the specified guild
 * @summary Request Guild Refresh
 */
export const zodRequestGuildRefreshParams = zod.object({
	discordId: zod.number(),
});

/**
 * @summary Set an admin role for a guild
 */
export const zodSetAdminRoleParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetAdminRoleBody = zod.string();

/**
 * @summary Set invite code for a guild
 */
export const zodSetInviteParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodSetInviteBody = zod.string();

/**
 * @summary Refresh Guild Purchases
 */
export const zodUpdateGuildPurchasesParams = zod.object({
	discordId: zod.number(),
});

/**
 * @summary Get Hypixel Guild
 */
export const zodGetHypixelGuildParams = zod.object({
	guildId: zod.string(),
});

export const zodGetHypixelGuildResponse = zod.object({
	guild: zod.object({
		id: zod.string(),
		name: zod.string(),
		createdAt: zod.number(),
		description: zod.string(),
		preferredGames: zod.array(zod.string()).nullish(),
		publiclyListed: zod.coerce.boolean<boolean>(),
		public: zod.coerce.boolean<boolean>(),
		exp: zod.number(),
		tag: zod.string().nullish(),
		tagColor: zod.string().nullish(),
		gameExp: zod.record(zod.string(), zod.number()),
		ranks: zod.array(
			zod.object({
				name: zod.string(),
				tag: zod.string().nullish(),
				default: zod.coerce.boolean<boolean>(),
				created: zod.number(),
				priority: zod.number(),
			})
		),
		members: zod.array(
			zod.object({
				playerUuid: zod.string(),
				name: zod.string(),
				formattedName: zod.string(),
				rank: zod.string().nullish(),
				joinedAt: zod.number(),
				questParticipation: zod.number(),
				active: zod.coerce.boolean<boolean>(),
				expHistory: zod.record(zod.string(), zod.number()),
			})
		),
		memberCount: zod.number(),
		lastUpdated: zod.number(),
		stats: zod.array(
			zod.object({
				recordedAt: zod.iso.datetime({}),
				memberCount: zod.number(),
				hypixelLevel: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				skyblockExperience: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				skillLevel: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				slayerExperience: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				catacombsExperience: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				farmingWeight: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				networth: zod.object({
					total: zod.number(),
					average: zod.number(),
				}),
				collections: zod.record(zod.string(), zod.number()),
				skills: zod.record(zod.string(), zod.number()),
			})
		),
	}),
});

/**
 * @summary Get Hypixel Guild Members Leaderboard
 */
export const zodGetHypixelGuildMembersLeaderboardParams = zod.object({
	guildId: zod.string().describe('Guild id to fetch members for (discord/hypixel guild id)'),
	leaderboard: zod.string().describe('Id of leaderboard'),
});

export const zodGetHypixelGuildMembersLeaderboardQueryRemovedDefault = 0;

export const zodGetHypixelGuildMembersLeaderboardQueryParams = zod.object({
	interval: zod.string().nullish().describe('Time interval key of a monthly leaderboard. Format: yyyy-MM'),
	mode: zod
		.string()
		.nullish()
		.describe(
			'Game mode to filter leaderboard by. Leave empty to get all modes.\nOptions: \"ironman\", \"island\", \"classic\"'
		),
	removed: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.nullish()
		.describe(
			'Removed filter to get leaderboard entries that have been removed from the leaderboard.\nDefault is profiles that have not been removed/wiped.\n0 = Not Removed\n1 = Removed\n2 = All'
		),
});

export const zodGetHypixelGuildMembersLeaderboardResponseEntriesItemMetaPrefixMax = 16;

export const zodGetHypixelGuildMembersLeaderboardResponseEntriesItemMetaSuffixMax = 16;

export const zodGetHypixelGuildMembersLeaderboardResponse = zod.object({
	id: zod.string(),
	title: zod.string(),
	shortTitle: zod.string().nullish(),
	itemId: zod.string().nullish().describe('Item Id if this is a collection leaderboard'),
	interval: zod.string().nullish(),
	firstInterval: zod.string().nullish(),
	limit: zod.number(),
	offset: zod.number(),
	maxEntries: zod.number(),
	minimumScore: zod.number().describe('The minimum score required to be on the leaderboard'),
	startsAt: zod.number(),
	endsAt: zod.number(),
	profile: zod.coerce.boolean<boolean>(),
	entries: zod.array(
		zod.object({
			ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
			profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
			uuid: zod.string().describe('Uuid of the player or profile'),
			amount: zod.number().describe('Score of the entry'),
			removed: zod.coerce.boolean<boolean>(),
			initialAmount: zod.number().describe('Initial score of the entry'),
			mode: zod
				.string()
				.nullish()
				.describe('Game mode of the entry. Classic profiles are considered default/null.'),
			members: zod
				.array(
					zod.object({
						ign: zod.string(),
						uuid: zod.string(),
						xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
						removed: zod.coerce.boolean<boolean>(),
					})
				)
				.nullish(),
			meta: zod
				.object({
					prefix: zod
						.string()
						.max(zodGetHypixelGuildMembersLeaderboardResponseEntriesItemMetaPrefixMax)
						.nullish(),
					suffix: zod
						.string()
						.max(zodGetHypixelGuildMembersLeaderboardResponseEntriesItemMetaSuffixMax)
						.nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Metadata of the entry'),
		})
	),
	guildId: zod.string(),
});

/**
 * Get the rank of a Hypixel guild on a specific leaderboard
 * @summary Get Hypixel Guild Rank
 */
export const zodGetHypixelGuildRankParams = zod.object({
	guildId: zod.string(),
});

export const zodGetHypixelGuildRankQueryParams = zod.object({
	sortBy: zod
		.enum([
			'memberCount',
			'skyblockExperience',
			'skyblockExperienceAverage',
			'skillLevel',
			'skillLevelAverage',
			'hypixelLevelAverage',
			'slayerExperience',
			'catacombsExperience',
			'farmingWeight',
			'networth',
			'networthAverage',
		])
		.nullish(),
	collection: zod.string().nullish(),
	skill: zod.string().nullish(),
});

export const zodGetHypixelGuildRankResponse = zod.object({
	guildId: zod.string(),
	guildName: zod.string(),
	rank: zod.number(),
	amount: zod.number(),
});

/**
 * @summary Get Hypixel Guilds
 */
export const zodGetHypixelGuildsQueryParams = zod.object({
	sortBy: zod
		.enum([
			'memberCount',
			'skyblockExperience',
			'skyblockExperienceAverage',
			'skillLevel',
			'skillLevelAverage',
			'hypixelLevelAverage',
			'slayerExperience',
			'catacombsExperience',
			'farmingWeight',
			'networth',
			'networthAverage',
		])
		.nullish(),
	collection: zod.string().nullish(),
	skill: zod.string().nullish(),
	descending: zod.coerce.boolean<boolean>().nullish(),
	page: zod.number().nullish(),
	pageSize: zod.number().nullish(),
});

export const zodGetHypixelGuildsResponse = zod.object({
	totalGuilds: zod.number(),
	guilds: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			createdAt: zod.number(),
			tag: zod.string().nullish(),
			tagColor: zod.string().nullish(),
			memberCount: zod.number(),
			lastUpdated: zod.number(),
			stats: zod
				.object({
					recordedAt: zod.iso.datetime({}),
					memberCount: zod.number(),
					hypixelLevel: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					skyblockExperience: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					skillLevel: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					slayerExperience: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					catacombsExperience: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					farmingWeight: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
					networth: zod.object({
						total: zod.number(),
						average: zod.number(),
					}),
				})
				.nullish(),
			amount: zod.number().describe('Populated when sorting guilds by a specific collection or skill'),
		})
	),
});

/**
 * Fuzzy search across Hypixel guild names
 * @summary Search Hypixel Guilds
 */
export const zodSearchHypixelGuildsQueryParams = zod.object({
	query: zod.string(),
	limit: zod.number(),
});

export const zodSearchHypixelGuildsResponse = zod.object({
	results: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			memberCount: zod.number(),
			tag: zod.string().nullish(),
			tagColor: zod.string().nullish(),
		})
	),
});

/**
 * @summary Get Leaderboard
 */
export const zodGetLeaderboardParams = zod.object({
	leaderboard: zod.string().describe('Id of leaderboard'),
});

export const zodGetLeaderboardQueryOffsetDefault = 0;
export const zodGetLeaderboardQueryLimitDefault = 20;
export const zodGetLeaderboardQueryRemovedDefault = 0;

export const zodGetLeaderboardQueryParams = zod.object({
	offset: zod.number().nullish(),
	limit: zod.number().default(zodGetLeaderboardQueryLimitDefault),
	interval: zod.string().nullish().describe('Time interval key of a monthly leaderboard. Format: yyyy-MM'),
	mode: zod
		.string()
		.nullish()
		.describe(
			'Game mode to filter leaderboard by. Leave empty to get all modes.\nOptions: \"ironman\", \"island\", \"classic\"'
		),
	removed: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.nullish()
		.describe(
			'Removed filter to get leaderboard entries that have been removed from the leaderboard.\nDefault is profiles that have not been removed/wiped.\n0 = Not Removed\n1 = Removed\n2 = All'
		),
});

export const zodGetLeaderboardResponseEntriesItemMetaPrefixMax = 16;

export const zodGetLeaderboardResponseEntriesItemMetaSuffixMax = 16;

export const zodGetLeaderboardResponse = zod.object({
	id: zod.string(),
	title: zod.string(),
	shortTitle: zod.string().nullish(),
	itemId: zod.string().nullish().describe('Item Id if this is a collection leaderboard'),
	interval: zod.string().nullish(),
	firstInterval: zod.string().nullish(),
	limit: zod.number(),
	offset: zod.number(),
	maxEntries: zod.number(),
	minimumScore: zod.number().describe('The minimum score required to be on the leaderboard'),
	startsAt: zod.number(),
	endsAt: zod.number(),
	profile: zod.coerce.boolean<boolean>(),
	entries: zod.array(
		zod.object({
			ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
			profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
			uuid: zod.string().describe('Uuid of the player or profile'),
			amount: zod.number().describe('Score of the entry'),
			removed: zod.coerce.boolean<boolean>(),
			initialAmount: zod.number().describe('Initial score of the entry'),
			mode: zod
				.string()
				.nullish()
				.describe('Game mode of the entry. Classic profiles are considered default/null.'),
			members: zod
				.array(
					zod.object({
						ign: zod.string(),
						uuid: zod.string(),
						xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
						removed: zod.coerce.boolean<boolean>(),
					})
				)
				.nullish(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetLeaderboardResponseEntriesItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetLeaderboardResponseEntriesItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Metadata of the entry'),
		})
	),
});

/**
 * @summary Get Leaderboards
 */
export const zodGetLeaderboardsResponse = zod.object({
	leaderboards: zod.record(
		zod.string(),
		zod.object({
			title: zod.string().describe('Leaderboard title'),
			short: zod.string().nullish().describe('Leaderboard short title'),
			itemId: zod.string().nullish().describe('Item Id if a collection based leaderboard'),
			category: zod.string().describe('Leaderboard category'),
			profile: zod.coerce.boolean<boolean>().describe('If true, the leaderboard is profile based'),
			minimumScore: zod.number().describe('Minimum score required to be on the leaderboard'),
			intervalType: zod.enum(['Current', 'Weekly', 'Monthly']).describe('Interval type of the leaderboard'),
			scoreDataType: zod.enum(['Double', 'Long', 'Decimal']).describe('Score data type of the leaderboard'),
		})
	),
});

/**
 * @summary Get multiple leaderboard ranks for a player
 */
export const zodGetMultiplePlayerRanksParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetMultiplePlayerRanksQueryIncludeUpcomingDefault = false;
export const zodGetMultiplePlayerRanksQueryUpcomingDefault = 0;
export const zodGetMultiplePlayerRanksQueryPreviousDefault = 0;
export const zodGetMultiplePlayerRanksQueryRemovedDefault = 0;

export const zodGetMultiplePlayerRanksQueryParams = zod.object({
	leaderboards: zod.string().describe('Ids of leaderboards (comma-separated)'),
	includeUpcoming: zod.coerce.boolean<boolean>().nullish().describe('Include upcoming players'),
	upcoming: zod.number().nullish().describe('Amount of upcoming players to include (max 10).'),
	previous: zod.number().nullish().describe('Amount of passed players to include (max 3).'),
	atRank: zod.number().nullish().describe('Start at a specified rank for upcoming players'),
	interval: zod.string().nullish().describe('Time interval key of a monthly leaderboard. Format: yyyy-MM'),
	mode: zod
		.string()
		.nullish()
		.describe(
			'Game mode to filter leaderboard by. Leave empty to get all modes.\nOptions: \"ironman\", \"island\", \"classic\"'
		),
	removed: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.nullish()
		.describe(
			'Removed filter to get leaderboard entries that have been removed from the leaderboard.\nDefault is profiles that have not been removed/wiped.\n0 = Not Removed\n1 = Removed\n2 = All'
		),
});

export const zodGetMultiplePlayerRanksResponseUpcomingPlayersItemMetaPrefixMax = 16;

export const zodGetMultiplePlayerRanksResponseUpcomingPlayersItemMetaSuffixMax = 16;

export const zodGetMultiplePlayerRanksResponsePreviousItemMetaPrefixMax = 16;

export const zodGetMultiplePlayerRanksResponsePreviousItemMetaSuffixMax = 16;

export const zodGetMultiplePlayerRanksResponse = zod.record(
	zod.string(),
	zod.object({
		rank: zod.number().describe('Current rank of the player (-1 if not on leaderboard)'),
		amount: zod.number().describe('Current score of the player (0 if not on leaderboard)'),
		initialAmount: zod
			.number()
			.describe('The starting amount of the leaderboard entry for interval based leaderboards'),
		minAmount: zod
			.number()
			.describe(
				'The minimum amount required to be on the leaderboard. If this is a time based leaderboard,\nthis score is instead required on the normal leaderboard before the player can be on the\ntime based leaderboard'
			),
		upcomingRank: zod.number().describe('The starting rank of the returned upcoming players list'),
		upcomingPlayers: zod
			.array(
				zod.object({
					ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
					profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
					uuid: zod.string().describe('Uuid of the player or profile'),
					amount: zod.number().describe('Score of the entry'),
					removed: zod.coerce.boolean<boolean>(),
					initialAmount: zod.number().describe('Initial score of the entry'),
					mode: zod
						.string()
						.nullish()
						.describe('Game mode of the entry. Classic profiles are considered default/null.'),
					members: zod
						.array(
							zod.object({
								ign: zod.string(),
								uuid: zod.string(),
								xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
								removed: zod.coerce.boolean<boolean>(),
							})
						)
						.nullish(),
					meta: zod
						.object({
							prefix: zod
								.string()
								.max(zodGetMultiplePlayerRanksResponseUpcomingPlayersItemMetaPrefixMax)
								.nullish(),
							suffix: zod
								.string()
								.max(zodGetMultiplePlayerRanksResponseUpcomingPlayersItemMetaSuffixMax)
								.nullish(),
							leaderboard: zod
								.object({
									styleId: zod.number().nullish(),
									backgroundColor: zod.string().nullish(),
									borderColor: zod.string().nullish(),
									textColor: zod.string().nullish(),
									rankColor: zod.string().nullish(),
									backgroundImage: zod.string().nullish(),
									overlayImage: zod.string().nullish(),
								})
								.nullish(),
						})
						.nullish()
						.describe('Metadata of the entry'),
				})
			)
			.nullish()
			.describe('List of upcoming players'),
		previous: zod
			.array(
				zod.object({
					ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
					profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
					uuid: zod.string().describe('Uuid of the player or profile'),
					amount: zod.number().describe('Score of the entry'),
					removed: zod.coerce.boolean<boolean>(),
					initialAmount: zod.number().describe('Initial score of the entry'),
					mode: zod
						.string()
						.nullish()
						.describe('Game mode of the entry. Classic profiles are considered default/null.'),
					members: zod
						.array(
							zod.object({
								ign: zod.string(),
								uuid: zod.string(),
								xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
								removed: zod.coerce.boolean<boolean>(),
							})
						)
						.nullish(),
					meta: zod
						.object({
							prefix: zod
								.string()
								.max(zodGetMultiplePlayerRanksResponsePreviousItemMetaPrefixMax)
								.nullish(),
							suffix: zod
								.string()
								.max(zodGetMultiplePlayerRanksResponsePreviousItemMetaSuffixMax)
								.nullish(),
							leaderboard: zod
								.object({
									styleId: zod.number().nullish(),
									backgroundColor: zod.string().nullish(),
									borderColor: zod.string().nullish(),
									textColor: zod.string().nullish(),
									rankColor: zod.string().nullish(),
									backgroundImage: zod.string().nullish(),
									overlayImage: zod.string().nullish(),
								})
								.nullish(),
						})
						.nullish()
						.describe('Metadata of the entry'),
				})
			)
			.nullish()
			.describe('List of previous players'),
	})
);

/**
 * @summary Get a Player's Leaderboard Ranks
 */
export const zodGetPlayerLeaderboardRanksParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetPlayerLeaderboardRanksQueryParams = zod.object({
	max: zod
		.number()
		.nullish()
		.describe("Maximum rank number to return. Used if you don't want ranks higher than a certain number."),
});

export const zodGetPlayerLeaderboardRanksResponse = zod.object({
	ranks: zod.record(
		zod.string(),
		zod.object({
			title: zod.string(),
			short: zod.string().nullish(),
			slug: zod.string(),
			profile: zod.coerce.boolean<boolean>().nullish(),
			rank: zod.number(),
			intervalIdentifier: zod.string().nullish(),
			amount: zod.number(),
			initialAmount: zod.number(),
			type: zod.enum(['Double', 'Long', 'Decimal']),
		})
	),
});

/**
 * @summary Get a Player's Leaderboard Rank
 */
export const zodGetPlayerRank1Params = zod.object({
	leaderboard: zod.string().describe('Id of leaderboard'),
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetPlayerRank1QueryIncludeUpcomingDefault = false;
export const zodGetPlayerRank1QueryUpcomingDefault = 0;
export const zodGetPlayerRank1QueryPreviousDefault = 0;
export const zodGetPlayerRank1QueryRemovedDefault = 0;

export const zodGetPlayerRank1QueryParams = zod.object({
	includeUpcoming: zod.coerce.boolean<boolean>().nullish().describe('Include upcoming players'),
	upcoming: zod
		.number()
		.nullish()
		.describe('Amount of upcoming players to include (max 100). Only works with new leaderboard backend'),
	previous: zod.number().nullish().describe('Amount of passed players to include (max 3).'),
	atRank: zod.number().nullish().describe('Start at a specified rank for upcoming players'),
	interval: zod.string().nullish().describe('Time interval key of a monthly leaderboard. Format: yyyy-MM'),
	mode: zod
		.string()
		.nullish()
		.describe(
			'Game mode to filter leaderboard by. Leave empty to get all modes.\nOptions: \"ironman\", \"island\", \"classic\"'
		),
	removed: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.nullish()
		.describe(
			'Removed filter to get leaderboard entries that have been removed from the leaderboard.\nDefault is profiles that have not been removed/wiped.\n0 = Not Removed\n1 = Removed\n2 = All'
		),
});

export const zodGetPlayerRank1ResponseUpcomingPlayersItemMetaPrefixMax = 16;

export const zodGetPlayerRank1ResponseUpcomingPlayersItemMetaSuffixMax = 16;

export const zodGetPlayerRank1ResponsePreviousItemMetaPrefixMax = 16;

export const zodGetPlayerRank1ResponsePreviousItemMetaSuffixMax = 16;

export const zodGetPlayerRank1Response = zod.object({
	rank: zod.number().describe('Current rank of the player (-1 if not on leaderboard)'),
	amount: zod.number().describe('Current score of the player (0 if not on leaderboard)'),
	initialAmount: zod
		.number()
		.describe('The starting amount of the leaderboard entry for interval based leaderboards'),
	minAmount: zod
		.number()
		.describe(
			'The minimum amount required to be on the leaderboard. If this is a time based leaderboard,\nthis score is instead required on the normal leaderboard before the player can be on the\ntime based leaderboard'
		),
	upcomingRank: zod.number().describe('The starting rank of the returned upcoming players list'),
	upcomingPlayers: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetPlayerRank1ResponseUpcomingPlayersItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetPlayerRank1ResponseUpcomingPlayersItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of upcoming players'),
	previous: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetPlayerRank1ResponsePreviousItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetPlayerRank1ResponsePreviousItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of previous players'),
});

/**
 * @summary Get a Player's Leaderboard Rank
 */
export const zodGetPlayerRank2Params = zod.object({
	leaderboard: zod.string(),
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetPlayerRank2QueryIncludeUpcomingDefault = false;
export const zodGetPlayerRank2QueryUpcomingDefault = 0;
export const zodGetPlayerRank2QueryPreviousDefault = 0;
export const zodGetPlayerRank2QueryRemovedDefault = 0;

export const zodGetPlayerRank2QueryParams = zod.object({
	includeUpcoming: zod.coerce.boolean<boolean>().nullish(),
	upcoming: zod.number().nullish(),
	previous: zod.number().nullish(),
	atRank: zod.number().nullish(),
	interval: zod.string().nullish(),
	mode: zod.string().nullish(),
	removed: zod.union([zod.literal(0), zod.literal(1), zod.literal(2)]).nullish(),
});

export const zodGetPlayerRank2ResponseUpcomingPlayersItemMetaPrefixMax = 16;

export const zodGetPlayerRank2ResponseUpcomingPlayersItemMetaSuffixMax = 16;

export const zodGetPlayerRank2ResponsePreviousItemMetaPrefixMax = 16;

export const zodGetPlayerRank2ResponsePreviousItemMetaSuffixMax = 16;

export const zodGetPlayerRank2Response = zod.object({
	rank: zod.number().describe('Current rank of the player (-1 if not on leaderboard)'),
	amount: zod.number().describe('Current score of the player (0 if not on leaderboard)'),
	initialAmount: zod
		.number()
		.describe('The starting amount of the leaderboard entry for interval based leaderboards'),
	minAmount: zod
		.number()
		.describe(
			'The minimum amount required to be on the leaderboard. If this is a time based leaderboard,\nthis score is instead required on the normal leaderboard before the player can be on the\ntime based leaderboard'
		),
	upcomingRank: zod.number().describe('The starting rank of the returned upcoming players list'),
	upcomingPlayers: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetPlayerRank2ResponseUpcomingPlayersItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetPlayerRank2ResponseUpcomingPlayersItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of upcoming players'),
	previous: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetPlayerRank2ResponsePreviousItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetPlayerRank2ResponsePreviousItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of previous players'),
});

/**
 * @deprecated
 * @summary Get a Player's Leaderboard Ranks
 */
export const zodGetPlayerRanksParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetPlayerRanksResponse = zod.object({
	misc: zod.record(zod.string(), zod.number()),
	skills: zod.record(zod.string(), zod.number()),
	collections: zod.record(zod.string(), zod.number()),
	pests: zod.record(zod.string(), zod.number()),
	profile: zod.record(zod.string(), zod.number()),
});

/**
 * @summary Get a Profiles's Leaderboard Rank
 */
export const zodGetProfileRank1Params = zod.object({
	leaderboard: zod.string().describe('Id of leaderboard'),
	profileUuid: zod.string(),
});

export const zodGetProfileRank1QueryIncludeUpcomingDefault = false;
export const zodGetProfileRank1QueryUpcomingDefault = 0;
export const zodGetProfileRank1QueryPreviousDefault = 0;
export const zodGetProfileRank1QueryRemovedDefault = 0;

export const zodGetProfileRank1QueryParams = zod.object({
	includeUpcoming: zod.coerce.boolean<boolean>().nullish().describe('Include upcoming players'),
	upcoming: zod.number().nullish().describe('Amount of upcoming players to include (max 100).'),
	previous: zod.number().nullish().describe('Amount of passed players to include (max 3).'),
	atRank: zod.number().nullish().describe('Start at a specified rank for upcoming players'),
	interval: zod.string().nullish().describe('Time interval key of a monthly leaderboard. Format: yyyy-MM'),
	mode: zod
		.string()
		.nullish()
		.describe(
			'Game mode to filter leaderboard by. Leave empty to get all modes.\nOptions: \"ironman\", \"island\", \"classic\"'
		),
	removed: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.nullish()
		.describe(
			'Removed filter to get leaderboard entries that have been removed from the leaderboard.\nDefault is profiles that have not been removed/wiped.\n0 = Not Removed\n1 = Removed\n2 = All'
		),
});

export const zodGetProfileRank1ResponseUpcomingPlayersItemMetaPrefixMax = 16;

export const zodGetProfileRank1ResponseUpcomingPlayersItemMetaSuffixMax = 16;

export const zodGetProfileRank1ResponsePreviousItemMetaPrefixMax = 16;

export const zodGetProfileRank1ResponsePreviousItemMetaSuffixMax = 16;

export const zodGetProfileRank1Response = zod.object({
	rank: zod.number().describe('Current rank of the player (-1 if not on leaderboard)'),
	amount: zod.number().describe('Current score of the player (0 if not on leaderboard)'),
	initialAmount: zod
		.number()
		.describe('The starting amount of the leaderboard entry for interval based leaderboards'),
	minAmount: zod
		.number()
		.describe(
			'The minimum amount required to be on the leaderboard. If this is a time based leaderboard,\nthis score is instead required on the normal leaderboard before the player can be on the\ntime based leaderboard'
		),
	upcomingRank: zod.number().describe('The starting rank of the returned upcoming players list'),
	upcomingPlayers: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetProfileRank1ResponseUpcomingPlayersItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetProfileRank1ResponseUpcomingPlayersItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of upcoming players'),
	previous: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetProfileRank1ResponsePreviousItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetProfileRank1ResponsePreviousItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of previous players'),
});

/**
 * @summary Get a Profiles's Leaderboard Rank
 */
export const zodGetProfileRank2Params = zod.object({
	leaderboard: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetProfileRank2QueryIncludeUpcomingDefault = false;
export const zodGetProfileRank2QueryUpcomingDefault = 0;
export const zodGetProfileRank2QueryPreviousDefault = 0;
export const zodGetProfileRank2QueryRemovedDefault = 0;

export const zodGetProfileRank2QueryParams = zod.object({
	includeUpcoming: zod.coerce.boolean<boolean>().nullish(),
	upcoming: zod.number().nullish(),
	previous: zod.number().nullish(),
	atRank: zod.number().nullish(),
	interval: zod.string().nullish(),
	mode: zod.string().nullish(),
	removed: zod.union([zod.literal(0), zod.literal(1), zod.literal(2)]).nullish(),
});

export const zodGetProfileRank2ResponseUpcomingPlayersItemMetaPrefixMax = 16;

export const zodGetProfileRank2ResponseUpcomingPlayersItemMetaSuffixMax = 16;

export const zodGetProfileRank2ResponsePreviousItemMetaPrefixMax = 16;

export const zodGetProfileRank2ResponsePreviousItemMetaSuffixMax = 16;

export const zodGetProfileRank2Response = zod.object({
	rank: zod.number().describe('Current rank of the player (-1 if not on leaderboard)'),
	amount: zod.number().describe('Current score of the player (0 if not on leaderboard)'),
	initialAmount: zod
		.number()
		.describe('The starting amount of the leaderboard entry for interval based leaderboards'),
	minAmount: zod
		.number()
		.describe(
			'The minimum amount required to be on the leaderboard. If this is a time based leaderboard,\nthis score is instead required on the normal leaderboard before the player can be on the\ntime based leaderboard'
		),
	upcomingRank: zod.number().describe('The starting rank of the returned upcoming players list'),
	upcomingPlayers: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetProfileRank2ResponseUpcomingPlayersItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetProfileRank2ResponseUpcomingPlayersItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of upcoming players'),
	previous: zod
		.array(
			zod.object({
				ign: zod.string().nullish().describe("Player's IGN if player leaderboard"),
				profile: zod.string().nullish().describe("Player's profile name if player leaderboard"),
				uuid: zod.string().describe('Uuid of the player or profile'),
				amount: zod.number().describe('Score of the entry'),
				removed: zod.coerce.boolean<boolean>(),
				initialAmount: zod.number().describe('Initial score of the entry'),
				mode: zod
					.string()
					.nullish()
					.describe('Game mode of the entry. Classic profiles are considered default/null.'),
				members: zod
					.array(
						zod.object({
							ign: zod.string(),
							uuid: zod.string(),
							xp: zod.number().describe('Skyblock xp of the player (used for sorting)'),
							removed: zod.coerce.boolean<boolean>(),
						})
					)
					.nullish(),
				meta: zod
					.object({
						prefix: zod.string().max(zodGetProfileRank2ResponsePreviousItemMetaPrefixMax).nullish(),
						suffix: zod.string().max(zodGetProfileRank2ResponsePreviousItemMetaSuffixMax).nullish(),
						leaderboard: zod
							.object({
								styleId: zod.number().nullish(),
								backgroundColor: zod.string().nullish(),
								borderColor: zod.string().nullish(),
								textColor: zod.string().nullish(),
								rankColor: zod.string().nullish(),
								backgroundImage: zod.string().nullish(),
								overlayImage: zod.string().nullish(),
							})
							.nullish(),
					})
					.nullish()
					.describe('Metadata of the entry'),
			})
		)
		.nullish()
		.describe('List of previous players'),
});

/**
 * @summary Get all entitlements for a user or guild
 */
export const zodGetEntitlementsParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodGetEntitlementsQueryParams = zod.object({
	target: zod.union([zod.literal(0), zod.literal(1), zod.literal(2)]).nullish(),
});

export const zodGetEntitlementsResponseProductWeightStylesItemNameMax = 64;

export const zodGetEntitlementsResponseProductThumbnailTitleMax = 64;

export const zodGetEntitlementsResponseProductThumbnailDescriptionMax = 512;

export const zodGetEntitlementsResponseProductImagesItemTitleMax = 64;

export const zodGetEntitlementsResponseProductImagesItemDescriptionMax = 512;

export const zodGetEntitlementsResponseItem = zod.object({
	id: zod.string().describe('Entitlement ID'),
	type: zod
		.union([
			zod.literal(1),
			zod.literal(2),
			zod.literal(3),
			zod.literal(4),
			zod.literal(5),
			zod.literal(6),
			zod.literal(7),
			zod.literal(8),
		])
		.describe('Type of entitlement'),
	target: zod
		.union([zod.literal(0), zod.literal(1), zod.literal(2)])
		.describe('Target of entitlement.\n0 = None\n1 = User\n2 = Guild'),
	productId: zod.string().describe('SKU ID of the product'),
	product: zod
		.object({
			id: zod.string().describe('Product ID'),
			name: zod.string().describe('Product name'),
			slug: zod.string().describe('Slug of the product'),
			price: zod.number().describe('Product price'),
			description: zod.string().nullish().describe('Product description'),
			available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
			type: zod
				.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
				.describe('Type of product'),
			features: zod
				.object({
					badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
					weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
					weightStyleOverride: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe("Ability to override other's weight styles."),
					embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
					hideShopPromotions: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to hide shop promotions.'),
					moreInfoDefault: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Show \"More Info\" on weight command by default.'),
					customEmoji: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to have custom name emoji for the user.'),
					maxMonthlyEvents: zod
						.number()
						.nullish()
						.describe('Maximum number of events that can be created in a month. (For guilds)'),
					maxJacobLeaderboards: zod
						.number()
						.nullish()
						.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
					flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
				})
				.describe('Features of the product'),
			weightStyles: zod
				.array(
					zod.object({
						id: zod.number(),
						name: zod.string().max(zodGetEntitlementsResponseProductWeightStylesItemNameMax).nullish(),
					})
				)
				.describe('Unlocked weight styles'),
			thumbnail: zod
				.object({
					title: zod
						.string()
						.max(zodGetEntitlementsResponseProductThumbnailTitleMax)
						.nullish()
						.describe('Image title'),
					description: zod
						.string()
						.max(zodGetEntitlementsResponseProductThumbnailDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish()
				.describe('Product thumbnail'),
			images: zod
				.array(
					zod.object({
						title: zod
							.string()
							.max(zodGetEntitlementsResponseProductImagesItemTitleMax)
							.nullish()
							.describe('Image title'),
						description: zod
							.string()
							.max(zodGetEntitlementsResponseProductImagesItemDescriptionMax)
							.nullish()
							.describe('Image description'),
						order: zod.number().nullish().describe('Image ordering number'),
						width: zod.number().describe('The original width of the image.'),
						height: zod.number().describe('The original height of the image.'),
						sources: zod
							.record(
								zod.string(),
								zod.object({
									url: zod
										.string()
										.describe('The fully-qualified public URL for this image variant.'),
									width: zod.number().describe('The width of this image variant in pixels.'),
								})
							)
							.describe(
								'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
							),
						url: zod.string().describe('Lowest quality image URL'),
					})
				)
				.describe('Product Images'),
			flags: zod.number().describe('Discord flags'),
			isSubscription: zod.coerce.boolean<boolean>(),
			isGuildSubscription: zod.coerce.boolean<boolean>(),
			isUserSubscription: zod.coerce.boolean<boolean>(),
		})
		.describe('Product details'),
	deleted: zod.coerce.boolean<boolean>(),
	consumed: zod.coerce.boolean<boolean>().nullish().describe('Consumed status of the entitlement if applicable'),
	startDate: zod.iso.datetime({}).nullish().describe('Start date of the entitlement'),
	endDate: zod.iso.datetime({}).nullish().describe('End date of the entitlement'),
});
export const zodGetEntitlementsResponse = zod.array(zodGetEntitlementsResponseItem);

/**
 * This passes along a request to Discord to grant a test entitlement to a user or guild, which only works on subscription products.
 * @summary Grant a test entitlement to a user or guild
 */
export const zodGrantTestEntitlementParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	productId: zod.number(),
});

export const zodGrantTestEntitlementQueryParams = zod.object({
	target: zod.union([zod.literal(0), zod.literal(1), zod.literal(2)]).nullish(),
});

/**
 * This passes along a request to Discord to remove a test entitlement from a user or guild.
 * @summary Remove a test entitlement from a user or guild
 */
export const zodRemoveTestEntitlementParams = zod.object({
	discordId: zod.number(),
	productId: zod.number(),
});

export const zodRemoveTestEntitlementQueryParams = zod.object({
	target: zod.union([zod.literal(0), zod.literal(1), zod.literal(2)]).nullish(),
});

/**
 * @summary Delete a notification
 */
export const zodDeleteNotificationParams = zod.object({
	id: zod.string(),
});

/**
 * Retrieve paginated notifications for the authenticated user.
 * @summary Get user notifications
 */
export const zodGetNotificationsQueryParams = zod.object({
	offset: zod.number(),
	limit: zod.number(),
	unreadOnly: zod.coerce.boolean<boolean>(),
});

export const zodGetNotificationsResponse = zod.object({
	notifications: zod.array(
		zod.object({
			id: zod.number(),
			type: zod.enum([
				'system',
				'guideApproved',
				'guideEditApproved',
				'guideRejected',
				'guideDeleted',
				'commentApproved',
				'commentEditApproved',
				'commentRejected',
				'newComment',
				'newReply',
				'shopPurchase',
			]),
			title: zod.string(),
			message: zod.string().nullish(),
			link: zod.string().nullish(),
			isRead: zod.coerce.boolean<boolean>(),
			createdAt: zod.iso.datetime({}),
			data: zod.record(zod.string(), zod.unknown()).nullish(),
		})
	),
	unreadCount: zod.number(),
});

/**
 * @summary Mark notification as read
 */
export const zodMarkNotificationReadParams = zod.object({
	id: zod.string(),
});

/**
 * @summary Get Linked Accounts
 */
export const zodGetLinkedAccountsParams = zod.object({
	discordId: zod.number(),
});

export const zodGetLinkedAccountsResponse = zod.object({
	selectedUuid: zod.string().nullish(),
	players: zod.array(
		zod.object({
			uuid: zod.string(),
			displayname: zod.string().nullish(),
			firstLogin: zod.number(),
			lastLogin: zod.number(),
			lastLogout: zod.number(),
			karma: zod.number(),
			networkExp: zod.number(),
			guildMember: zod
				.object({
					guild: zod
						.object({
							id: zod.string(),
							name: zod.string(),
							createdAt: zod.number(),
							tag: zod.string().nullish(),
							tagColor: zod.string().nullish(),
							memberCount: zod.number(),
							lastUpdated: zod.number(),
							stats: zod
								.object({
									recordedAt: zod.iso.datetime({}),
									memberCount: zod.number(),
									hypixelLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skyblockExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									skillLevel: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									slayerExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									catacombsExperience: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									farmingWeight: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
									networth: zod.object({
										total: zod.number(),
										average: zod.number(),
									}),
								})
								.nullish(),
							amount: zod
								.number()
								.describe('Populated when sorting guilds by a specific collection or skill'),
						})
						.nullish(),
					rank: zod.string().nullish(),
					joinedAt: zod.number(),
					questParticipation: zod.number(),
					active: zod.coerce.boolean<boolean>(),
					expHistory: zod.record(zod.string(), zod.number()),
				})
				.nullish(),
			rewardHighScore: zod.number(),
			rewardScore: zod.number(),
			rewardStreak: zod.number(),
			totalDailyRewards: zod.number(),
			totalRewards: zod.number(),
			prefix: zod.string().nullish(),
			rank: zod.string().nullish(),
			packageRank: zod.string().nullish(),
			newPackageRank: zod.string().nullish(),
			rankPlusColor: zod.string().nullish(),
			monthlyPackageRank: zod.string().nullish(),
			mostRecentMonthlyPackageRank: zod.string().nullish(),
			monthlyRankColor: zod.string().nullish(),
			socialMedia: zod
				.object({
					discord: zod.string().nullish(),
					hypixel: zod.string().nullish(),
					youtube: zod.string().nullish(),
				})
				.nullish(),
		})
	),
});

/**
 * @summary Get Player Data
 */
export const zodGetPlayerDataParams = zod.object({
	player: zod.string(),
});

export const zodGetPlayerDataResponse = zod.object({
	uuid: zod.string(),
	displayname: zod.string().nullish(),
	firstLogin: zod.number(),
	lastLogin: zod.number(),
	lastLogout: zod.number(),
	karma: zod.number(),
	networkExp: zod.number(),
	guildMember: zod
		.object({
			guild: zod
				.object({
					id: zod.string(),
					name: zod.string(),
					createdAt: zod.number(),
					tag: zod.string().nullish(),
					tagColor: zod.string().nullish(),
					memberCount: zod.number(),
					lastUpdated: zod.number(),
					stats: zod
						.object({
							recordedAt: zod.iso.datetime({}),
							memberCount: zod.number(),
							hypixelLevel: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							skyblockExperience: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							skillLevel: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							slayerExperience: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							catacombsExperience: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							farmingWeight: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
							networth: zod.object({
								total: zod.number(),
								average: zod.number(),
							}),
						})
						.nullish(),
					amount: zod.number().describe('Populated when sorting guilds by a specific collection or skill'),
				})
				.nullish(),
			rank: zod.string().nullish(),
			joinedAt: zod.number(),
			questParticipation: zod.number(),
			active: zod.coerce.boolean<boolean>(),
			expHistory: zod.record(zod.string(), zod.number()),
		})
		.nullish(),
	rewardHighScore: zod.number(),
	rewardScore: zod.number(),
	rewardStreak: zod.number(),
	totalDailyRewards: zod.number(),
	totalRewards: zod.number(),
	prefix: zod.string().nullish(),
	rank: zod.string().nullish(),
	packageRank: zod.string().nullish(),
	newPackageRank: zod.string().nullish(),
	rankPlusColor: zod.string().nullish(),
	monthlyPackageRank: zod.string().nullish(),
	mostRecentMonthlyPackageRank: zod.string().nullish(),
	monthlyRankColor: zod.string().nullish(),
	socialMedia: zod
		.object({
			discord: zod.string().nullish(),
			hypixel: zod.string().nullish(),
			youtube: zod.string().nullish(),
		})
		.nullish(),
});

/**
 * @summary Get All Profile Details
 */
export const zodGetAllProfileDetailsParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetAllProfileDetailsResponseMembersItemMetaPrefixMax = 16;

export const zodGetAllProfileDetailsResponseMembersItemMetaSuffixMax = 16;

export const zodGetAllProfileDetailsResponseItem = zod.object({
	profileId: zod.string(),
	profileName: zod.string(),
	gameMode: zod.string(),
	selected: zod.coerce.boolean<boolean>(),
	bankBalance: zod.number(),
	deleted: zod.coerce.boolean<boolean>(),
	members: zod.array(
		zod.object({
			uuid: zod.string(),
			username: zod.string(),
			profileName: zod.string().nullish(),
			active: zod.coerce.boolean<boolean>(),
			farmingWeight: zod.number(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetAllProfileDetailsResponseMembersItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetAllProfileDetailsResponseMembersItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish(),
		})
	),
});
export const zodGetAllProfileDetailsResponse = zod.array(zodGetAllProfileDetailsResponseItem);

/**
 * @summary Get Profile Member
 */
export const zodGetProfileParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetProfileResponseMetaPrefixMax = 16;

export const zodGetProfileResponseMetaSuffixMax = 16;

export const zodGetProfileResponseInventoriesItemNameMax = 64;

export const zodGetProfileResponse = zod.object({
	profileId: zod.string(),
	playerUuid: zod.string(),
	profileName: zod.string(),
	api: zod.object({
		inventories: zod.coerce.boolean<boolean>(),
		collections: zod.coerce.boolean<boolean>(),
		skills: zod.coerce.boolean<boolean>(),
		vault: zod.coerce.boolean<boolean>(),
		museum: zod.coerce.boolean<boolean>(),
	}),
	skyblockXp: zod.number(),
	socialXp: zod.number(),
	purse: zod.number(),
	bankBalance: zod.number(),
	personalBank: zod.number(),
	networth: zod.object({
		normal: zod.number(),
		liquid: zod.number(),
		functional: zod.number(),
		liquidFunctional: zod.number(),
	}),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetProfileResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetProfileResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish(),
	collections: zod.record(zod.string(), zod.number()),
	collectionTiers: zod.record(zod.string(), zod.number()),
	craftedMinions: zod.record(zod.string(), zod.number()),
	sacks: zod.record(zod.string(), zod.number()),
	pets: zod.array(
		zod.object({
			uuid: zod.string().nullish(),
			type: zod.string(),
			exp: zod.number(),
			active: zod.coerce.boolean<boolean>(),
			tier: zod.string().nullish(),
			heldItem: zod.string().nullish(),
			candyUsed: zod.number(),
			skin: zod.string().nullish(),
			level: zod.number(),
		})
	),
	unparsed: zod.object({
		copper: zod.number(),
		consumed: zod.record(zod.string(), zod.number()),
		exportedCrops: zod.record(zod.string(), zod.coerce.boolean<boolean>()).nullish(),
		dnaMilestone: zod.number(),
		levelCaps: zod.record(zod.string(), zod.number()),
		perks: zod.record(zod.string(), zod.number()).nullish(),
		tempStatBuffs: zod
			.array(
				zod.object({
					stat: zod.number(),
					key: zod.string().nullish(),
					amount: zod.number(),
					expire_at: zod.number(),
				})
			)
			.nullish(),
		accessoryBagSettings: zod.unknown().nullish(),
		bestiary: zod.unknown().nullish(),
		dungeons: zod
			.object({
				dungeon_types: zod
					.object({
						catacombs: zod.object({
							experience: zod.number(),
							highest_tier_completed: zod.number(),
							tier_completions: zod.record(zod.string(), zod.number()),
							times_played: zod.record(zod.string(), zod.number()),
							best_score: zod.record(zod.string(), zod.number()),
							mobs_killed: zod.record(zod.string(), zod.number()),
							most_mobs_killed: zod.record(zod.string(), zod.number()),
							watcher_kills: zod.record(zod.string(), zod.number()),
							most_healing: zod.record(zod.string(), zod.number()),
							fastest_time: zod.record(zod.string(), zod.number()),
							fastest_time_s: zod.record(zod.string(), zod.number()),
							fastest_time_s_plus: zod.record(zod.string(), zod.number()),
							most_damage_tank: zod.record(zod.string(), zod.number()),
							most_damage_mage: zod.record(zod.string(), zod.number()),
							most_damage_healer: zod.record(zod.string(), zod.number()),
							most_damage_archer: zod.record(zod.string(), zod.number()),
							milestone_completions: zod.record(zod.string(), zod.number()),
						}),
						master_catacombs: zod.object({
							experience: zod.number(),
							highest_tier_completed: zod.number(),
							tier_completions: zod.record(zod.string(), zod.number()),
							times_played: zod.record(zod.string(), zod.number()),
							best_score: zod.record(zod.string(), zod.number()),
							mobs_killed: zod.record(zod.string(), zod.number()),
							most_mobs_killed: zod.record(zod.string(), zod.number()),
							watcher_kills: zod.record(zod.string(), zod.number()),
							most_healing: zod.record(zod.string(), zod.number()),
							fastest_time: zod.record(zod.string(), zod.number()),
							fastest_time_s: zod.record(zod.string(), zod.number()),
							fastest_time_s_plus: zod.record(zod.string(), zod.number()),
							most_damage_tank: zod.record(zod.string(), zod.number()),
							most_damage_mage: zod.record(zod.string(), zod.number()),
							most_damage_healer: zod.record(zod.string(), zod.number()),
							most_damage_archer: zod.record(zod.string(), zod.number()),
							milestone_completions: zod.record(zod.string(), zod.number()),
						}),
					})
					.nullish(),
				player_classes: zod
					.object({
						healer: zod.object({
							experience: zod.number(),
						}),
						mage: zod.object({
							experience: zod.number(),
						}),
						berserk: zod.object({
							experience: zod.number(),
						}),
						archer: zod.object({
							experience: zod.number(),
						}),
						tank: zod.object({
							experience: zod.number(),
						}),
					})
					.nullish(),
				secrets: zod.number(),
			})
			.nullish(),
	}),
	jacob: zod.object({
		medals: zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
		}),
		earnedMedals: zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
			platinum: zod.number(),
			diamond: zod.number(),
		}),
		perks: zod.object({
			doubleDrops: zod.number(),
			levelCap: zod.number(),
			personalBests: zod.coerce.boolean<boolean>(),
		}),
		stats: zod.object({
			brackets: zod.record(
				zod.string(),
				zod.union([
					zod.literal(0),
					zod.literal(1),
					zod.literal(2),
					zod.literal(3),
					zod.literal(4),
					zod.literal(5),
					zod.literal(-1),
				])
			),
			personalBests: zod.record(zod.string(), zod.number()),
			crops: zod.record(
				zod.string(),
				zod.object({
					participations: zod.number(),
					firstPlaceScores: zod.number(),
					personalBestTimestamp: zod.number().nullish(),
					medals: zod.object({
						bronze: zod.number(),
						silver: zod.number(),
						gold: zod.number(),
						platinum: zod.number(),
						diamond: zod.number(),
					}),
				})
			),
		}),
		participations: zod.number(),
		firstPlaceScores: zod.number(),
		contests: zod.array(
			zod.object({
				crop: zod.string(),
				timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
				collected: zod.number(),
				position: zod.number(),
				participants: zod.number(),
				medal: zod.string().nullish(),
			})
		),
	}),
	farmingWeight: zod.object({
		totalWeight: zod.number(),
		crops: zod.record(zod.string(), zod.number()).nullish(),
		cropWeight: zod.record(zod.string(), zod.number()),
		bonusWeight: zod.record(zod.string(), zod.number()),
		uncountedCrops: zod.record(zod.string(), zod.number()),
		pests: zod.object({
			beetle: zod.number(),
			cricket: zod.number(),
			fly: zod.number(),
			locust: zod.number(),
			mite: zod.number(),
			mosquito: zod.number(),
			moth: zod.number(),
			rat: zod.number(),
			slug: zod.number(),
			earthworm: zod.number(),
			mouse: zod.number(),
			dragonfly: zod.number(),
			firefly: zod.number(),
			mantis: zod.number(),
		}),
		inventory: zod
			.object({
				armor: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				tools: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				equipment: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				accessories: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
			})
			.nullish(),
		lastUpdated: zod.number(),
	}),
	garden: zod
		.object({
			profileId: zod.string().describe('Profile ID'),
			experience: zod.number().describe('Garden experience'),
			completedVisitors: zod.number().describe('Total completed visitors'),
			uniqueVisitors: zod.number().describe('Unique visitors unlocked'),
			crops: zod
				.object({
					cactus: zod.string().nullish(),
					carrot: zod.string().nullish(),
					potato: zod.string().nullish(),
					wheat: zod.string().nullish(),
					melon: zod.string().nullish(),
					pumpkin: zod.string().nullish(),
					mushroom: zod.string().nullish(),
					cocoaBeans: zod.string().nullish(),
					sugarCane: zod.string().nullish(),
					netherWart: zod.string().nullish(),
					sunflower: zod.string().nullish(),
					moonflower: zod.string().nullish(),
					wildRose: zod.string().nullish(),
				})
				.describe('Crops counted towards milestones'),
			cropUpgrades: zod
				.object({
					cactus: zod.number(),
					carrot: zod.number(),
					potato: zod.number(),
					wheat: zod.number(),
					melon: zod.number(),
					pumpkin: zod.number(),
					mushroom: zod.number(),
					cocoaBeans: zod.number(),
					sugarCane: zod.number(),
					netherWart: zod.number(),
					sunflower: zod.number(),
					moonflower: zod.number(),
					wildRose: zod.number(),
				})
				.describe('Crop upgrades'),
			plots: zod.array(zod.string()).describe('List of unlocked plots'),
			composter: zod
				.object({
					organic_matter: zod.number(),
					fuel_units: zod.number(),
					compost_units: zod.number(),
					compost_items: zod.number(),
					conversion_ticks: zod.number(),
					last_save: zod.number(),
					upgrades: zod.object({
						speed: zod.number(),
						multi_drop: zod.number(),
						fuel_cap: zod.number(),
						organic_matter_cap: zod.number(),
						cost_reduction: zod.number(),
					}),
					lastSave: zod.number().describe('Last save time in unix seconds'),
				})
				.describe('Composter data'),
			visitors: zod
				.record(
					zod.string(),
					zod.object({
						visits: zod.number(),
						accepted: zod.number(),
					})
				)
				.describe('Visitor data'),
			lastSave: zod.string().describe('Last save time in unix seconds'),
		})
		.nullish(),
	skills: zod.object({
		farming: zod.number(),
		mining: zod.number(),
		combat: zod.number(),
		foraging: zod.number(),
		fishing: zod.number(),
		enchanting: zod.number(),
		alchemy: zod.number(),
		carpentry: zod.number(),
		runecrafting: zod.number(),
		taming: zod.number(),
		social: zod.number(),
	}),
	chocolateFactory: zod.object({
		chocolate: zod.number(),
		totalChocolate: zod.number(),
		chocolateSincePrestige: zod.number(),
		chocolateSpent: zod.number(),
		prestige: zod.number(),
		lastViewed: zod.number(),
		uniqueRabbits: zod.object({
			common: zod.number(),
			uncommon: zod.number(),
			rare: zod.number(),
			epic: zod.number(),
			legendary: zod.number(),
			mythic: zod.number(),
			divine: zod.number(),
		}),
		totalRabbits: zod.object({
			common: zod.number(),
			uncommon: zod.number(),
			rare: zod.number(),
			epic: zod.number(),
			legendary: zod.number(),
			mythic: zod.number(),
			divine: zod.number(),
		}),
		unlockedZorro: zod.coerce.boolean<boolean>(),
		refinedTrufflesConsumed: zod.number(),
		cocoaFortuneUpgrades: zod.number(),
	}),
	events: zod.array(
		zod.object({
			eventId: zod.string(),
			eventName: zod.string(),
			teamId: zod.string().nullish(),
			status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
			rank: zod.number().describe('Currently not populated'),
			score: zod.string().nullish(),
		})
	),
	inventories: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string().max(zodGetProfileResponseInventoriesItemNameMax),
			metadata: zod.record(zod.string(), zod.string()).nullish(),
		})
	),
	isSelected: zod.coerce.boolean<boolean>(),
	wasRemoved: zod.coerce.boolean<boolean>(),
	lastUpdated: zod.number(),
	lastDataChanged: zod.number(),
});

/**
 * @summary Get Specific Profile Member Auctions
 */
export const zodGetProfileAuctionsParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetProfileAuctionsResponse = zod.object({
	ended: zod
		.array(
			zod.object({
				auctionId: zod.string(),
				sellerUuid: zod.string(),
				sellerProfileUuid: zod.string(),
				seller: zod
					.object({
						id: zod.string(),
						name: zod.string(),
						formattedName: zod.string(),
					})
					.nullish(),
				buyerUuid: zod.string().nullish(),
				buyerProfileUuid: zod.string().nullish(),
				buyer: zod
					.object({
						id: zod.string(),
						name: zod.string(),
						formattedName: zod.string(),
					})
					.nullish(),
				start: zod.number(),
				end: zod.number(),
				soldAt: zod.number(),
				price: zod.number(),
				count: zod.number(),
				bin: zod.coerce.boolean<boolean>(),
				skyblockId: zod.string().nullish(),
				variantKey: zod.string(),
				itemUuid: zod.string().nullish(),
				item: zod
					.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
					.nullish(),
				lastUpdatedAt: zod.iso.datetime({}),
				startingBid: zod.number(),
				highestBid: zod.number().nullish(),
			})
		)
		.describe('Ended auctions'),
});

/**
 * @summary Get Profile Details
 */
export const zodGetProfileDetailsParams = zod.object({
	profileUuid: zod.string(),
});

export const zodGetProfileDetailsResponseMembersItemMetaPrefixMax = 16;

export const zodGetProfileDetailsResponseMembersItemMetaSuffixMax = 16;

export const zodGetProfileDetailsResponse = zod.object({
	profileId: zod.string(),
	profileName: zod.string(),
	gameMode: zod.string(),
	selected: zod.coerce.boolean<boolean>(),
	bankBalance: zod.number(),
	deleted: zod.coerce.boolean<boolean>(),
	members: zod.array(
		zod.object({
			uuid: zod.string(),
			username: zod.string(),
			profileName: zod.string().nullish(),
			active: zod.coerce.boolean<boolean>(),
			farmingWeight: zod.number(),
			meta: zod
				.object({
					prefix: zod.string().max(zodGetProfileDetailsResponseMembersItemMetaPrefixMax).nullish(),
					suffix: zod.string().max(zodGetProfileDetailsResponseMembersItemMetaSuffixMax).nullish(),
					leaderboard: zod
						.object({
							styleId: zod.number().nullish(),
							backgroundColor: zod.string().nullish(),
							borderColor: zod.string().nullish(),
							textColor: zod.string().nullish(),
							rankColor: zod.string().nullish(),
							backgroundImage: zod.string().nullish(),
							overlayImage: zod.string().nullish(),
						})
						.nullish(),
				})
				.nullish(),
		})
	),
});

/**
 * @summary Get Specific Profile Member Inventory
 */
export const zodGetProfileInventoryParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
	inventory: zod.string().describe('Inventory ID'),
});

export const zodGetProfileInventoryResponseNameMax = 64;

export const zodGetProfileInventoryResponse = zod.object({
	id: zod.string(),
	name: zod.string().max(zodGetProfileInventoryResponseNameMax),
	items: zod
		.record(
			zod.string(),
			zod
				.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
				.nullable()
		)
		.describe('Dictionary of slot to item mapping, null if the slot is empty'),
	metadata: zod.record(zod.string(), zod.string()).nullish(),
});

/**
 * @summary Get names of a player's profiles
 */
export const zodGetProfileNamesParams = zod.object({
	player: zod.string(),
});

export const zodGetProfileNamesResponseItem = zod.object({
	id: zod.string(),
	name: zod.string(),
	selected: zod.coerce.boolean<boolean>(),
});
export const zodGetProfileNamesResponse = zod.array(zodGetProfileNamesResponseItem);

/**
 * @summary Get Member Networth
 */
export const zodGetProfileNetworthParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetProfileNetworthResponse = zod.object({
	networth: zod.number(),
	liquidNetworth: zod.number(),
	functionalNetworth: zod.number(),
	liquidFunctionalNetworth: zod.number(),
	purse: zod.number(),
	bank: zod.number(),
	personalBank: zod.number(),
	categories: zod.record(
		zod.string(),
		zod.object({
			total: zod.number(),
			liquidTotal: zod.number(),
			functionalTotal: zod.number(),
			liquidFunctionalTotal: zod.number(),
			items: zod.array(
				zod.object({
					item: zod
						.object({
							skyblockId: zod.string().nullish(),
							name: zod.string().nullish(),
							slot: zod.string().nullish(),
							count: zod.number(),
							damage: zod.number(),
							uuid: zod.string().nullish(),
						})
						.nullish(),
					basePrice: zod.number(),
					price: zod.number(),
					networth: zod.number(),
					calculation: zod
						.array(
							zod.object({
								id: zod.string(),
								type: zod.string(),
								value: zod.number(),
								count: zod.number(),
							})
						)
						.nullish(),
					soulbound: zod.coerce.boolean<boolean>(),
					cosmetic: zod.coerce.boolean<boolean>(),
					liquidNetworth: zod.number(),
					functionalNetworth: zod.number(),
					liquidFunctionalNetworth: zod.number(),
					cosmeticValue: zod.number(),
					illiquidValue: zod.number(),
				})
			),
		})
	),
});

/**
 * @summary Get Profile Member
 */
export const zodGetSelectedProfileParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetSelectedProfileResponseMetaPrefixMax = 16;

export const zodGetSelectedProfileResponseMetaSuffixMax = 16;

export const zodGetSelectedProfileResponseInventoriesItemNameMax = 64;

export const zodGetSelectedProfileResponse = zod.object({
	profileId: zod.string(),
	playerUuid: zod.string(),
	profileName: zod.string(),
	api: zod.object({
		inventories: zod.coerce.boolean<boolean>(),
		collections: zod.coerce.boolean<boolean>(),
		skills: zod.coerce.boolean<boolean>(),
		vault: zod.coerce.boolean<boolean>(),
		museum: zod.coerce.boolean<boolean>(),
	}),
	skyblockXp: zod.number(),
	socialXp: zod.number(),
	purse: zod.number(),
	bankBalance: zod.number(),
	personalBank: zod.number(),
	networth: zod.object({
		normal: zod.number(),
		liquid: zod.number(),
		functional: zod.number(),
		liquidFunctional: zod.number(),
	}),
	meta: zod
		.object({
			prefix: zod.string().max(zodGetSelectedProfileResponseMetaPrefixMax).nullish(),
			suffix: zod.string().max(zodGetSelectedProfileResponseMetaSuffixMax).nullish(),
			leaderboard: zod
				.object({
					styleId: zod.number().nullish(),
					backgroundColor: zod.string().nullish(),
					borderColor: zod.string().nullish(),
					textColor: zod.string().nullish(),
					rankColor: zod.string().nullish(),
					backgroundImage: zod.string().nullish(),
					overlayImage: zod.string().nullish(),
				})
				.nullish(),
		})
		.nullish(),
	collections: zod.record(zod.string(), zod.number()),
	collectionTiers: zod.record(zod.string(), zod.number()),
	craftedMinions: zod.record(zod.string(), zod.number()),
	sacks: zod.record(zod.string(), zod.number()),
	pets: zod.array(
		zod.object({
			uuid: zod.string().nullish(),
			type: zod.string(),
			exp: zod.number(),
			active: zod.coerce.boolean<boolean>(),
			tier: zod.string().nullish(),
			heldItem: zod.string().nullish(),
			candyUsed: zod.number(),
			skin: zod.string().nullish(),
			level: zod.number(),
		})
	),
	unparsed: zod.object({
		copper: zod.number(),
		consumed: zod.record(zod.string(), zod.number()),
		exportedCrops: zod.record(zod.string(), zod.coerce.boolean<boolean>()).nullish(),
		dnaMilestone: zod.number(),
		levelCaps: zod.record(zod.string(), zod.number()),
		perks: zod.record(zod.string(), zod.number()).nullish(),
		tempStatBuffs: zod
			.array(
				zod.object({
					stat: zod.number(),
					key: zod.string().nullish(),
					amount: zod.number(),
					expire_at: zod.number(),
				})
			)
			.nullish(),
		accessoryBagSettings: zod.unknown().nullish(),
		bestiary: zod.unknown().nullish(),
		dungeons: zod
			.object({
				dungeon_types: zod
					.object({
						catacombs: zod.object({
							experience: zod.number(),
							highest_tier_completed: zod.number(),
							tier_completions: zod.record(zod.string(), zod.number()),
							times_played: zod.record(zod.string(), zod.number()),
							best_score: zod.record(zod.string(), zod.number()),
							mobs_killed: zod.record(zod.string(), zod.number()),
							most_mobs_killed: zod.record(zod.string(), zod.number()),
							watcher_kills: zod.record(zod.string(), zod.number()),
							most_healing: zod.record(zod.string(), zod.number()),
							fastest_time: zod.record(zod.string(), zod.number()),
							fastest_time_s: zod.record(zod.string(), zod.number()),
							fastest_time_s_plus: zod.record(zod.string(), zod.number()),
							most_damage_tank: zod.record(zod.string(), zod.number()),
							most_damage_mage: zod.record(zod.string(), zod.number()),
							most_damage_healer: zod.record(zod.string(), zod.number()),
							most_damage_archer: zod.record(zod.string(), zod.number()),
							milestone_completions: zod.record(zod.string(), zod.number()),
						}),
						master_catacombs: zod.object({
							experience: zod.number(),
							highest_tier_completed: zod.number(),
							tier_completions: zod.record(zod.string(), zod.number()),
							times_played: zod.record(zod.string(), zod.number()),
							best_score: zod.record(zod.string(), zod.number()),
							mobs_killed: zod.record(zod.string(), zod.number()),
							most_mobs_killed: zod.record(zod.string(), zod.number()),
							watcher_kills: zod.record(zod.string(), zod.number()),
							most_healing: zod.record(zod.string(), zod.number()),
							fastest_time: zod.record(zod.string(), zod.number()),
							fastest_time_s: zod.record(zod.string(), zod.number()),
							fastest_time_s_plus: zod.record(zod.string(), zod.number()),
							most_damage_tank: zod.record(zod.string(), zod.number()),
							most_damage_mage: zod.record(zod.string(), zod.number()),
							most_damage_healer: zod.record(zod.string(), zod.number()),
							most_damage_archer: zod.record(zod.string(), zod.number()),
							milestone_completions: zod.record(zod.string(), zod.number()),
						}),
					})
					.nullish(),
				player_classes: zod
					.object({
						healer: zod.object({
							experience: zod.number(),
						}),
						mage: zod.object({
							experience: zod.number(),
						}),
						berserk: zod.object({
							experience: zod.number(),
						}),
						archer: zod.object({
							experience: zod.number(),
						}),
						tank: zod.object({
							experience: zod.number(),
						}),
					})
					.nullish(),
				secrets: zod.number(),
			})
			.nullish(),
	}),
	jacob: zod.object({
		medals: zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
		}),
		earnedMedals: zod.object({
			bronze: zod.number(),
			silver: zod.number(),
			gold: zod.number(),
			platinum: zod.number(),
			diamond: zod.number(),
		}),
		perks: zod.object({
			doubleDrops: zod.number(),
			levelCap: zod.number(),
			personalBests: zod.coerce.boolean<boolean>(),
		}),
		stats: zod.object({
			brackets: zod.record(
				zod.string(),
				zod.union([
					zod.literal(0),
					zod.literal(1),
					zod.literal(2),
					zod.literal(3),
					zod.literal(4),
					zod.literal(5),
					zod.literal(-1),
				])
			),
			personalBests: zod.record(zod.string(), zod.number()),
			crops: zod.record(
				zod.string(),
				zod.object({
					participations: zod.number(),
					firstPlaceScores: zod.number(),
					personalBestTimestamp: zod.number().nullish(),
					medals: zod.object({
						bronze: zod.number(),
						silver: zod.number(),
						gold: zod.number(),
						platinum: zod.number(),
						diamond: zod.number(),
					}),
				})
			),
		}),
		participations: zod.number(),
		firstPlaceScores: zod.number(),
		contests: zod.array(
			zod.object({
				crop: zod.string(),
				timestamp: zod.number().describe('Timestamp of the contest in seconds since unix epoch.'),
				collected: zod.number(),
				position: zod.number(),
				participants: zod.number(),
				medal: zod.string().nullish(),
			})
		),
	}),
	farmingWeight: zod.object({
		totalWeight: zod.number(),
		crops: zod.record(zod.string(), zod.number()).nullish(),
		cropWeight: zod.record(zod.string(), zod.number()),
		bonusWeight: zod.record(zod.string(), zod.number()),
		uncountedCrops: zod.record(zod.string(), zod.number()),
		pests: zod.object({
			beetle: zod.number(),
			cricket: zod.number(),
			fly: zod.number(),
			locust: zod.number(),
			mite: zod.number(),
			mosquito: zod.number(),
			moth: zod.number(),
			rat: zod.number(),
			slug: zod.number(),
			earthworm: zod.number(),
			mouse: zod.number(),
			dragonfly: zod.number(),
			firefly: zod.number(),
			mantis: zod.number(),
		}),
		inventory: zod
			.object({
				armor: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				tools: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				equipment: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
				accessories: zod.array(
					zod.object({
						id: zod.number().describe('Old Minecraft id of the item'),
						count: zod.number().describe('Minecraft stack count of the item'),
						damage: zod.number().describe('Minecraft damage value of the item'),
						skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
						uuid: zod
							.string()
							.nullish()
							.describe('Item UUID to uniquely identify a specific instance of this item'),
						name: zod.string().nullish().describe('Item name, first line of the lore'),
						lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
						enchantments: zod
							.record(zod.string(), zod.number())
							.nullish()
							.describe('Applied enchantments with their levels'),
						attributes: zod
							.object({
								runes: zod.record(zod.string(), zod.number()).nullish(),
								effects: zod
									.array(
										zod.object({
											level: zod.number(),
											effect: zod.string().nullish(),
											duration_ticks: zod.number(),
										})
									)
									.nullish(),
								necromancer_souls: zod
									.array(
										zod.object({
											mob_id: zod.string().nullish(),
											dropped_instance_id: zod.string().nullish(),
											dropped_mode_id: zod.string().nullish(),
										})
									)
									.nullish(),
								hook: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								line: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								sinker: zod
									.object({
										part: zod.string().nullish(),
										donated_museum: zod.coerce.boolean<boolean>(),
									})
									.nullish(),
								ability_scroll: zod.array(zod.string()).nullish(),
								inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
							})
							.nullish()
							.describe('ExtraAttributes not included elsewhere'),
						itemAttributes: zod
							.record(zod.string(), zod.string())
							.nullish()
							.describe('ExtraAtrributes.Attributes for attribute shards'),
						gems: zod
							.record(zod.string(), zod.string().nullable())
							.nullish()
							.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
						petInfo: zod
							.object({
								type: zod.string(),
								active: zod.coerce.boolean<boolean>(),
								exp: zod.number(),
								level: zod.number(),
								tier: zod.string(),
								candyUsed: zod.number(),
								heldItem: zod.string().nullish(),
								skin: zod.string().nullish(),
							})
							.nullish()
							.describe('Pet info if item is a pet'),
						imageUrl: zod.string().nullish().describe('Image url for the item'),
						textureId: zod
							.string()
							.nullish()
							.describe('Texture id for the item, used to look up the image in our image service'),
						slot: zod
							.string()
							.nullish()
							.describe('Slot identifier where the item was located, if applicable'),
					})
				),
			})
			.nullish(),
		lastUpdated: zod.number(),
	}),
	garden: zod
		.object({
			profileId: zod.string().describe('Profile ID'),
			experience: zod.number().describe('Garden experience'),
			completedVisitors: zod.number().describe('Total completed visitors'),
			uniqueVisitors: zod.number().describe('Unique visitors unlocked'),
			crops: zod
				.object({
					cactus: zod.string().nullish(),
					carrot: zod.string().nullish(),
					potato: zod.string().nullish(),
					wheat: zod.string().nullish(),
					melon: zod.string().nullish(),
					pumpkin: zod.string().nullish(),
					mushroom: zod.string().nullish(),
					cocoaBeans: zod.string().nullish(),
					sugarCane: zod.string().nullish(),
					netherWart: zod.string().nullish(),
					sunflower: zod.string().nullish(),
					moonflower: zod.string().nullish(),
					wildRose: zod.string().nullish(),
				})
				.describe('Crops counted towards milestones'),
			cropUpgrades: zod
				.object({
					cactus: zod.number(),
					carrot: zod.number(),
					potato: zod.number(),
					wheat: zod.number(),
					melon: zod.number(),
					pumpkin: zod.number(),
					mushroom: zod.number(),
					cocoaBeans: zod.number(),
					sugarCane: zod.number(),
					netherWart: zod.number(),
					sunflower: zod.number(),
					moonflower: zod.number(),
					wildRose: zod.number(),
				})
				.describe('Crop upgrades'),
			plots: zod.array(zod.string()).describe('List of unlocked plots'),
			composter: zod
				.object({
					organic_matter: zod.number(),
					fuel_units: zod.number(),
					compost_units: zod.number(),
					compost_items: zod.number(),
					conversion_ticks: zod.number(),
					last_save: zod.number(),
					upgrades: zod.object({
						speed: zod.number(),
						multi_drop: zod.number(),
						fuel_cap: zod.number(),
						organic_matter_cap: zod.number(),
						cost_reduction: zod.number(),
					}),
					lastSave: zod.number().describe('Last save time in unix seconds'),
				})
				.describe('Composter data'),
			visitors: zod
				.record(
					zod.string(),
					zod.object({
						visits: zod.number(),
						accepted: zod.number(),
					})
				)
				.describe('Visitor data'),
			lastSave: zod.string().describe('Last save time in unix seconds'),
		})
		.nullish(),
	skills: zod.object({
		farming: zod.number(),
		mining: zod.number(),
		combat: zod.number(),
		foraging: zod.number(),
		fishing: zod.number(),
		enchanting: zod.number(),
		alchemy: zod.number(),
		carpentry: zod.number(),
		runecrafting: zod.number(),
		taming: zod.number(),
		social: zod.number(),
	}),
	chocolateFactory: zod.object({
		chocolate: zod.number(),
		totalChocolate: zod.number(),
		chocolateSincePrestige: zod.number(),
		chocolateSpent: zod.number(),
		prestige: zod.number(),
		lastViewed: zod.number(),
		uniqueRabbits: zod.object({
			common: zod.number(),
			uncommon: zod.number(),
			rare: zod.number(),
			epic: zod.number(),
			legendary: zod.number(),
			mythic: zod.number(),
			divine: zod.number(),
		}),
		totalRabbits: zod.object({
			common: zod.number(),
			uncommon: zod.number(),
			rare: zod.number(),
			epic: zod.number(),
			legendary: zod.number(),
			mythic: zod.number(),
			divine: zod.number(),
		}),
		unlockedZorro: zod.coerce.boolean<boolean>(),
		refinedTrufflesConsumed: zod.number(),
		cocoaFortuneUpgrades: zod.number(),
	}),
	events: zod.array(
		zod.object({
			eventId: zod.string(),
			eventName: zod.string(),
			teamId: zod.string().nullish(),
			status: zod.union([zod.literal(0), zod.literal(1), zod.literal(2), zod.literal(3)]),
			rank: zod.number().describe('Currently not populated'),
			score: zod.string().nullish(),
		})
	),
	inventories: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string().max(zodGetSelectedProfileResponseInventoriesItemNameMax),
			metadata: zod.record(zod.string(), zod.string()).nullish(),
		})
	),
	isSelected: zod.coerce.boolean<boolean>(),
	wasRemoved: zod.coerce.boolean<boolean>(),
	lastUpdated: zod.number(),
	lastDataChanged: zod.number(),
});

/**
 * Retrieves the yearly recap for a player. Requires authentication if the recap is not public.
 * @summary Get Player Recap
 */
export const zodGetPlayerRecapParams = zod.object({
	year: zod.number(),
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetPlayerRecapResponse = zod.object({
	playerUuid: zod.string(),
	year: zod.number(),
	public: zod.coerce.boolean<boolean>(),
	data: zod.object({
		player: zod.object({
			ign: zod.string(),
			uuid: zod.string(),
			firstDataPoint: zod.string(),
			lastDataPoint: zod.string(),
			daysActive: zod.number(),
			mostActiveMonth: zod.string(),
			farmingWeight: zod.object({
				gained: zod.number(),
				total: zod.number(),
				averageComparison: zod.number(),
			}),
		}),
		profiles: zod.array(
			zod.object({
				name: zod.string(),
				cuteName: zod.string(),
				isMain: zod.coerce.boolean<boolean>(),
				wiped: zod.coerce.boolean<boolean>().nullish(),
			})
		),
		allProfilesSummary: zod.object({
			totalWeightGained: zod.number(),
			totalCoinsGained: zod.number(),
			wipedProfiles: zod.number(),
		}),
		contests: zod.object({
			total: zod.number(),
			perCrop: zod.record(zod.string(), zod.number()),
			highestPlacements: zod.array(
				zod.object({
					crop: zod.string(),
					rank: zod.number(),
					medal: zod.string(),
				})
			),
		}),
		events: zod.array(
			zod.object({
				name: zod.string(),
				type: zod.string(),
				participated: zod.coerce.boolean<boolean>(),
				rank: zod.number().nullish(),
				score: zod.number().nullish(),
				banner: zod.string().nullish(),
				typeLabel: zod.string().nullish(),
			})
		),
		shop: zod.object({
			hasPurchased: zod.coerce.boolean<boolean>(),
		}),
		collections: zod.object({
			increases: zod.record(zod.string(), zod.number()),
			globalTotals: zod.record(zod.string(), zod.number()),
			averageComparison: zod.record(zod.string(), zod.number()),
			monthly: zod.array(
				zod.object({
					month: zod.string(),
					amount: zod.number(),
				})
			),
		}),
		pests: zod.object({
			kills: zod.number(),
			breakdown: zod.record(zod.string(), zod.number()),
			globalTotal: zod.number(),
			averageComparison: zod.number(),
			monthly: zod.array(
				zod.object({
					month: zod.string(),
					amount: zod.number(),
				})
			),
		}),
		skills: zod.object({
			farmingXp: zod.number(),
			breakdown: zod.record(zod.string(), zod.number()),
			globalTotal: zod.number(),
			averageComparison: zod.number(),
		}),
		streak: zod.object({
			longestStreakHours: zod.number(),
			start: zod.number(),
			end: zod.number(),
			averageDailyDowntime: zod.number(),
			sparkline: zod.array(zod.number()),
		}),
		leaderboards: zod.object({
			top1000: zod.array(
				zod.object({
					title: zod.string(),
					slug: zod.string(),
					rank: zod.number(),
					amount: zod.number(),
					shortTitle: zod.string().nullish(),
				})
			),
			monthlyHighs: zod.array(
				zod.object({
					month: zod.string(),
					name: zod.string(),
					rank: zod.number(),
				})
			),
		}),
		year: zod.string(),
		currentProfile: zod.string(),
	}),
	global: zod.object({
		totalCrops: zod.number(),
		totalXp: zod.number(),
		totalPests: zod.number(),
		totalFarmingWeight: zod.number(),
		trackedPlayers: zod.number(),
		bannedWiped: zod.number(),
		ironmanToNormal: zod.number(),
		crops: zod.record(zod.string(), zod.number()),
		totalCropsBreakdown: zod.record(zod.string(), zod.number()),
		skills: zod.record(zod.string(), zod.number()),
		totalSkillsBreakdown: zod.record(zod.string(), zod.number()),
		pests: zod.record(zod.string(), zod.number()),
		totalPestsBreakdown: zod.record(zod.string(), zod.number()),
	}),
	discord: zod.object({
		username: zod.string(),
		id: zod.string(),
		avatar: zod.string(),
	}),
});

/**
 * Toggles the public visibility of a player's yearly recap.
 * @summary Toggle Recap Visibility
 */
export const zodToggleRecapVisibilityParams = zod.object({
	year: zod.number(),
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodToggleRecapVisibilityBody = zod.object({
	public: zod.coerce.boolean<boolean>(),
});

/**
 * Get a specific auction by id. Will not fetch auction from Hypixel, only returns auctions that exist locally.
 * @summary Get Auction
 */
export const zodGetAuctionParams = zod.object({
	auctionId: zod.string(),
});

export const zodGetAuctionResponse = zod.object({
	auction: zod.object({
		auctionId: zod.string(),
		sellerUuid: zod.string(),
		sellerProfileUuid: zod.string(),
		seller: zod
			.object({
				id: zod.string(),
				name: zod.string(),
				formattedName: zod.string(),
			})
			.nullish(),
		buyerUuid: zod.string().nullish(),
		buyerProfileUuid: zod.string().nullish(),
		buyer: zod
			.object({
				id: zod.string(),
				name: zod.string(),
				formattedName: zod.string(),
			})
			.nullish(),
		start: zod.number(),
		end: zod.number(),
		soldAt: zod.number(),
		price: zod.number(),
		count: zod.number(),
		bin: zod.coerce.boolean<boolean>(),
		skyblockId: zod.string().nullish(),
		variantKey: zod.string(),
		itemUuid: zod.string().nullish(),
		item: zod
			.object({
				id: zod.number().describe('Old Minecraft id of the item'),
				count: zod.number().describe('Minecraft stack count of the item'),
				damage: zod.number().describe('Minecraft damage value of the item'),
				skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
				uuid: zod
					.string()
					.nullish()
					.describe('Item UUID to uniquely identify a specific instance of this item'),
				name: zod.string().nullish().describe('Item name, first line of the lore'),
				lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
				enchantments: zod
					.record(zod.string(), zod.number())
					.nullish()
					.describe('Applied enchantments with their levels'),
				attributes: zod
					.object({
						runes: zod.record(zod.string(), zod.number()).nullish(),
						effects: zod
							.array(
								zod.object({
									level: zod.number(),
									effect: zod.string().nullish(),
									duration_ticks: zod.number(),
								})
							)
							.nullish(),
						necromancer_souls: zod
							.array(
								zod.object({
									mob_id: zod.string().nullish(),
									dropped_instance_id: zod.string().nullish(),
									dropped_mode_id: zod.string().nullish(),
								})
							)
							.nullish(),
						hook: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						line: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						sinker: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						ability_scroll: zod.array(zod.string()).nullish(),
						inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
					})
					.nullish()
					.describe('ExtraAttributes not included elsewhere'),
				itemAttributes: zod
					.record(zod.string(), zod.string())
					.nullish()
					.describe('ExtraAtrributes.Attributes for attribute shards'),
				gems: zod
					.record(zod.string(), zod.string().nullable())
					.nullish()
					.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
				petInfo: zod
					.object({
						type: zod.string(),
						active: zod.coerce.boolean<boolean>(),
						exp: zod.number(),
						level: zod.number(),
						tier: zod.string(),
						candyUsed: zod.number(),
						heldItem: zod.string().nullish(),
						skin: zod.string().nullish(),
					})
					.nullish()
					.describe('Pet info if item is a pet'),
				imageUrl: zod.string().nullish().describe('Image url for the item'),
				textureId: zod
					.string()
					.nullish()
					.describe('Texture id for the item, used to look up the image in our image service'),
				slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
			})
			.nullish(),
		lastUpdatedAt: zod.iso.datetime({}),
		startingBid: zod.number(),
		highestBid: zod.number().nullish(),
	}),
});

/**
 * Get overview of auction house.
 * @summary Get Auction House Overview
 */
export const zodGetAuctionHouseOverviewResponse = zod.object({
	new: zod.array(
		zod.object({
			auctionId: zod.string(),
			sellerUuid: zod.string(),
			sellerProfileUuid: zod.string(),
			seller: zod
				.object({
					id: zod.string(),
					name: zod.string(),
					formattedName: zod.string(),
				})
				.nullish(),
			buyerUuid: zod.string().nullish(),
			buyerProfileUuid: zod.string().nullish(),
			buyer: zod
				.object({
					id: zod.string(),
					name: zod.string(),
					formattedName: zod.string(),
				})
				.nullish(),
			start: zod.number(),
			end: zod.number(),
			soldAt: zod.number(),
			price: zod.number(),
			count: zod.number(),
			bin: zod.coerce.boolean<boolean>(),
			skyblockId: zod.string().nullish(),
			variantKey: zod.string(),
			itemUuid: zod.string().nullish(),
			item: zod
				.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
				.nullish(),
			lastUpdatedAt: zod.iso.datetime({}),
			startingBid: zod.number(),
			highestBid: zod.number().nullish(),
		})
	),
	ended: zod.array(
		zod.object({
			auctionId: zod.string(),
			sellerUuid: zod.string(),
			sellerProfileUuid: zod.string(),
			seller: zod
				.object({
					id: zod.string(),
					name: zod.string(),
					formattedName: zod.string(),
				})
				.nullish(),
			buyerUuid: zod.string().nullish(),
			buyerProfileUuid: zod.string().nullish(),
			buyer: zod
				.object({
					id: zod.string(),
					name: zod.string(),
					formattedName: zod.string(),
				})
				.nullish(),
			start: zod.number(),
			end: zod.number(),
			soldAt: zod.number(),
			price: zod.number(),
			count: zod.number(),
			bin: zod.coerce.boolean<boolean>(),
			skyblockId: zod.string().nullish(),
			variantKey: zod.string(),
			itemUuid: zod.string().nullish(),
			item: zod
				.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
				.nullish(),
			lastUpdatedAt: zod.iso.datetime({}),
			startingBid: zod.number(),
			highestBid: zod.number().nullish(),
		})
	),
});

/**
 * Get lowest auction house prices.
 * @summary Get Auction House
 */
export const zodGetAuctionHouseProductsResponse = zod.object({
	items: zod.record(
		zod.string(),
		zod.array(
			zod.object({
				skyblockId: zod.string(),
				variantKey: zod.string(),
				variedBy: zod
					.object({
						rarity: zod.string().nullish(),
						enchantments: zod.record(zod.string(), zod.number()).nullish(),
						pet: zod.string().nullish(),
						petLevel: zod
							.object({
								key: zod.string(),
								min: zod.number(),
								max: zod.number(),
							})
							.nullish(),
						itemAttributes: zod.record(zod.string(), zod.string()).nullish(),
						extra: zod.record(zod.string(), zod.string()).nullish(),
					})
					.describe('Data used to generate variant key (easier to parse)'),
				lowest: zod.number().describe('Lowest price seen recently (excluding outliers)'),
				lowestVolume: zod.number().describe('Volume of prices used to get the lowest recent price'),
				lowest3Day: zod.number().describe('Lowest price seen in 3 days (excluding outliers)'),
				lowest3DayVolume: zod.number().describe('Volume of prices used to get the lowest 3 day price'),
				lowest7Day: zod.number().describe('Lowest price seen in 7 days (excluding outliers)'),
				lowest7DayVolume: zod.number().describe('Volume of prices ued to get lowest 3 day price'),
			})
		)
	),
});

/**
 * @summary Get Auction History For Item
 */
export const zodGetAuctionPriceHistoryParams = zod.object({
	skyblockId: zod.string(),
	variantKey: zod.string(),
});

export const zodGetAuctionPriceHistoryQueryParams = zod.object({
	timespan: zod.string().nullish(),
});

export const zodGetAuctionPriceHistoryResponse = zod.object({
	history: zod.array(
		zod.object({
			timestamp: zod.iso.datetime({}),
			lowestBinPrice: zod.number().nullish(),
			averageBinPrice: zod.number().nullish(),
			binListings: zod.number(),
			lowestSalePrice: zod.number().nullish(),
			averageSalePrice: zod.number().nullish(),
			saleAuctions: zod.number(),
			itemsSold: zod.number(),
		})
	),
});

/**
 * Retrieve aggregated BIN statistics for each tracked variant of a SkyBlock item.
 * @summary List Auction Variants
 */
export const zodGetAuctionVariantsParams = zod.object({
	skyblockId: zod.string(),
});

export const zodGetAuctionVariantsResponse = zod.object({
	variants: zod.array(
		zod.object({
			skyblockId: zod.string(),
			variantKey: zod.string(),
			variedBy: zod
				.object({
					rarity: zod.string().nullish(),
					enchantments: zod.record(zod.string(), zod.number()).nullish(),
					pet: zod.string().nullish(),
					petLevel: zod
						.object({
							key: zod.string(),
							min: zod.number(),
							max: zod.number(),
						})
						.nullish(),
					itemAttributes: zod.record(zod.string(), zod.string()).nullish(),
					extra: zod.record(zod.string(), zod.string()).nullish(),
				})
				.describe('Data used to generate variant key (easier to parse)'),
			lowest: zod.number().describe('Lowest price seen recently (excluding outliers)'),
			lowestVolume: zod.number().describe('Volume of prices used to get the lowest recent price'),
			lowest3Day: zod.number().describe('Lowest price seen in 3 days (excluding outliers)'),
			lowest3DayVolume: zod.number().describe('Volume of prices used to get the lowest 3 day price'),
			lowest7Day: zod.number().describe('Lowest price seen in 7 days (excluding outliers)'),
			lowest7DayVolume: zod.number().describe('Volume of prices ued to get lowest 3 day price'),
		})
	),
});

/**
 * Get recently ended auctions for a specific item and optional variant. Supports bundle: format for pets and runes.
 * @summary Get Recently Ended Auctions for Item
 */
export const zodGetItemEndedAuctionsParams = zod.object({
	skyblockId: zod.string(),
});

export const zodGetItemEndedAuctionsQueryParams = zod.object({
	variant: zod.string().nullish(),
	limit: zod.number(),
});

export const zodGetItemEndedAuctionsResponseItem = zod.object({
	auctionId: zod.string(),
	sellerUuid: zod.string(),
	sellerProfileUuid: zod.string(),
	seller: zod
		.object({
			id: zod.string(),
			name: zod.string(),
			formattedName: zod.string(),
		})
		.nullish(),
	buyerUuid: zod.string().nullish(),
	buyerProfileUuid: zod.string().nullish(),
	buyer: zod
		.object({
			id: zod.string(),
			name: zod.string(),
			formattedName: zod.string(),
		})
		.nullish(),
	start: zod.number(),
	end: zod.number(),
	soldAt: zod.number(),
	price: zod.number(),
	count: zod.number(),
	bin: zod.coerce.boolean<boolean>(),
	skyblockId: zod.string().nullish(),
	variantKey: zod.string(),
	itemUuid: zod.string().nullish(),
	item: zod
		.object({
			id: zod.number().describe('Old Minecraft id of the item'),
			count: zod.number().describe('Minecraft stack count of the item'),
			damage: zod.number().describe('Minecraft damage value of the item'),
			skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
			uuid: zod.string().nullish().describe('Item UUID to uniquely identify a specific instance of this item'),
			name: zod.string().nullish().describe('Item name, first line of the lore'),
			lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
			enchantments: zod
				.record(zod.string(), zod.number())
				.nullish()
				.describe('Applied enchantments with their levels'),
			attributes: zod
				.object({
					runes: zod.record(zod.string(), zod.number()).nullish(),
					effects: zod
						.array(
							zod.object({
								level: zod.number(),
								effect: zod.string().nullish(),
								duration_ticks: zod.number(),
							})
						)
						.nullish(),
					necromancer_souls: zod
						.array(
							zod.object({
								mob_id: zod.string().nullish(),
								dropped_instance_id: zod.string().nullish(),
								dropped_mode_id: zod.string().nullish(),
							})
						)
						.nullish(),
					hook: zod
						.object({
							part: zod.string().nullish(),
							donated_museum: zod.coerce.boolean<boolean>(),
						})
						.nullish(),
					line: zod
						.object({
							part: zod.string().nullish(),
							donated_museum: zod.coerce.boolean<boolean>(),
						})
						.nullish(),
					sinker: zod
						.object({
							part: zod.string().nullish(),
							donated_museum: zod.coerce.boolean<boolean>(),
						})
						.nullish(),
					ability_scroll: zod.array(zod.string()).nullish(),
					inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
				})
				.nullish()
				.describe('ExtraAttributes not included elsewhere'),
			itemAttributes: zod
				.record(zod.string(), zod.string())
				.nullish()
				.describe('ExtraAtrributes.Attributes for attribute shards'),
			gems: zod
				.record(zod.string(), zod.string().nullable())
				.nullish()
				.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
			petInfo: zod
				.object({
					type: zod.string(),
					active: zod.coerce.boolean<boolean>(),
					exp: zod.number(),
					level: zod.number(),
					tier: zod.string(),
					candyUsed: zod.number(),
					heldItem: zod.string().nullish(),
					skin: zod.string().nullish(),
				})
				.nullish()
				.describe('Pet info if item is a pet'),
			imageUrl: zod.string().nullish().describe('Image url for the item'),
			textureId: zod
				.string()
				.nullish()
				.describe('Texture id for the item, used to look up the image in our image service'),
			slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
		})
		.nullish(),
	lastUpdatedAt: zod.iso.datetime({}),
	startingBid: zod.number(),
	highestBid: zod.number().nullish(),
});
export const zodGetItemEndedAuctionsResponse = zod.array(zodGetItemEndedAuctionsResponseItem);

/**
 * Returns a paginated list of auction items ranked by recent trading volume.
 * @summary List Popular Auction Items
 */
export const zodGetPopularAuctionsQueryParams = zod.object({
	timespan: zod.string().nullish(),
	page: zod.number(),
	pageSize: zod.number(),
});

export const zodGetPopularAuctionsResponse = zod.object({
	page: zod.number(),
	pageSize: zod.number(),
	totalCount: zod.number(),
	totalPages: zod.number(),
	items: zod.array(
		zod.object({
			skyblockId: zod.string(),
			name: zod.string().nullish(),
			itemsSold: zod.number(),
			saleAuctions: zod.number(),
			binListings: zod.number(),
			averageSalePrice: zod.number().nullish(),
			averageBinPrice: zod.number().nullish(),
			lowestSalePrice: zod.number().nullish(),
			lowestBinPrice: zod.number().nullish(),
		})
	),
});

/**
 * Fuzzy search across known auctionable items by SkyBlock ID or display name.
 * @summary Search Auction Items
 */
export const zodSearchAuctionItemsQueryParams = zod.object({
	query: zod.string(),
	limit: zod.number(),
});

export const zodSearchAuctionItemsResponse = zod.object({
	results: zod.array(
		zod.object({
			skyblockId: zod.string(),
			variantKey: zod.string().nullish(),
			name: zod.string().nullish(),
			hasVariants: zod.coerce.boolean<boolean>(),
			variantCount: zod.number(),
			recentLowestPrice: zod.number().nullish(),
			recentVolume: zod.number(),
		})
	),
});

/**
 * Get overview of bazaar with top movers and most traded items.
 * @summary Get Bazaar Overview
 */
export const zodGetBazaarOverviewResponse = zod.object({
	topMovers: zod.array(
		zod.object({
			itemId: zod.string(),
			name: zod.string().nullish(),
			category: zod.string().nullish(),
			summary: zod.object({
				name: zod.string().nullish().describe('Name of the item if it exists.'),
				npc: zod.number().describe('NPC sell price of the item if it exists.'),
				sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
				buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
				sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
				buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
				averageSell: zod
					.number()
					.describe(
						'Calculated average Instant Sell price that should be more resistant to price fluctuations'
					),
				averageBuy: zod
					.number()
					.describe(
						'Calculated average Instant Buy price that should be more resistant to price fluctuations'
					),
				averageSellOrder: zod
					.number()
					.describe(
						'Calculated average Sell Order price that should be more resistant to price fluctuations'
					),
				averageBuyOrder: zod
					.number()
					.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
				orders: zod
					.object({
						sellSummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
						buySummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
					})
					.nullish()
					.describe('Current orders in the bazaar for this item if they exist.'),
			}),
		})
	),
	mostTraded: zod.array(
		zod.object({
			itemId: zod.string(),
			name: zod.string().nullish(),
			category: zod.string().nullish(),
			summary: zod.object({
				name: zod.string().nullish().describe('Name of the item if it exists.'),
				npc: zod.number().describe('NPC sell price of the item if it exists.'),
				sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
				buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
				sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
				buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
				averageSell: zod
					.number()
					.describe(
						'Calculated average Instant Sell price that should be more resistant to price fluctuations'
					),
				averageBuy: zod
					.number()
					.describe(
						'Calculated average Instant Buy price that should be more resistant to price fluctuations'
					),
				averageSellOrder: zod
					.number()
					.describe(
						'Calculated average Sell Order price that should be more resistant to price fluctuations'
					),
				averageBuyOrder: zod
					.number()
					.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
				orders: zod
					.object({
						sellSummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
						buySummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
					})
					.nullish()
					.describe('Current orders in the bazaar for this item if they exist.'),
			}),
		})
	),
});

/**
 * Get a specific bazaar product and it's npc price (if it exists)
 * @summary Get Bazaar Product
 */
export const zodGetBazaarProductParams = zod.object({
	itemId: zod.string(),
});

export const zodGetBazaarProductResponse = zod.object({
	productId: zod.string(),
	product: zod.object({
		name: zod.string().nullish().describe('Name of the item if it exists.'),
		npc: zod.number().describe('NPC sell price of the item if it exists.'),
		sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
		buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
		sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
		buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
		averageSell: zod
			.number()
			.describe('Calculated average Instant Sell price that should be more resistant to price fluctuations'),
		averageBuy: zod
			.number()
			.describe('Calculated average Instant Buy price that should be more resistant to price fluctuations'),
		averageSellOrder: zod
			.number()
			.describe('Calculated average Sell Order price that should be more resistant to price fluctuations'),
		averageBuyOrder: zod
			.number()
			.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
		orders: zod
			.object({
				sellSummary: zod
					.array(
						zod.object({
							amount: zod.number(),
							pricePerUnit: zod.number(),
							orders: zod.number(),
						})
					)
					.nullish(),
				buySummary: zod
					.array(
						zod.object({
							amount: zod.number(),
							pricePerUnit: zod.number(),
							orders: zod.number(),
						})
					)
					.nullish(),
			})
			.nullish()
			.describe('Current orders in the bazaar for this item if they exist.'),
	}),
});

/**
 * Get a specific bazaar product's history
 * @summary Get Bazaar Product History
 */
export const zodGetBazaarProductHistoryParams = zod.object({
	itemId: zod.string(),
});

export const zodGetBazaarProductHistoryQueryParams = zod.object({
	timespan: zod.string().nullish(),
});

export const zodGetBazaarProductHistoryResponse = zod.object({
	productId: zod.string(),
	product: zod.object({
		name: zod.string().nullish().describe('Name of the item if it exists.'),
		npc: zod.number().describe('NPC sell price of the item if it exists.'),
		sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
		buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
		sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
		buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
		averageSell: zod
			.number()
			.describe('Calculated average Instant Sell price that should be more resistant to price fluctuations'),
		averageBuy: zod
			.number()
			.describe('Calculated average Instant Buy price that should be more resistant to price fluctuations'),
		averageSellOrder: zod
			.number()
			.describe('Calculated average Sell Order price that should be more resistant to price fluctuations'),
		averageBuyOrder: zod
			.number()
			.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
		orders: zod
			.object({
				sellSummary: zod
					.array(
						zod.object({
							amount: zod.number(),
							pricePerUnit: zod.number(),
							orders: zod.number(),
						})
					)
					.nullish(),
				buySummary: zod
					.array(
						zod.object({
							amount: zod.number(),
							pricePerUnit: zod.number(),
							orders: zod.number(),
						})
					)
					.nullish(),
			})
			.nullish()
			.describe('Current orders in the bazaar for this item if they exist.'),
	}),
	history: zod.array(
		zod.object({
			timestamp: zod.iso.datetime({}),
			instaSellPrice: zod.number(),
			instaBuyPrice: zod.number(),
			buyOrderPrice: zod.number(),
			sellOrderPrice: zod.number(),
		})
	),
});

/**
 * Get all bazaar products.
 * @summary Get Bazaar Products
 */
export const zodGetBazaarProductsResponse = zod.object({
	products: zod.record(
		zod.string(),
		zod.object({
			name: zod.string().nullish().describe('Name of the item if it exists.'),
			npc: zod.number().describe('NPC sell price of the item if it exists.'),
			sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
			buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
			sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
			buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
			averageSell: zod
				.number()
				.describe('Calculated average Instant Sell price that should be more resistant to price fluctuations'),
			averageBuy: zod
				.number()
				.describe('Calculated average Instant Buy price that should be more resistant to price fluctuations'),
			averageSellOrder: zod
				.number()
				.describe('Calculated average Sell Order price that should be more resistant to price fluctuations'),
			averageBuyOrder: zod
				.number()
				.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
			orders: zod
				.object({
					sellSummary: zod
						.array(
							zod.object({
								amount: zod.number(),
								pricePerUnit: zod.number(),
								orders: zod.number(),
							})
						)
						.nullish(),
					buySummary: zod
						.array(
							zod.object({
								amount: zod.number(),
								pricePerUnit: zod.number(),
								orders: zod.number(),
							})
						)
						.nullish(),
				})
				.nullish()
				.describe('Current orders in the bazaar for this item if they exist.'),
		})
	),
});

/**
 * Search bazaar products by name or category. Returns all products if no filters provided.
 * @summary Search Bazaar Products
 */
export const zodSearchBazaarProductsQueryParams = zod.object({
	query: zod.string().nullish(),
	category: zod.string().nullish(),
	limit: zod.number(),
});

export const zodSearchBazaarProductsResponse = zod.object({
	products: zod.array(
		zod.object({
			itemId: zod.string(),
			name: zod.string().nullish(),
			category: zod.string().nullish(),
			summary: zod.object({
				name: zod.string().nullish().describe('Name of the item if it exists.'),
				npc: zod.number().describe('NPC sell price of the item if it exists.'),
				sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
				buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
				sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
				buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
				averageSell: zod
					.number()
					.describe(
						'Calculated average Instant Sell price that should be more resistant to price fluctuations'
					),
				averageBuy: zod
					.number()
					.describe(
						'Calculated average Instant Buy price that should be more resistant to price fluctuations'
					),
				averageSellOrder: zod
					.number()
					.describe(
						'Calculated average Sell Order price that should be more resistant to price fluctuations'
					),
				averageBuyOrder: zod
					.number()
					.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
				orders: zod
					.object({
						sellSummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
						buySummary: zod
							.array(
								zod.object({
									amount: zod.number(),
									pricePerUnit: zod.number(),
									orders: zod.number(),
								})
							)
							.nullish(),
					})
					.nullish()
					.describe('Current orders in the bazaar for this item if they exist.'),
			}),
		})
	),
});

/**
 * Get the current/upcoming Skyblock firesales.
 * @summary Get Current Skyblock Firesale
 */
export const zodSkyblockFiresaleResponse = zod.object({
	firesales: zod.array(
		zod.object({
			startsAt: zod.number(),
			endsAt: zod.number(),
			items: zod.array(
				zod.object({
					itemId: zod.string(),
					slotId: zod.number(),
					amount: zod.number(),
					price: zod.number().describe('Price in Skyblock Gems'),
					startsAt: zod.number().describe('Unix seconds'),
					endsAt: zod.number().describe('Unix seconds'),
				})
			),
		})
	),
});

/**
 * Get the current/upcoming Skyblock firesales, Taylor's Collection, and Seasonal Bundles.
 * @summary Get Skyblock Gem Shops
 */
export const zodSkyblockGemShopResponse = zod.object({
	firesales: zod.array(
		zod.object({
			startsAt: zod.number(),
			endsAt: zod.number(),
			items: zod.array(
				zod.object({
					itemId: zod.string(),
					slotId: zod.number(),
					amount: zod.number(),
					price: zod.number().describe('Price in Skyblock Gems'),
					startsAt: zod.number().describe('Unix seconds'),
					endsAt: zod.number().describe('Unix seconds'),
				})
			),
		})
	),
	taylorCollection: zod.object({
		items: zod.array(
			zod.object({
				name: zod.string(),
				output: zod.array(
					zod.object({
						type: zod.union([
							zod.literal(0),
							zod.literal(1),
							zod.literal(2),
							zod.literal(3),
							zod.literal(4),
							zod.literal(5),
							zod.literal(6),
							zod.literal(7),
							zod.literal(8),
							zod.literal(9),
						]),
						essence_type: zod.string().nullish(),
						item_id: zod.string().nullish(),
						medal_type: zod.string().nullish(),
						amount: zod.number(),
					})
				),
				cost: zod.array(
					zod.object({
						type: zod.union([
							zod.literal(0),
							zod.literal(1),
							zod.literal(2),
							zod.literal(3),
							zod.literal(4),
							zod.literal(5),
							zod.literal(6),
							zod.literal(7),
							zod.literal(8),
							zod.literal(9),
						]),
						essence_type: zod.string().nullish(),
						item_id: zod.string().nullish(),
						medal_type: zod.string().nullish(),
						amount: zod.number(),
					})
				),
				released: zod.string(),
			})
		),
	}),
	seasonalBundles: zod.object({
		items: zod.array(
			zod.object({
				name: zod.string(),
				output: zod.array(
					zod.object({
						type: zod.union([
							zod.literal(0),
							zod.literal(1),
							zod.literal(2),
							zod.literal(3),
							zod.literal(4),
							zod.literal(5),
							zod.literal(6),
							zod.literal(7),
							zod.literal(8),
							zod.literal(9),
						]),
						essence_type: zod.string().nullish(),
						item_id: zod.string().nullish(),
						medal_type: zod.string().nullish(),
						amount: zod.number(),
					})
				),
				cost: zod.array(
					zod.object({
						type: zod.union([
							zod.literal(0),
							zod.literal(1),
							zod.literal(2),
							zod.literal(3),
							zod.literal(4),
							zod.literal(5),
							zod.literal(6),
							zod.literal(7),
							zod.literal(8),
							zod.literal(9),
						]),
						essence_type: zod.string().nullish(),
						item_id: zod.string().nullish(),
						medal_type: zod.string().nullish(),
						amount: zod.number(),
					})
				),
				released: zod.string(),
			})
		),
	}),
});

/**
 * Get similar items and trend data for a specific item.
 * @summary Get Related Items and Trends
 */
export const zodGetItemRelatedParams = zod.object({
	skyblockId: zod.string(),
});

export const zodGetItemRelatedResponse = zod.object({
	similar: zod.array(
		zod.object({
			id: zod.string().nullish(),
			material: zod.string().nullish(),
			color: zod.string().nullish(),
			durability: zod.number(),
			skin: zod
				.object({
					value: zod.string().nullish(),
					signature: zod.string().nullish(),
				})
				.nullish(),
			name: zod.string().nullish(),
			category: zod.string().nullish(),
			tier: zod.string().nullish(),
			unstackable: zod.coerce.boolean<boolean>(),
			glowing: zod.coerce.boolean<boolean>(),
			npc_sell_price: zod.number(),
			can_auction: zod.coerce.boolean<boolean>(),
			can_trade: zod.coerce.boolean<boolean>(),
			can_place: zod.coerce.boolean<boolean>(),
			gemstone_slots: zod
				.array(
					zod.object({
						slot_type: zod.string().nullish(),
						costs: zod.array(
							zod.object({
								type: zod.string(),
								item_id: zod.string().nullish(),
								coins: zod.number(),
							})
						),
						requirements: zod.array(
							zod.object({
								type: zod.string(),
								skill: zod.string().nullish(),
								data_key: zod.string().nullish(),
								value: zod.string().nullish(),
								operator: zod.string().nullish(),
								level: zod.number(),
							})
						),
					})
				)
				.nullish(),
			requirements: zod
				.array(
					zod.object({
						type: zod.string(),
						skill: zod.string().nullish(),
						data_key: zod.string().nullish(),
						value: zod.string().nullish(),
						operator: zod.string().nullish(),
						level: zod.number(),
					})
				)
				.nullish(),
			museum: zod.coerce.boolean<boolean>(),
			museum_data: zod
				.object({
					donation_xp: zod.number(),
					parent: zod.record(zod.string(), zod.string()),
					type: zod.string().nullish(),
					armor_set_donation_xp: zod.record(zod.string(), zod.number()).nullish(),
					game_stage: zod.string().nullish(),
				})
				.nullish(),
			stats: zod.record(zod.string(), zod.number()).nullish(),
			generator_tier: zod.number(),
			dungeon_item_conversion_cost: zod
				.object({
					essence_type: zod.string().nullish(),
					amount: zod.number(),
				})
				.nullish(),
			upgrade_costs: zod
				.array(
					zod.array(
						zod.object({
							type: zod.string().nullish(),
							essence_type: zod.string().nullish(),
							item_id: zod.string().nullish(),
							amount: zod.number(),
						})
					)
				)
				.nullish(),
			catacombs_requirements: zod
				.array(
					zod.object({
						type: zod.string().nullish(),
						dungeon_type: zod.string().nullish(),
						level: zod.number(),
					})
				)
				.nullish(),
			hide_from_viewrecipe_command: zod.coerce.boolean<boolean>(),
			salvagable_from_recipe: zod.coerce.boolean<boolean>(),
			item_specific: zod
				.object({
					rootElement: zod.unknown(),
				})
				.nullish(),
		})
	),
	trends: zod
		.object({
			priceChangePercentage: zod.number(),
			volumeChangePercentage: zod.number(),
		})
		.nullish(),
});

/**
 * Get an ItemDto from raw bytes from Hypixel
 * @summary Parse Skyblock Item from Bytes
 */
export const zodGetItemsFromBytesBody = zod.object({
	bytes: zod.string(),
});

export const zodGetItemsFromBytesResponse = zod.object({
	items: zod.array(
		zod
			.object({
				id: zod.number().describe('Old Minecraft id of the item'),
				count: zod.number().describe('Minecraft stack count of the item'),
				damage: zod.number().describe('Minecraft damage value of the item'),
				skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
				uuid: zod
					.string()
					.nullish()
					.describe('Item UUID to uniquely identify a specific instance of this item'),
				name: zod.string().nullish().describe('Item name, first line of the lore'),
				lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
				enchantments: zod
					.record(zod.string(), zod.number())
					.nullish()
					.describe('Applied enchantments with their levels'),
				attributes: zod
					.object({
						runes: zod.record(zod.string(), zod.number()).nullish(),
						effects: zod
							.array(
								zod.object({
									level: zod.number(),
									effect: zod.string().nullish(),
									duration_ticks: zod.number(),
								})
							)
							.nullish(),
						necromancer_souls: zod
							.array(
								zod.object({
									mob_id: zod.string().nullish(),
									dropped_instance_id: zod.string().nullish(),
									dropped_mode_id: zod.string().nullish(),
								})
							)
							.nullish(),
						hook: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						line: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						sinker: zod
							.object({
								part: zod.string().nullish(),
								donated_museum: zod.coerce.boolean<boolean>(),
							})
							.nullish(),
						ability_scroll: zod.array(zod.string()).nullish(),
						inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
					})
					.nullish()
					.describe('ExtraAttributes not included elsewhere'),
				itemAttributes: zod
					.record(zod.string(), zod.string())
					.nullish()
					.describe('ExtraAtrributes.Attributes for attribute shards'),
				gems: zod
					.record(zod.string(), zod.string().nullable())
					.nullish()
					.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
				petInfo: zod
					.object({
						type: zod.string(),
						active: zod.coerce.boolean<boolean>(),
						exp: zod.number(),
						level: zod.number(),
						tier: zod.string(),
						candyUsed: zod.number(),
						heldItem: zod.string().nullish(),
						skin: zod.string().nullish(),
					})
					.nullish()
					.describe('Pet info if item is a pet'),
				imageUrl: zod.string().nullish().describe('Image url for the item'),
				textureId: zod
					.string()
					.nullish()
					.describe('Texture id for the item, used to look up the image in our image service'),
				slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
			})
			.nullable()
	),
});

/**
 * Get all items in the Hypixel resources endpoint
 * @summary Get Skyblock Items
 */
export const zodGetSkyblockItemsResponse = zod.object({
	items: zod.record(
		zod.string(),
		zod
			.object({
				id: zod.string().nullish(),
				material: zod.string().nullish(),
				color: zod.string().nullish(),
				durability: zod.number(),
				skin: zod
					.object({
						value: zod.string().nullish(),
						signature: zod.string().nullish(),
					})
					.nullish(),
				name: zod.string().nullish(),
				category: zod.string().nullish(),
				tier: zod.string().nullish(),
				unstackable: zod.coerce.boolean<boolean>(),
				glowing: zod.coerce.boolean<boolean>(),
				npc_sell_price: zod.number(),
				can_auction: zod.coerce.boolean<boolean>(),
				can_trade: zod.coerce.boolean<boolean>(),
				can_place: zod.coerce.boolean<boolean>(),
				gemstone_slots: zod
					.array(
						zod.object({
							slot_type: zod.string().nullish(),
							costs: zod.array(
								zod.object({
									type: zod.string(),
									item_id: zod.string().nullish(),
									coins: zod.number(),
								})
							),
							requirements: zod.array(
								zod.object({
									type: zod.string(),
									skill: zod.string().nullish(),
									data_key: zod.string().nullish(),
									value: zod.string().nullish(),
									operator: zod.string().nullish(),
									level: zod.number(),
								})
							),
						})
					)
					.nullish(),
				requirements: zod
					.array(
						zod.object({
							type: zod.string(),
							skill: zod.string().nullish(),
							data_key: zod.string().nullish(),
							value: zod.string().nullish(),
							operator: zod.string().nullish(),
							level: zod.number(),
						})
					)
					.nullish(),
				museum: zod.coerce.boolean<boolean>(),
				museum_data: zod
					.object({
						donation_xp: zod.number(),
						parent: zod.record(zod.string(), zod.string()),
						type: zod.string().nullish(),
						armor_set_donation_xp: zod.record(zod.string(), zod.number()).nullish(),
						game_stage: zod.string().nullish(),
					})
					.nullish(),
				stats: zod.record(zod.string(), zod.number()).nullish(),
				generator_tier: zod.number(),
				dungeon_item_conversion_cost: zod
					.object({
						essence_type: zod.string().nullish(),
						amount: zod.number(),
					})
					.nullish(),
				upgrade_costs: zod
					.array(
						zod.array(
							zod.object({
								type: zod.string().nullish(),
								essence_type: zod.string().nullish(),
								item_id: zod.string().nullish(),
								amount: zod.number(),
							})
						)
					)
					.nullish(),
				catacombs_requirements: zod
					.array(
						zod.object({
							type: zod.string().nullish(),
							dungeon_type: zod.string().nullish(),
							level: zod.number(),
						})
					)
					.nullish(),
				hide_from_viewrecipe_command: zod.coerce.boolean<boolean>(),
				salvagable_from_recipe: zod.coerce.boolean<boolean>(),
				item_specific: zod
					.object({
						rootElement: zod.unknown(),
					})
					.nullish(),
			})
			.nullable()
	),
});

/**
 * Get specific skyblock items from the Hypixel resources endpoint, along with bazaar data for each.
 * @summary Get Specific Skyblock Items
 */
export const zodGetSpecifiedSkyblockItemsBody = zod.object({
	items: zod.array(zod.string()),
});

export const zodGetSpecifiedSkyblockItemsResponse = zod.object({
	items: zod.record(
		zod.string(),
		zod.object({
			itemId: zod.string(),
			name: zod.string().nullish(),
			data: zod
				.object({
					id: zod.string().nullish(),
					material: zod.string().nullish(),
					color: zod.string().nullish(),
					durability: zod.number(),
					skin: zod
						.object({
							value: zod.string().nullish(),
							signature: zod.string().nullish(),
						})
						.nullish(),
					name: zod.string().nullish(),
					category: zod.string().nullish(),
					tier: zod.string().nullish(),
					unstackable: zod.coerce.boolean<boolean>(),
					glowing: zod.coerce.boolean<boolean>(),
					npc_sell_price: zod.number(),
					can_auction: zod.coerce.boolean<boolean>(),
					can_trade: zod.coerce.boolean<boolean>(),
					can_place: zod.coerce.boolean<boolean>(),
					gemstone_slots: zod
						.array(
							zod.object({
								slot_type: zod.string().nullish(),
								costs: zod.array(
									zod.object({
										type: zod.string(),
										item_id: zod.string().nullish(),
										coins: zod.number(),
									})
								),
								requirements: zod.array(
									zod.object({
										type: zod.string(),
										skill: zod.string().nullish(),
										data_key: zod.string().nullish(),
										value: zod.string().nullish(),
										operator: zod.string().nullish(),
										level: zod.number(),
									})
								),
							})
						)
						.nullish(),
					requirements: zod
						.array(
							zod.object({
								type: zod.string(),
								skill: zod.string().nullish(),
								data_key: zod.string().nullish(),
								value: zod.string().nullish(),
								operator: zod.string().nullish(),
								level: zod.number(),
							})
						)
						.nullish(),
					museum: zod.coerce.boolean<boolean>(),
					museum_data: zod
						.object({
							donation_xp: zod.number(),
							parent: zod.record(zod.string(), zod.string()),
							type: zod.string().nullish(),
							armor_set_donation_xp: zod.record(zod.string(), zod.number()).nullish(),
							game_stage: zod.string().nullish(),
						})
						.nullish(),
					stats: zod.record(zod.string(), zod.number()).nullish(),
					generator_tier: zod.number(),
					dungeon_item_conversion_cost: zod
						.object({
							essence_type: zod.string().nullish(),
							amount: zod.number(),
						})
						.nullish(),
					upgrade_costs: zod
						.array(
							zod.array(
								zod.object({
									type: zod.string().nullish(),
									essence_type: zod.string().nullish(),
									item_id: zod.string().nullish(),
									amount: zod.number(),
								})
							)
						)
						.nullish(),
					catacombs_requirements: zod
						.array(
							zod.object({
								type: zod.string().nullish(),
								dungeon_type: zod.string().nullish(),
								level: zod.number(),
							})
						)
						.nullish(),
					hide_from_viewrecipe_command: zod.coerce.boolean<boolean>(),
					salvagable_from_recipe: zod.coerce.boolean<boolean>(),
					item_specific: zod
						.object({
							rootElement: zod.unknown(),
						})
						.nullish(),
				})
				.nullish()
				.describe('Data from the Hypixel items endpoint'),
			bazaar: zod
				.object({
					name: zod.string().nullish().describe('Name of the item if it exists.'),
					npc: zod.number().describe('NPC sell price of the item if it exists.'),
					sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
					buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
					sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
					buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
					averageSell: zod
						.number()
						.describe(
							'Calculated average Instant Sell price that should be more resistant to price fluctuations'
						),
					averageBuy: zod
						.number()
						.describe(
							'Calculated average Instant Buy price that should be more resistant to price fluctuations'
						),
					averageSellOrder: zod
						.number()
						.describe(
							'Calculated average Sell Order price that should be more resistant to price fluctuations'
						),
					averageBuyOrder: zod
						.number()
						.describe(
							'Calculated average Buy Order price that should be more resistant to price fluctuations'
						),
					orders: zod
						.object({
							sellSummary: zod
								.array(
									zod.object({
										amount: zod.number(),
										pricePerUnit: zod.number(),
										orders: zod.number(),
									})
								)
								.nullish(),
							buySummary: zod
								.array(
									zod.object({
										amount: zod.number(),
										pricePerUnit: zod.number(),
										orders: zod.number(),
									})
								)
								.nullish(),
						})
						.nullish()
						.describe('Current orders in the bazaar for this item if they exist.'),
				})
				.nullish(),
			auctions: zod
				.array(
					zod.object({
						skyblockId: zod.string(),
						variantKey: zod.string(),
						variedBy: zod
							.object({
								rarity: zod.string().nullish(),
								enchantments: zod.record(zod.string(), zod.number()).nullish(),
								pet: zod.string().nullish(),
								petLevel: zod
									.object({
										key: zod.string(),
										min: zod.number(),
										max: zod.number(),
									})
									.nullish(),
								itemAttributes: zod.record(zod.string(), zod.string()).nullish(),
								extra: zod.record(zod.string(), zod.string()).nullish(),
							})
							.describe('Data used to generate variant key (easier to parse)'),
						lowest: zod.number().describe('Lowest price seen recently (excluding outliers)'),
						lowestVolume: zod.number().describe('Volume of prices used to get the lowest recent price'),
						lowest3Day: zod.number().describe('Lowest price seen in 3 days (excluding outliers)'),
						lowest3DayVolume: zod.number().describe('Volume of prices used to get the lowest 3 day price'),
						lowest7Day: zod.number().describe('Lowest price seen in 7 days (excluding outliers)'),
						lowest7DayVolume: zod.number().describe('Volume of prices ued to get lowest 3 day price'),
					})
				)
				.nullish(),
		})
	),
});

/**
 * Get the Hypixel provided data of a specific item, as well as a bazaar summary.
 * @summary Get Skyblock Item
 */
export const zodSkyblockProductParams = zod.object({
	itemId: zod.string(),
});

export const zodSkyblockProductResponse = zod.object({
	itemId: zod.string(),
	name: zod.string().nullish(),
	data: zod
		.object({
			id: zod.string().nullish(),
			material: zod.string().nullish(),
			color: zod.string().nullish(),
			durability: zod.number(),
			skin: zod
				.object({
					value: zod.string().nullish(),
					signature: zod.string().nullish(),
				})
				.nullish(),
			name: zod.string().nullish(),
			category: zod.string().nullish(),
			tier: zod.string().nullish(),
			unstackable: zod.coerce.boolean<boolean>(),
			glowing: zod.coerce.boolean<boolean>(),
			npc_sell_price: zod.number(),
			can_auction: zod.coerce.boolean<boolean>(),
			can_trade: zod.coerce.boolean<boolean>(),
			can_place: zod.coerce.boolean<boolean>(),
			gemstone_slots: zod
				.array(
					zod.object({
						slot_type: zod.string().nullish(),
						costs: zod.array(
							zod.object({
								type: zod.string(),
								item_id: zod.string().nullish(),
								coins: zod.number(),
							})
						),
						requirements: zod.array(
							zod.object({
								type: zod.string(),
								skill: zod.string().nullish(),
								data_key: zod.string().nullish(),
								value: zod.string().nullish(),
								operator: zod.string().nullish(),
								level: zod.number(),
							})
						),
					})
				)
				.nullish(),
			requirements: zod
				.array(
					zod.object({
						type: zod.string(),
						skill: zod.string().nullish(),
						data_key: zod.string().nullish(),
						value: zod.string().nullish(),
						operator: zod.string().nullish(),
						level: zod.number(),
					})
				)
				.nullish(),
			museum: zod.coerce.boolean<boolean>(),
			museum_data: zod
				.object({
					donation_xp: zod.number(),
					parent: zod.record(zod.string(), zod.string()),
					type: zod.string().nullish(),
					armor_set_donation_xp: zod.record(zod.string(), zod.number()).nullish(),
					game_stage: zod.string().nullish(),
				})
				.nullish(),
			stats: zod.record(zod.string(), zod.number()).nullish(),
			generator_tier: zod.number(),
			dungeon_item_conversion_cost: zod
				.object({
					essence_type: zod.string().nullish(),
					amount: zod.number(),
				})
				.nullish(),
			upgrade_costs: zod
				.array(
					zod.array(
						zod.object({
							type: zod.string().nullish(),
							essence_type: zod.string().nullish(),
							item_id: zod.string().nullish(),
							amount: zod.number(),
						})
					)
				)
				.nullish(),
			catacombs_requirements: zod
				.array(
					zod.object({
						type: zod.string().nullish(),
						dungeon_type: zod.string().nullish(),
						level: zod.number(),
					})
				)
				.nullish(),
			hide_from_viewrecipe_command: zod.coerce.boolean<boolean>(),
			salvagable_from_recipe: zod.coerce.boolean<boolean>(),
			item_specific: zod
				.object({
					rootElement: zod.unknown(),
				})
				.nullish(),
		})
		.nullish()
		.describe('Data from the Hypixel items endpoint'),
	bazaar: zod
		.object({
			name: zod.string().nullish().describe('Name of the item if it exists.'),
			npc: zod.number().describe('NPC sell price of the item if it exists.'),
			sell: zod.number().describe('Instant Sell price taken directly from most recently fetched data'),
			buy: zod.number().describe('Instant Buy price taken directly from most recently fetched data'),
			sellOrder: zod.number().describe('Sell Order price calculated from most recently fetched data'),
			buyOrder: zod.number().describe('Buy Order price calculated from most recently fetched data'),
			averageSell: zod
				.number()
				.describe('Calculated average Instant Sell price that should be more resistant to price fluctuations'),
			averageBuy: zod
				.number()
				.describe('Calculated average Instant Buy price that should be more resistant to price fluctuations'),
			averageSellOrder: zod
				.number()
				.describe('Calculated average Sell Order price that should be more resistant to price fluctuations'),
			averageBuyOrder: zod
				.number()
				.describe('Calculated average Buy Order price that should be more resistant to price fluctuations'),
			orders: zod
				.object({
					sellSummary: zod
						.array(
							zod.object({
								amount: zod.number(),
								pricePerUnit: zod.number(),
								orders: zod.number(),
							})
						)
						.nullish(),
					buySummary: zod
						.array(
							zod.object({
								amount: zod.number(),
								pricePerUnit: zod.number(),
								orders: zod.number(),
							})
						)
						.nullish(),
				})
				.nullish()
				.describe('Current orders in the bazaar for this item if they exist.'),
		})
		.nullish(),
	auctions: zod
		.array(
			zod.object({
				skyblockId: zod.string(),
				variantKey: zod.string(),
				variedBy: zod
					.object({
						rarity: zod.string().nullish(),
						enchantments: zod.record(zod.string(), zod.number()).nullish(),
						pet: zod.string().nullish(),
						petLevel: zod
							.object({
								key: zod.string(),
								min: zod.number(),
								max: zod.number(),
							})
							.nullish(),
						itemAttributes: zod.record(zod.string(), zod.string()).nullish(),
						extra: zod.record(zod.string(), zod.string()).nullish(),
					})
					.describe('Data used to generate variant key (easier to parse)'),
				lowest: zod.number().describe('Lowest price seen recently (excluding outliers)'),
				lowestVolume: zod.number().describe('Volume of prices used to get the lowest recent price'),
				lowest3Day: zod.number().describe('Lowest price seen in 3 days (excluding outliers)'),
				lowest3DayVolume: zod.number().describe('Volume of prices used to get the lowest 3 day price'),
				lowest7Day: zod.number().describe('Lowest price seen in 7 days (excluding outliers)'),
				lowest7DayVolume: zod.number().describe('Volume of prices ued to get lowest 3 day price'),
			})
		)
		.nullish(),
});

/**
 * @summary Add Product to Shop Category
 */
export const zodAddProductToCategoryParams = zod.object({
	categoryId: zod.number().describe('Id of the category to add the product to'),
	productId: zod.number().describe('Id of the product to add to the category'),
});

/**
 * @summary Remove Product from Shop Category
 */
export const zodRemoveProductToCategoryParams = zod.object({
	categoryId: zod.number().describe('Id of the category to add the product to'),
	productId: zod.number().describe('Id of the product to add to the category'),
});

/**
 * @summary Create Shop Category
 */
export const zodCreateCategoryBodyTitleMax = 256;

export const zodCreateCategoryBodySlugMax = 32;

export const zodCreateCategoryBodyDescriptionMax = 512;

export const zodCreateCategoryBody = zod.object({
	title: zod.string().max(zodCreateCategoryBodyTitleMax),
	slug: zod.string().max(zodCreateCategoryBodySlugMax),
	description: zod.string().max(zodCreateCategoryBodyDescriptionMax).nullish(),
});

/**
 * @summary Delete Shop Category
 */
export const zodDeleteCategoryParams = zod.object({
	categoryId: zod.number().describe('Id of the category to delete'),
});

/**
 * @summary Update Shop Category
 */
export const zodUpdateCategoryParams = zod.object({
	categoryId: zod.number().describe('Id of the category to update'),
});

export const zodUpdateCategoryBodyTitleMax = 256;

export const zodUpdateCategoryBodySlugMax = 32;

export const zodUpdateCategoryBodyDescriptionMax = 512;

export const zodUpdateCategoryBody = zod.object({
	title: zod.string().max(zodUpdateCategoryBodyTitleMax).nullish(),
	slug: zod.string().max(zodUpdateCategoryBodySlugMax).nullish(),
	description: zod.string().max(zodUpdateCategoryBodyDescriptionMax).nullish(),
	published: zod.coerce.boolean<boolean>().nullish(),
});

/**
 * @summary Get Shop Categories
 */
export const zodGetCategoriesQueryParams = zod.object({
	includeProducts: zod.coerce.boolean<boolean>().nullish().describe('Include products in response'),
});

export const zodGetCategoriesResponseProductsItemWeightStylesItemNameMax = 64;

export const zodGetCategoriesResponseProductsItemThumbnailTitleMax = 64;

export const zodGetCategoriesResponseProductsItemThumbnailDescriptionMax = 512;

export const zodGetCategoriesResponseProductsItemImagesItemTitleMax = 64;

export const zodGetCategoriesResponseProductsItemImagesItemDescriptionMax = 512;

export const zodGetCategoriesResponseItem = zod.object({
	id: zod.number(),
	title: zod.string(),
	slug: zod.string(),
	description: zod.string().nullish(),
	order: zod.number(),
	published: zod.coerce.boolean<boolean>(),
	products: zod.array(
		zod.object({
			id: zod.string().describe('Product ID'),
			name: zod.string().describe('Product name'),
			slug: zod.string().describe('Slug of the product'),
			price: zod.number().describe('Product price'),
			description: zod.string().nullish().describe('Product description'),
			available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
			type: zod
				.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
				.describe('Type of product'),
			features: zod
				.object({
					badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
					weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
					weightStyleOverride: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe("Ability to override other's weight styles."),
					embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
					hideShopPromotions: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to hide shop promotions.'),
					moreInfoDefault: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Show \"More Info\" on weight command by default.'),
					customEmoji: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to have custom name emoji for the user.'),
					maxMonthlyEvents: zod
						.number()
						.nullish()
						.describe('Maximum number of events that can be created in a month. (For guilds)'),
					maxJacobLeaderboards: zod
						.number()
						.nullish()
						.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
					flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
				})
				.describe('Features of the product'),
			weightStyles: zod
				.array(
					zod.object({
						id: zod.number(),
						name: zod.string().max(zodGetCategoriesResponseProductsItemWeightStylesItemNameMax).nullish(),
					})
				)
				.describe('Unlocked weight styles'),
			thumbnail: zod
				.object({
					title: zod
						.string()
						.max(zodGetCategoriesResponseProductsItemThumbnailTitleMax)
						.nullish()
						.describe('Image title'),
					description: zod
						.string()
						.max(zodGetCategoriesResponseProductsItemThumbnailDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish()
				.describe('Product thumbnail'),
			images: zod
				.array(
					zod.object({
						title: zod
							.string()
							.max(zodGetCategoriesResponseProductsItemImagesItemTitleMax)
							.nullish()
							.describe('Image title'),
						description: zod
							.string()
							.max(zodGetCategoriesResponseProductsItemImagesItemDescriptionMax)
							.nullish()
							.describe('Image description'),
						order: zod.number().nullish().describe('Image ordering number'),
						width: zod.number().describe('The original width of the image.'),
						height: zod.number().describe('The original height of the image.'),
						sources: zod
							.record(
								zod.string(),
								zod.object({
									url: zod
										.string()
										.describe('The fully-qualified public URL for this image variant.'),
									width: zod.number().describe('The width of this image variant in pixels.'),
								})
							)
							.describe(
								'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
							),
						url: zod.string().describe('Lowest quality image URL'),
					})
				)
				.describe('Product Images'),
			flags: zod.number().describe('Discord flags'),
			isSubscription: zod.coerce.boolean<boolean>(),
			isGuildSubscription: zod.coerce.boolean<boolean>(),
			isUserSubscription: zod.coerce.boolean<boolean>(),
		})
	),
});
export const zodGetCategoriesResponse = zod.array(zodGetCategoriesResponseItem);

/**
 * @summary Get Shop Category
 */
export const zodGetCategoryParams = zod.object({
	category: zod.string().describe('Category id or slug'),
});

export const zodGetCategoryResponseProductsItemWeightStylesItemNameMax = 64;

export const zodGetCategoryResponseProductsItemThumbnailTitleMax = 64;

export const zodGetCategoryResponseProductsItemThumbnailDescriptionMax = 512;

export const zodGetCategoryResponseProductsItemImagesItemTitleMax = 64;

export const zodGetCategoryResponseProductsItemImagesItemDescriptionMax = 512;

export const zodGetCategoryResponse = zod.object({
	id: zod.number(),
	title: zod.string(),
	slug: zod.string(),
	description: zod.string().nullish(),
	order: zod.number(),
	published: zod.coerce.boolean<boolean>(),
	products: zod.array(
		zod.object({
			id: zod.string().describe('Product ID'),
			name: zod.string().describe('Product name'),
			slug: zod.string().describe('Slug of the product'),
			price: zod.number().describe('Product price'),
			description: zod.string().nullish().describe('Product description'),
			available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
			type: zod
				.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
				.describe('Type of product'),
			features: zod
				.object({
					badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
					weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
					weightStyleOverride: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe("Ability to override other's weight styles."),
					embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
					hideShopPromotions: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to hide shop promotions.'),
					moreInfoDefault: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Show \"More Info\" on weight command by default.'),
					customEmoji: zod.coerce
						.boolean<boolean>()
						.nullish()
						.describe('Ability to have custom name emoji for the user.'),
					maxMonthlyEvents: zod
						.number()
						.nullish()
						.describe('Maximum number of events that can be created in a month. (For guilds)'),
					maxJacobLeaderboards: zod
						.number()
						.nullish()
						.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
					flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
				})
				.describe('Features of the product'),
			weightStyles: zod
				.array(
					zod.object({
						id: zod.number(),
						name: zod.string().max(zodGetCategoryResponseProductsItemWeightStylesItemNameMax).nullish(),
					})
				)
				.describe('Unlocked weight styles'),
			thumbnail: zod
				.object({
					title: zod
						.string()
						.max(zodGetCategoryResponseProductsItemThumbnailTitleMax)
						.nullish()
						.describe('Image title'),
					description: zod
						.string()
						.max(zodGetCategoryResponseProductsItemThumbnailDescriptionMax)
						.nullish()
						.describe('Image description'),
					order: zod.number().nullish().describe('Image ordering number'),
					width: zod.number().describe('The original width of the image.'),
					height: zod.number().describe('The original height of the image.'),
					sources: zod
						.record(
							zod.string(),
							zod.object({
								url: zod.string().describe('The fully-qualified public URL for this image variant.'),
								width: zod.number().describe('The width of this image variant in pixels.'),
							})
						)
						.describe(
							'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
						),
					url: zod.string().describe('Lowest quality image URL'),
				})
				.nullish()
				.describe('Product thumbnail'),
			images: zod
				.array(
					zod.object({
						title: zod
							.string()
							.max(zodGetCategoryResponseProductsItemImagesItemTitleMax)
							.nullish()
							.describe('Image title'),
						description: zod
							.string()
							.max(zodGetCategoryResponseProductsItemImagesItemDescriptionMax)
							.nullish()
							.describe('Image description'),
						order: zod.number().nullish().describe('Image ordering number'),
						width: zod.number().describe('The original width of the image.'),
						height: zod.number().describe('The original height of the image.'),
						sources: zod
							.record(
								zod.string(),
								zod.object({
									url: zod
										.string()
										.describe('The fully-qualified public URL for this image variant.'),
									width: zod.number().describe('The width of this image variant in pixels.'),
								})
							)
							.describe(
								'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
							),
						url: zod.string().describe('Lowest quality image URL'),
					})
				)
				.describe('Product Images'),
			flags: zod.number().describe('Discord flags'),
			isSubscription: zod.coerce.boolean<boolean>(),
			isGuildSubscription: zod.coerce.boolean<boolean>(),
			isUserSubscription: zod.coerce.boolean<boolean>(),
		})
	),
});

/**
 * @summary Reorder Shop Categories
 */

export const zodReorderCategoriesBody = zod.object({
	elements: zod
		.array(
			zod.object({
				id: zod.number(),
				order: zod.number(),
			})
		)
		.min(1),
});

/**
 * @summary Reorder Products in Shop Category
 */
export const zodReorderCategoryProductsParams = zod.object({
	categoryId: zod.number().describe('Category id'),
});

export const zodReorderCategoryProductsBody = zod.object({
	elements: zod
		.array(
			zod.object({
				id: zod.string().nullish(),
				order: zod.number(),
			})
		)
		.min(1),
});

/**
 * @summary Add Cosmetic to Product
 */
export const zodAddCosmeticToProductParams = zod.object({
	productId: zod.number().describe('Id of the produc to add the cosmetic to'),
	cosmeticId: zod.number().describe('Id of the cosmetic to add to the product'),
});

/**
 * @summary Remove Cosmetic from Product
 */
export const zodRemoveCosmeticToProductParams = zod.object({
	productId: zod.number().describe('Id of the produc to add the cosmetic to'),
	cosmeticId: zod.number().describe('Id of the cosmetic to add to the product'),
});

/**
 * @summary Add Image To Product
 */
export const zodAddProductImageParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodAddProductImageQueryThumbnailDefault = false;

export const zodAddProductImageQueryParams = zod.object({
	thumbnail: zod.coerce.boolean<boolean>().nullish().describe("Use this to set the image as the product's thumbnail"),
});

export const zodAddProductImageBodyTitleMax = 64;

export const zodAddProductImageBodyDescriptionMax = 512;

export const zodAddProductImageBody = zod.object({
	title: zod.string().max(zodAddProductImageBodyTitleMax).nullish(),
	description: zod.string().max(zodAddProductImageBodyDescriptionMax).nullish(),
	image: zod.instanceof(File),
});

/**
 * @summary Remove Image from Product
 */
export const zodDeleteProductImageParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
	imagePath: zod.string(),
});

/**
 * @summary Get Admin Shop Products
 */
export const zodGetAllProductsResponseWeightStylesItemNameMax = 64;

export const zodGetAllProductsResponseThumbnailTitleMax = 64;

export const zodGetAllProductsResponseThumbnailDescriptionMax = 512;

export const zodGetAllProductsResponseImagesItemTitleMax = 64;

export const zodGetAllProductsResponseImagesItemDescriptionMax = 512;

export const zodGetAllProductsResponseItem = zod.object({
	id: zod.string().describe('Product ID'),
	name: zod.string().describe('Product name'),
	slug: zod.string().describe('Slug of the product'),
	price: zod.number().describe('Product price'),
	description: zod.string().nullish().describe('Product description'),
	available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
	type: zod
		.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
		.describe('Type of product'),
	features: zod
		.object({
			badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
			weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
			hideShopPromotions: zod.coerce.boolean<boolean>().nullish().describe('Ability to hide shop promotions.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			customEmoji: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Ability to have custom name emoji for the user.'),
			maxMonthlyEvents: zod
				.number()
				.nullish()
				.describe('Maximum number of events that can be created in a month. (For guilds)'),
			maxJacobLeaderboards: zod
				.number()
				.nullish()
				.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
			flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
		})
		.describe('Features of the product'),
	weightStyles: zod
		.array(
			zod.object({
				id: zod.number(),
				name: zod.string().max(zodGetAllProductsResponseWeightStylesItemNameMax).nullish(),
			})
		)
		.describe('Unlocked weight styles'),
	thumbnail: zod
		.object({
			title: zod.string().max(zodGetAllProductsResponseThumbnailTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetAllProductsResponseThumbnailDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Product thumbnail'),
	images: zod
		.array(
			zod.object({
				title: zod.string().max(zodGetAllProductsResponseImagesItemTitleMax).nullish().describe('Image title'),
				description: zod
					.string()
					.max(zodGetAllProductsResponseImagesItemDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			})
		)
		.describe('Product Images'),
	flags: zod.number().describe('Discord flags'),
	isSubscription: zod.coerce.boolean<boolean>(),
	isGuildSubscription: zod.coerce.boolean<boolean>(),
	isUserSubscription: zod.coerce.boolean<boolean>(),
});
export const zodGetAllProductsResponse = zod.array(zodGetAllProductsResponseItem);

/**
 * @summary Refresh Shop Products
 */
export const zodRefreshProductsResponseWeightStylesItemNameMax = 64;

export const zodRefreshProductsResponseThumbnailTitleMax = 64;

export const zodRefreshProductsResponseThumbnailDescriptionMax = 512;

export const zodRefreshProductsResponseImagesItemTitleMax = 64;

export const zodRefreshProductsResponseImagesItemDescriptionMax = 512;

export const zodRefreshProductsResponseItem = zod.object({
	id: zod.string().describe('Product ID'),
	name: zod.string().describe('Product name'),
	slug: zod.string().describe('Slug of the product'),
	price: zod.number().describe('Product price'),
	description: zod.string().nullish().describe('Product description'),
	available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
	type: zod
		.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
		.describe('Type of product'),
	features: zod
		.object({
			badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
			weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
			hideShopPromotions: zod.coerce.boolean<boolean>().nullish().describe('Ability to hide shop promotions.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			customEmoji: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Ability to have custom name emoji for the user.'),
			maxMonthlyEvents: zod
				.number()
				.nullish()
				.describe('Maximum number of events that can be created in a month. (For guilds)'),
			maxJacobLeaderboards: zod
				.number()
				.nullish()
				.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
			flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
		})
		.describe('Features of the product'),
	weightStyles: zod
		.array(
			zod.object({
				id: zod.number(),
				name: zod.string().max(zodRefreshProductsResponseWeightStylesItemNameMax).nullish(),
			})
		)
		.describe('Unlocked weight styles'),
	thumbnail: zod
		.object({
			title: zod.string().max(zodRefreshProductsResponseThumbnailTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodRefreshProductsResponseThumbnailDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Product thumbnail'),
	images: zod
		.array(
			zod.object({
				title: zod.string().max(zodRefreshProductsResponseImagesItemTitleMax).nullish().describe('Image title'),
				description: zod
					.string()
					.max(zodRefreshProductsResponseImagesItemDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			})
		)
		.describe('Product Images'),
	flags: zod.number().describe('Discord flags'),
	isSubscription: zod.coerce.boolean<boolean>(),
	isGuildSubscription: zod.coerce.boolean<boolean>(),
	isUserSubscription: zod.coerce.boolean<boolean>(),
});
export const zodRefreshProductsResponse = zod.array(zodRefreshProductsResponseItem);

/**
 * @summary Update Shop Product
 */
export const zodUpdateProductParams = zod.object({
	discordId: zod.number().describe('Discord Snowflake ID of the requested resource (guild, user, etc.)'),
});

export const zodUpdateProductBodyDescriptionMax = 1024;

export const zodUpdateProductBody = zod.object({
	description: zod.string().max(zodUpdateProductBodyDescriptionMax).nullish().describe('Description of the product'),
	available: zod.coerce.boolean<boolean>().nullish().describe('If the product is available for purchase'),
	price: zod.number().nullish().describe('Product price in USD cents'),
	features: zod
		.object({
			badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
			weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
			hideShopPromotions: zod.coerce.boolean<boolean>().nullish().describe('Ability to hide shop promotions.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			customEmoji: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Ability to have custom name emoji for the user.'),
			maxMonthlyEvents: zod
				.number()
				.nullish()
				.describe('Maximum number of events that can be created in a month. (For guilds)'),
			maxJacobLeaderboards: zod
				.number()
				.nullish()
				.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
			flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
		})
		.nullish()
		.describe('Features of the product'),
	releasedAt: zod.string().nullish().describe('Unix seconds timestamp of release date'),
});

/**
 * @summary Get Shop Product
 */
export const zodGetProductParams = zod.object({
	discordId: zod.number(),
});

export const zodGetProductResponseWeightStylesItemNameMax = 64;

export const zodGetProductResponseThumbnailTitleMax = 64;

export const zodGetProductResponseThumbnailDescriptionMax = 512;

export const zodGetProductResponseImagesItemTitleMax = 64;

export const zodGetProductResponseImagesItemDescriptionMax = 512;

export const zodGetProductResponse = zod.object({
	id: zod.string().describe('Product ID'),
	name: zod.string().describe('Product name'),
	slug: zod.string().describe('Slug of the product'),
	price: zod.number().describe('Product price'),
	description: zod.string().nullish().describe('Product description'),
	available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
	type: zod
		.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
		.describe('Type of product'),
	features: zod
		.object({
			badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
			weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
			hideShopPromotions: zod.coerce.boolean<boolean>().nullish().describe('Ability to hide shop promotions.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			customEmoji: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Ability to have custom name emoji for the user.'),
			maxMonthlyEvents: zod
				.number()
				.nullish()
				.describe('Maximum number of events that can be created in a month. (For guilds)'),
			maxJacobLeaderboards: zod
				.number()
				.nullish()
				.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
			flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
		})
		.describe('Features of the product'),
	weightStyles: zod
		.array(
			zod.object({
				id: zod.number(),
				name: zod.string().max(zodGetProductResponseWeightStylesItemNameMax).nullish(),
			})
		)
		.describe('Unlocked weight styles'),
	thumbnail: zod
		.object({
			title: zod.string().max(zodGetProductResponseThumbnailTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetProductResponseThumbnailDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Product thumbnail'),
	images: zod
		.array(
			zod.object({
				title: zod.string().max(zodGetProductResponseImagesItemTitleMax).nullish().describe('Image title'),
				description: zod
					.string()
					.max(zodGetProductResponseImagesItemDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			})
		)
		.describe('Product Images'),
	flags: zod.number().describe('Discord flags'),
	isSubscription: zod.coerce.boolean<boolean>(),
	isGuildSubscription: zod.coerce.boolean<boolean>(),
	isUserSubscription: zod.coerce.boolean<boolean>(),
});

/**
 * @summary Claim Free Shop Product
 */
export const zodClaimProductParams = zod.object({
	discordId: zod.number(),
});

/**
 * @summary Get Shop Products
 */
export const zodGetProductsResponseWeightStylesItemNameMax = 64;

export const zodGetProductsResponseThumbnailTitleMax = 64;

export const zodGetProductsResponseThumbnailDescriptionMax = 512;

export const zodGetProductsResponseImagesItemTitleMax = 64;

export const zodGetProductsResponseImagesItemDescriptionMax = 512;

export const zodGetProductsResponseItem = zod.object({
	id: zod.string().describe('Product ID'),
	name: zod.string().describe('Product name'),
	slug: zod.string().describe('Slug of the product'),
	price: zod.number().describe('Product price'),
	description: zod.string().nullish().describe('Product description'),
	available: zod.coerce.boolean<boolean>().describe('If the product is available for purchase'),
	type: zod
		.union([zod.literal(2), zod.literal(3), zod.literal(5), zod.literal(6), zod.literal(-1)])
		.describe('Type of product'),
	features: zod
		.object({
			badgeId: zod.number().nullish().describe('ID of unlocked badge.'),
			weightStyles: zod.array(zod.string()).nullish().describe('Name of weight style to unlock.'),
			weightStyleOverride: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe("Ability to override other's weight styles."),
			embedColors: zod.array(zod.string()).nullish().describe('Embed color for the bot.'),
			hideShopPromotions: zod.coerce.boolean<boolean>().nullish().describe('Ability to hide shop promotions.'),
			moreInfoDefault: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Show \"More Info\" on weight command by default.'),
			customEmoji: zod.coerce
				.boolean<boolean>()
				.nullish()
				.describe('Ability to have custom name emoji for the user.'),
			maxMonthlyEvents: zod
				.number()
				.nullish()
				.describe('Maximum number of events that can be created in a month. (For guilds)'),
			maxJacobLeaderboards: zod
				.number()
				.nullish()
				.describe('Maximum number of jacob leaderboard that can be active at once. (For guilds)'),
			flags: zod.array(zod.string()).nullish().describe('Unlocked product flags'),
		})
		.describe('Features of the product'),
	weightStyles: zod
		.array(
			zod.object({
				id: zod.number(),
				name: zod.string().max(zodGetProductsResponseWeightStylesItemNameMax).nullish(),
			})
		)
		.describe('Unlocked weight styles'),
	thumbnail: zod
		.object({
			title: zod.string().max(zodGetProductsResponseThumbnailTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetProductsResponseThumbnailDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish()
		.describe('Product thumbnail'),
	images: zod
		.array(
			zod.object({
				title: zod.string().max(zodGetProductsResponseImagesItemTitleMax).nullish().describe('Image title'),
				description: zod
					.string()
					.max(zodGetProductsResponseImagesItemDescriptionMax)
					.nullish()
					.describe('Image description'),
				order: zod.number().nullish().describe('Image ordering number'),
				width: zod.number().describe('The original width of the image.'),
				height: zod.number().describe('The original height of the image.'),
				sources: zod
					.record(
						zod.string(),
						zod.object({
							url: zod.string().describe('The fully-qualified public URL for this image variant.'),
							width: zod.number().describe('The width of this image variant in pixels.'),
						})
					)
					.describe(
						'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
					),
				url: zod.string().describe('Lowest quality image URL'),
			})
		)
		.describe('Product Images'),
	flags: zod.number().describe('Discord flags'),
	isSubscription: zod.coerce.boolean<boolean>(),
	isGuildSubscription: zod.coerce.boolean<boolean>(),
	isUserSubscription: zod.coerce.boolean<boolean>(),
});
export const zodGetProductsResponse = zod.array(zodGetProductsResponseItem);

/**
 * @summary Add Image To Style
 */
export const zodAddStyleImageParams = zod.object({
	styleId: zod.number(),
});

export const zodAddStyleImageQueryThumbnailDefault = false;

export const zodAddStyleImageQueryParams = zod.object({
	thumbnail: zod.coerce.boolean<boolean>().nullish().describe("Use this to set the image as the product's thumbnail"),
});

export const zodAddStyleImageBodyTitleMax = 64;

export const zodAddStyleImageBodyDescriptionMax = 512;

export const zodAddStyleImageBody = zod.object({
	title: zod.string().max(zodAddStyleImageBodyTitleMax).nullish(),
	description: zod.string().max(zodAddStyleImageBodyDescriptionMax).nullish(),
	image: zod.instanceof(File),
});

/**
 * @summary Create Shop Style
 */
export const zodCreateStyleBodyStyleFormatterMax = 64;

export const zodCreateStyleBodyNameMin = 0;
export const zodCreateStyleBodyNameMax = 64;

export const zodCreateStyleBodyCollectionMax = 64;

export const zodCreateStyleBodyDescriptionMax = 1024;

export const zodCreateStyleBody = zod.object({
	styleFormatter: zod.string().max(zodCreateStyleBodyStyleFormatterMax).nullish(),
	name: zod.string().min(zodCreateStyleBodyNameMin).max(zodCreateStyleBodyNameMax),
	collection: zod.string().max(zodCreateStyleBodyCollectionMax).nullish(),
	description: zod.string().max(zodCreateStyleBodyDescriptionMax).nullish(),
	data: zod.object({
		decal: zod
			.object({
				start: zod.object({
					x: zod.number(),
					y: zod.number(),
				}),
				end: zod.object({
					x: zod.number(),
					y: zod.number(),
				}),
				fill: zod.string().nullish(),
				imageUrl: zod.string().nullish(),
				crops: zod.record(zod.string(), zod.string()).nullish(),
			})
			.nullish(),
		elements: zod.object({
			background: zod.object({
				size: zod
					.object({
						x: zod.number(),
						y: zod.number(),
					})
					.nullish(),
				fill: zod.string().nullish(),
				rects: zod
					.array(
						zod.object({
							start: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
							end: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
							fill: zod.string().nullish(),
							useEmbedColor: zod.coerce.boolean<boolean>().nullish(),
							opacity: zod.number().nullish(),
						})
					)
					.nullish(),
				imageUrl: zod.string().nullish(),
				radius: zod.number().nullish(),
				opacity: zod.number().nullish(),
			}),
			gradients: zod
				.array(
					zod.object({
						direction: zod.object({
							start: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
							end: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
						}),
						bounds: zod.object({
							start: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
							end: zod.object({
								x: zod.number(),
								y: zod.number(),
							}),
						}),
						stops: zod
							.array(
								zod.object({
									position: zod.number(),
									fill: zod.string(),
								})
							)
							.nullish(),
						opacity: zod.number().nullish(),
					})
				)
				.nullish(),
			name: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			weight: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			label: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			head: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			badge: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			rank: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
			rankWithBadge: zod
				.object({
					font: zod.string().nullish(),
					fill: zod.string().nullish(),
					fontSize: zod.number().nullish(),
					position: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					maxWidth: zod.number().nullish(),
					maxHeight: zod.number().nullish(),
					outline: zod
						.object({
							width: zod.number().nullish(),
							opacity: zod.number().nullish(),
							fill: zod.string().nullish(),
						})
						.nullish(),
					background: zod
						.object({
							fill: zod.string().nullish(),
							opacity: zod.number().nullish(),
							padding: zod.number().nullish(),
							radius: zod.number().nullish(),
						})
						.nullish(),
				})
				.nullish(),
		}),
	}),
});

/**
 * @summary Delete Shop Style
 */
export const zodDeleteStyleParams = zod.object({
	styleId: zod.number(),
});

/**
 * @summary Get Shop Style
 */
export const zodGetStyleParams = zod.object({
	styleId: zod.number(),
});

export const zodGetStyleResponseStyleFormatterMax = 64;

export const zodGetStyleResponseNameMax = 64;

export const zodGetStyleResponseCollectionMax = 64;

export const zodGetStyleResponseDescriptionMax = 1024;

export const zodGetStyleResponseImageTitleMax = 64;

export const zodGetStyleResponseImageDescriptionMax = 512;

export const zodGetStyleResponseImagesItemTitleMax = 64;

export const zodGetStyleResponseImagesItemDescriptionMax = 512;

export const zodGetStyleResponse = zod.object({
	id: zod.number(),
	styleFormatter: zod.string().max(zodGetStyleResponseStyleFormatterMax).nullish(),
	name: zod.string().max(zodGetStyleResponseNameMax).nullish(),
	collection: zod.string().max(zodGetStyleResponseCollectionMax).nullish(),
	description: zod.string().max(zodGetStyleResponseDescriptionMax).nullish(),
	image: zod
		.object({
			title: zod.string().max(zodGetStyleResponseImageTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetStyleResponseImageDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	images: zod.array(
		zod.object({
			title: zod.string().max(zodGetStyleResponseImagesItemTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetStyleResponseImagesItemDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
	),
	products: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			slug: zod.string().nullish(),
		})
	),
	data: zod
		.object({
			decal: zod
				.object({
					start: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					end: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					fill: zod.string().nullish(),
					imageUrl: zod.string().nullish(),
					crops: zod.record(zod.string(), zod.string()).nullish(),
				})
				.nullish(),
			elements: zod.object({
				background: zod.object({
					size: zod
						.object({
							x: zod.number(),
							y: zod.number(),
						})
						.nullish(),
					fill: zod.string().nullish(),
					align: zod.string().nullish(),
					rects: zod
						.array(
							zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								fill: zod.string().nullish(),
								useEmbedColor: zod.coerce.boolean<boolean>().nullish(),
								opacity: zod.number().nullish(),
							})
						)
						.nullish(),
					imageUrl: zod.string().nullish(),
					radius: zod.number().nullish(),
					opacity: zod.number().nullish(),
				}),
				gradients: zod
					.array(
						zod.object({
							direction: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							bounds: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							stops: zod
								.array(
									zod.object({
										position: zod.number(),
										fill: zod.string(),
									})
								)
								.nullish(),
							opacity: zod.number().nullish(),
						})
					)
					.nullish(),
				name: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				weight: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				label: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				head: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				badge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rank: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rankWithBadge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
			}),
		})
		.nullish(),
	leaderboard: zod
		.object({
			background: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			overlay: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			gradientOpacity: zod.number().nullish(),
			gradientColor: zod.string().nullish(),
			font: zod.string().nullish(),
			name: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			score: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			rank: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			subtitle: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
		})
		.nullish(),
});

/**
 * @summary Update Shop Style
 */
export const zodUpdateStyleParams = zod.object({
	styleId: zod.number(),
});

export const zodUpdateStyleBodyStyleFormatterMax = 64;

export const zodUpdateStyleBodyNameMax = 64;

export const zodUpdateStyleBodyCollectionMax = 64;

export const zodUpdateStyleBodyDescriptionMax = 1024;

export const zodUpdateStyleBodyImageTitleMax = 64;

export const zodUpdateStyleBodyImageDescriptionMax = 512;

export const zodUpdateStyleBodyImagesItemTitleMax = 64;

export const zodUpdateStyleBodyImagesItemDescriptionMax = 512;

export const zodUpdateStyleBody = zod.object({
	id: zod.number(),
	styleFormatter: zod.string().max(zodUpdateStyleBodyStyleFormatterMax).nullish(),
	name: zod.string().max(zodUpdateStyleBodyNameMax).nullish(),
	collection: zod.string().max(zodUpdateStyleBodyCollectionMax).nullish(),
	description: zod.string().max(zodUpdateStyleBodyDescriptionMax).nullish(),
	image: zod
		.object({
			title: zod.string().max(zodUpdateStyleBodyImageTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodUpdateStyleBodyImageDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	images: zod.array(
		zod.object({
			title: zod.string().max(zodUpdateStyleBodyImagesItemTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodUpdateStyleBodyImagesItemDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
	),
	products: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			slug: zod.string().nullish(),
		})
	),
	data: zod
		.object({
			decal: zod
				.object({
					start: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					end: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					fill: zod.string().nullish(),
					imageUrl: zod.string().nullish(),
					crops: zod.record(zod.string(), zod.string()).nullish(),
				})
				.nullish(),
			elements: zod.object({
				background: zod.object({
					size: zod
						.object({
							x: zod.number(),
							y: zod.number(),
						})
						.nullish(),
					fill: zod.string().nullish(),
					align: zod.string().nullish(),
					rects: zod
						.array(
							zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								fill: zod.string().nullish(),
								useEmbedColor: zod.coerce.boolean<boolean>().nullish(),
								opacity: zod.number().nullish(),
							})
						)
						.nullish(),
					imageUrl: zod.string().nullish(),
					radius: zod.number().nullish(),
					opacity: zod.number().nullish(),
				}),
				gradients: zod
					.array(
						zod.object({
							direction: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							bounds: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							stops: zod
								.array(
									zod.object({
										position: zod.number(),
										fill: zod.string(),
									})
								)
								.nullish(),
							opacity: zod.number().nullish(),
						})
					)
					.nullish(),
				name: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				weight: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				label: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				head: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				badge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rank: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rankWithBadge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
			}),
		})
		.nullish(),
	leaderboard: zod
		.object({
			background: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			overlay: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			gradientOpacity: zod.number().nullish(),
			gradientColor: zod.string().nullish(),
			font: zod.string().nullish(),
			name: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			score: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			rank: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			subtitle: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
		})
		.nullish(),
});

/**
 * @summary Remove Image from Style
 */
export const zodDeleteStyleImageParams = zod.object({
	styleId: zod.number(),
	imagePath: zod.string(),
});

/**
 * @summary Get Shop Styles
 */
export const zodGetStylesResponseStyleFormatterMax = 64;

export const zodGetStylesResponseNameMax = 64;

export const zodGetStylesResponseCollectionMax = 64;

export const zodGetStylesResponseDescriptionMax = 1024;

export const zodGetStylesResponseImageTitleMax = 64;

export const zodGetStylesResponseImageDescriptionMax = 512;

export const zodGetStylesResponseImagesItemTitleMax = 64;

export const zodGetStylesResponseImagesItemDescriptionMax = 512;

export const zodGetStylesResponseItem = zod.object({
	id: zod.number(),
	styleFormatter: zod.string().max(zodGetStylesResponseStyleFormatterMax).nullish(),
	name: zod.string().max(zodGetStylesResponseNameMax).nullish(),
	collection: zod.string().max(zodGetStylesResponseCollectionMax).nullish(),
	description: zod.string().max(zodGetStylesResponseDescriptionMax).nullish(),
	image: zod
		.object({
			title: zod.string().max(zodGetStylesResponseImageTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetStylesResponseImageDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
		.nullish(),
	images: zod.array(
		zod.object({
			title: zod.string().max(zodGetStylesResponseImagesItemTitleMax).nullish().describe('Image title'),
			description: zod
				.string()
				.max(zodGetStylesResponseImagesItemDescriptionMax)
				.nullish()
				.describe('Image description'),
			order: zod.number().nullish().describe('Image ordering number'),
			width: zod.number().describe('The original width of the image.'),
			height: zod.number().describe('The original height of the image.'),
			sources: zod
				.record(
					zod.string(),
					zod.object({
						url: zod.string().describe('The fully-qualified public URL for this image variant.'),
						width: zod.number().describe('The width of this image variant in pixels.'),
					})
				)
				.describe(
					'A dictionary of available image sources, keyed by a logical name (e.g., \"small\", \"medium\").'
				),
			url: zod.string().describe('Lowest quality image URL'),
		})
	),
	products: zod.array(
		zod.object({
			id: zod.string(),
			name: zod.string(),
			slug: zod.string().nullish(),
		})
	),
	data: zod
		.object({
			decal: zod
				.object({
					start: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					end: zod.object({
						x: zod.number(),
						y: zod.number(),
					}),
					fill: zod.string().nullish(),
					imageUrl: zod.string().nullish(),
					crops: zod.record(zod.string(), zod.string()).nullish(),
				})
				.nullish(),
			elements: zod.object({
				background: zod.object({
					size: zod
						.object({
							x: zod.number(),
							y: zod.number(),
						})
						.nullish(),
					fill: zod.string().nullish(),
					align: zod.string().nullish(),
					rects: zod
						.array(
							zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								fill: zod.string().nullish(),
								useEmbedColor: zod.coerce.boolean<boolean>().nullish(),
								opacity: zod.number().nullish(),
							})
						)
						.nullish(),
					imageUrl: zod.string().nullish(),
					radius: zod.number().nullish(),
					opacity: zod.number().nullish(),
				}),
				gradients: zod
					.array(
						zod.object({
							direction: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							bounds: zod.object({
								start: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
								end: zod.object({
									x: zod.number(),
									y: zod.number(),
								}),
							}),
							stops: zod
								.array(
									zod.object({
										position: zod.number(),
										fill: zod.string(),
									})
								)
								.nullish(),
							opacity: zod.number().nullish(),
						})
					)
					.nullish(),
				name: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				weight: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				label: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				head: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				badge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rank: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
				rankWithBadge: zod
					.object({
						font: zod.string().nullish(),
						fill: zod.string().nullish(),
						fontSize: zod.number().nullish(),
						position: zod.object({
							x: zod.number(),
							y: zod.number(),
						}),
						maxWidth: zod.number().nullish(),
						maxHeight: zod.number().nullish(),
						outline: zod
							.object({
								width: zod.number().nullish(),
								opacity: zod.number().nullish(),
								fill: zod.string().nullish(),
							})
							.nullish(),
						background: zod
							.object({
								fill: zod.string().nullish(),
								opacity: zod.number().nullish(),
								padding: zod.number().nullish(),
								radius: zod.number().nullish(),
							})
							.nullish(),
					})
					.nullish(),
			}),
		})
		.nullish(),
	leaderboard: zod
		.object({
			background: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			overlay: zod
				.object({
					imageUrl: zod.string().nullish(),
					imageOpacity: zod.string().nullish(),
					fillColor: zod.string().nullish(),
					fillOpacity: zod.number().nullish(),
					borderColor: zod.string().nullish(),
					borderOpacity: zod.number().nullish(),
					align: zod.string().nullish(),
				})
				.nullish(),
			gradientOpacity: zod.number().nullish(),
			gradientColor: zod.string().nullish(),
			font: zod.string().nullish(),
			name: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			score: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			rank: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
			subtitle: zod
				.object({
					color: zod.string().nullish(),
					shadowColor: zod.string().nullish(),
					shadowOpacity: zod.number().nullish(),
					fontWeight: zod.number().nullish(),
				})
				.nullish(),
		})
		.nullish(),
});
export const zodGetStylesResponse = zod.array(zodGetStylesResponseItem);

/**
 * @summary Get Minecraft Block Texture
 */
export const zodGetBlockTextureParams = zod.object({
	blockId: zod.string(),
});

export const zodGetBlockTextureQueryParams = zod.object({
	packs: zod.string().nullish(),
	face: zod.string().nullish(),
});

/**
 * @summary Get Inventory Item Texture Metadata
 */
export const zodGetInventoryItemMetaParams = zod.object({
	inventoryUuid: zod.string(),
	slotId: zod.string(),
});

export const zodGetInventoryItemMetaQueryParams = zod.object({
	packs: zod.string().nullish(),
	sub: zod.string().nullish().describe('Sub slot if nested inventory'),
});

export const zodGetInventoryItemMetaResponse = zod.object({
	packId: zod.string().nullish().describe('Texture Pack ID where the item texture is located'),
	variantKey: zod.string().nullish().describe('Variant key for price lookups'),
	networth: zod
		.object({
			item: zod
				.object({
					skyblockId: zod.string().nullish(),
					name: zod.string().nullish(),
					slot: zod.string().nullish(),
					count: zod.number(),
					damage: zod.number(),
					uuid: zod.string().nullish(),
				})
				.nullish(),
			basePrice: zod.number(),
			price: zod.number(),
			networth: zod.number(),
			calculation: zod
				.array(
					zod.object({
						id: zod.string(),
						type: zod.string(),
						value: zod.number(),
						count: zod.number(),
					})
				)
				.nullish(),
			soulbound: zod.coerce.boolean<boolean>(),
			cosmetic: zod.coerce.boolean<boolean>(),
			liquidNetworth: zod.number(),
			functionalNetworth: zod.number(),
			liquidFunctionalNetworth: zod.number(),
			cosmeticValue: zod.number(),
			illiquidValue: zod.number(),
		})
		.nullish()
		.describe('Networth calculation result for this item'),
});

/**
 * @summary Get Inventory Item Texture
 */
export const zodGetInventoryItemTextureParams = zod.object({
	inventoryUuid: zod.string(),
	slotId: zod.string(),
});

export const zodGetInventoryItemTextureQueryParams = zod.object({
	packs: zod.string().nullish(),
	sub: zod.string().nullish().describe('Sub slot if nested inventory'),
});

/**
 * @summary Get Skyblock Item Texture
 */
export const zodGetItemTextureParams = zod.object({
	itemId: zod.string(),
});

export const zodGetItemTextureQueryParams = zod.object({
	packs: zod.string().nullish(),
});

/**
 * @summary Get Skyblock Pet Texture
 */
export const zodGetPetTextureParams = zod.object({
	petId: zod.string(),
});

export const zodGetPetTextureQueryParams = zod.object({
	packs: zod.string().nullish(),
});

/**
 * Retrieves the icon image for a registered texture pack by its ID.
 * @summary Get Registered Texture Pack Icon
 */
export const zodGetTexturePackIconParams = zod.object({
	packId: zod.string(),
});

/**
 * Get all farming weight constants
 * @summary Get all weight constants
 */
export const zodGetAllWeightsResponse = zod.object({
	crops: zod.record(zod.string(), zod.number()),
	pests: zod.object({
		brackets: zod.record(zod.string(), zod.number()),
		values: zod.record(zod.string(), zod.record(zod.string(), zod.number())),
	}),
});

/**
 * @summary Get farming weight for a profile member
 */
export const zodGetWeightForProfileParams = zod.object({
	playerUuid: zod.string(),
	profileUuid: zod.string(),
});

export const zodGetWeightForProfileQueryCollectionsDefault = false;

export const zodGetWeightForProfileQueryParams = zod.object({
	collections: zod.coerce.boolean<boolean>().nullish(),
});

export const zodGetWeightForProfileResponse = zod.object({
	totalWeight: zod.number(),
	crops: zod.record(zod.string(), zod.number()).nullish(),
	cropWeight: zod.record(zod.string(), zod.number()),
	bonusWeight: zod.record(zod.string(), zod.number()),
	uncountedCrops: zod.record(zod.string(), zod.number()),
	pests: zod.object({
		beetle: zod.number(),
		cricket: zod.number(),
		fly: zod.number(),
		locust: zod.number(),
		mite: zod.number(),
		mosquito: zod.number(),
		moth: zod.number(),
		rat: zod.number(),
		slug: zod.number(),
		earthworm: zod.number(),
		mouse: zod.number(),
		dragonfly: zod.number(),
		firefly: zod.number(),
		mantis: zod.number(),
	}),
	inventory: zod
		.object({
			armor: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			tools: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			equipment: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			accessories: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
		})
		.nullish(),
	lastUpdated: zod.number(),
});

/**
 * @summary Get farming weight for a player's selected profile
 */
export const zodGetWeightForSelectedParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetWeightForSelectedQueryCollectionsDefault = false;

export const zodGetWeightForSelectedQueryParams = zod.object({
	collections: zod.coerce.boolean<boolean>().nullish(),
});

export const zodGetWeightForSelectedResponse = zod.object({
	totalWeight: zod.number(),
	crops: zod.record(zod.string(), zod.number()).nullish(),
	cropWeight: zod.record(zod.string(), zod.number()),
	bonusWeight: zod.record(zod.string(), zod.number()),
	uncountedCrops: zod.record(zod.string(), zod.number()),
	pests: zod.object({
		beetle: zod.number(),
		cricket: zod.number(),
		fly: zod.number(),
		locust: zod.number(),
		mite: zod.number(),
		mosquito: zod.number(),
		moth: zod.number(),
		rat: zod.number(),
		slug: zod.number(),
		earthworm: zod.number(),
		mouse: zod.number(),
		dragonfly: zod.number(),
		firefly: zod.number(),
		mantis: zod.number(),
	}),
	inventory: zod
		.object({
			armor: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			tools: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			equipment: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
			accessories: zod.array(
				zod.object({
					id: zod.number().describe('Old Minecraft id of the item'),
					count: zod.number().describe('Minecraft stack count of the item'),
					damage: zod.number().describe('Minecraft damage value of the item'),
					skyblockId: zod.string().nullish().describe('Skyblock ID of the item'),
					uuid: zod
						.string()
						.nullish()
						.describe('Item UUID to uniquely identify a specific instance of this item'),
					name: zod.string().nullish().describe('Item name, first line of the lore'),
					lore: zod.array(zod.string()).nullish().describe('List of item lore in order'),
					enchantments: zod
						.record(zod.string(), zod.number())
						.nullish()
						.describe('Applied enchantments with their levels'),
					attributes: zod
						.object({
							runes: zod.record(zod.string(), zod.number()).nullish(),
							effects: zod
								.array(
									zod.object({
										level: zod.number(),
										effect: zod.string().nullish(),
										duration_ticks: zod.number(),
									})
								)
								.nullish(),
							necromancer_souls: zod
								.array(
									zod.object({
										mob_id: zod.string().nullish(),
										dropped_instance_id: zod.string().nullish(),
										dropped_mode_id: zod.string().nullish(),
									})
								)
								.nullish(),
							hook: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							line: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							sinker: zod
								.object({
									part: zod.string().nullish(),
									donated_museum: zod.coerce.boolean<boolean>(),
								})
								.nullish(),
							ability_scroll: zod.array(zod.string()).nullish(),
							inventory_data: zod.record(zod.string(), zod.unknown().nullable()).nullish(),
						})
						.nullish()
						.describe('ExtraAttributes not included elsewhere'),
					itemAttributes: zod
						.record(zod.string(), zod.string())
						.nullish()
						.describe('ExtraAtrributes.Attributes for attribute shards'),
					gems: zod
						.record(zod.string(), zod.string().nullable())
						.nullish()
						.describe('Applied gems with gem rarity, null for an unlocked gem slot without a gem'),
					petInfo: zod
						.object({
							type: zod.string(),
							active: zod.coerce.boolean<boolean>(),
							exp: zod.number(),
							level: zod.number(),
							tier: zod.string(),
							candyUsed: zod.number(),
							heldItem: zod.string().nullish(),
							skin: zod.string().nullish(),
						})
						.nullish()
						.describe('Pet info if item is a pet'),
					imageUrl: zod.string().nullish().describe('Image url for the item'),
					textureId: zod
						.string()
						.nullish()
						.describe('Texture id for the item, used to look up the image in our image service'),
					slot: zod.string().nullish().describe('Slot identifier where the item was located, if applicable'),
				})
			),
		})
		.nullish(),
	lastUpdated: zod.number(),
});

/**
 * Get farming weight for all profiles of a player
 * @summary Get farming weight for all profiles of a player
 */
export const zodGetWeightForProfilesParams = zod.object({
	playerUuid: zod.string(),
});

export const zodGetWeightForProfilesQueryCollectionsDefault = false;

export const zodGetWeightForProfilesQueryParams = zod.object({
	collections: zod.coerce.boolean<boolean>().nullish(),
});

export const zodGetWeightForProfilesResponse = zod.object({
	selectedProfileId: zod.string().nullish(),
	profiles: zod.array(
		zod.object({
			profileId: zod.string(),
			profileName: zod.string(),
			totalWeight: zod.number(),
			crops: zod.record(zod.string(), zod.number()).nullish(),
			cropWeight: zod.record(zod.string(), zod.number()),
			bonusWeight: zod.record(zod.string(), zod.number()),
			uncountedCrops: zod.record(zod.string(), zod.number()),
			pests: zod.object({
				beetle: zod.number(),
				cricket: zod.number(),
				fly: zod.number(),
				locust: zod.number(),
				mite: zod.number(),
				mosquito: zod.number(),
				moth: zod.number(),
				rat: zod.number(),
				slug: zod.number(),
				earthworm: zod.number(),
				mouse: zod.number(),
				dragonfly: zod.number(),
				firefly: zod.number(),
				mantis: zod.number(),
			}),
			lastUpdated: zod.number(),
		})
	),
});
